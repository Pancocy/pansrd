const t='{"documentCount":105,"nextId":105,"documentIds":{"0":"/datastru/ds-array.html#数组","1":"/datastru/ds-array.html#_1-数组的常见操作","2":"/datastru/ds-array.html#_1-1-初始化数组","3":"/datastru/ds-array.html#_1-2-访问数组元素","4":"/datastru/ds-array.html#_1-3-插入元素","5":"/datastru/ds-array.html#_1-4-删除元素","6":"/datastru/ds-array.html#_1-5-遍历数组","7":"/datastru/ds-array.html#_1-6-查找元素","8":"/datastru/ds-array.html#_1-7-扩容数组","9":"/datastru/ds-array.html#数组的优、缺点和应用","10":"/datastru/ds-array.html#优点","11":"/datastru/ds-array.html#缺点","12":"/datastru/ds-array.html#应用","13":"/datastru/ds-complexity.html#时间复杂度","14":"/datastru/ds-complexity.html#_1-时间增长趋势","15":"/datastru/ds-complexity.html#_2-判断渐进上界","16":"/datastru/ds-complexity.html#_3-常见时间复杂度类型","17":"/datastru/ds-complexity.html#_3-1-常数阶o-1","18":"/datastru/ds-complexity.html#_3-2-对数阶o-log-n","19":"/datastru/ds-complexity.html#_3-3-线性阶o-n","20":"/datastru/ds-complexity.html#_3-4-线性对数阶","21":"/datastru/ds-complexity.html#_3-5-平方阶","22":"/datastru/ds-complexity.html#_3-6-指数阶","23":"/datastru/ds-complexity.html#_3-7-阶乘","24":"/datastru/ds-datastructure.html#数据结构","25":"/datastru/ds-datastructure.html#_1-逻辑结构-线性和非线性","26":"/datastru/ds-datastructure.html#_2-物理结构-连续和非连续","27":"/datastru/ds-datastructure.html#小结","28":"/datastru/ds-hashalgorithm.html#哈希算法","29":"/datastru/ds-hashalgorithm.html#常见的哈希算法","30":"/datastru/ds-hashalgorithm.html#简单哈希算法的设计","31":"/datastru/ds-hashalgorithm.html#数据结构的哈希值","32":"/datastru/ds-hashflict.html#哈希冲突与扩容","33":"/datastru/ds-hashflict.html#解决哈希冲突","34":"/datastru/ds-hashflict.html#_1-链式地址","35":"/datastru/ds-hashflict.html#_2-开放寻址","36":"/datastru/ds-hashmap.html#什么是hash-table","37":"/datastru/ds-hashmap.html#实现哈希表数据结构","38":"/datastru/ds-hashmap.html#哈希冲突","39":"/datastru/ds-linkedlist.html#_1-链表简介","40":"/datastru/ds-linkedlist.html#_2-链表相关操作","41":"/datastru/ds-linkedlist.html#_2-1-初始化链表","42":"/datastru/ds-linkedlist.html#_2-2-插入节点","43":"/datastru/ds-linkedlist.html#_2-3-删除节点","44":"/datastru/ds-linkedlist.html#_2-4-访问节点","45":"/datastru/ds-linkedlist.html#_2-5-查找节点","46":"/datastru/ds-linkedlist.html#_3-链表vs数组","47":"/datastru/ds-linkedlist.html#_4-链表的类型及应用","48":"/datastru/ds-linkedlist.html#_4-1-常见的链表类型","49":"/datastru/ds-linkedlist.html#_4-2-各类链表的应用","50":"/datastru/ds-list.html#列表-list","51":"/datastru/ds-list.html#_1-列表的常用操作","52":"/datastru/ds-list.html#_1-1-初始化列表","53":"/datastru/ds-list.html#_1-2-访问列表元素","54":"/datastru/ds-list.html#_1-3-遍历列表元素","55":"/datastru/ds-list.html#_1-4-插入和删除元素","56":"/datastru/ds-list.html#_1-5-排序列表","57":"/datastru/ds-list.html#_1-6-组合列表","58":"/datastru/ds-list.html#_2-列表的实现原理","59":"/datastru/ds-queue.html#实现简单结构的队列","60":"/datastru/ds-queue.html#_1-链表实现队列","61":"/datastru/ds-queue.html#_2-数组实现队列","62":"/datastru/ds-stack.html#栈","63":"/datastru/ds-stack.html#_1-认识栈","64":"/datastru/ds-stack.html#_2-栈的实现","65":"/datastru/ds-stack.html#_2-1-基于链表实现栈","66":"/datastru/ds-stack.html#_2-2-基于数组实现栈","67":"/rust/chapter1/controlFlow.html#控制流","68":"/rust/chapter1/controlFlow.html#if-表达式","69":"/rust/chapter1/controlFlow.html#_1-if-表达式的特征","70":"/rust/chapter1/controlFlow.html#_2-在-let-语句中使用-if","71":"/rust/chapter1/controlFlow.html#循环","72":"/rust/chapter1/controlFlow.html#_1-loop循环","73":"/rust/chapter1/controlFlow.html#_2-while条件循环","74":"/rust/chapter1/controlFlow.html#_3-for-循环遍历集合","75":"/rust/chapter1/controlFlow.html#_4-循环标签、continue、break","76":"/rust/chapter1/controlFlow.html#模式匹配","77":"/rust/chapter1/datatype.html#基本数据类型","78":"/rust/chapter1/datatype.html#标量类型","79":"/rust/chapter1/datatype.html#_1-整型","80":"/rust/chapter1/datatype.html#_2-浮点型","81":"/rust/chapter1/datatype.html#_3-数字运算","82":"/rust/chapter1/datatype.html#_4-布尔类型","83":"/rust/chapter1/datatype.html#_5-字符类型","84":"/rust/chapter1/datatype.html#复合类型","85":"/rust/chapter1/datatype.html#_1-元组","86":"/rust/chapter1/datatype.html#_2-数组","87":"/rust/chapter1/func-loop.html#函数","88":"/rust/chapter1/func-loop.html#具有参数的函数","89":"/rust/chapter1/func-loop.html#具有返回值的函数","90":"/rust/chapter1/func-loop.html#语句和表达式","91":"/rust/chapter1/func-loop.html#_1-语句","92":"/rust/chapter1/func-loop.html#_2-表达式","93":"/rust/chapter1/variable.html#变量与可变性","94":"/rust/chapter1/variable.html#常量","95":"/rust/chapter1/variable.html#遮蔽-shadow","96":"/rust/chapter2/ownership.html#所有权的目标","97":"/rust/chapter2/ownership.html#所有权的规则","98":"/rust/chapter2/ownership.html#变量作用域","99":"/rust/chapter2/ownership.html#_1-什么是作用域","100":"/rust/chapter2/ownership.html#_2-string类型","101":"/rust/chapter2/ownership.html#内存与分配","102":"/rust/chapter2/ownership.html#_1-数据的交互方式一-移动-move","103":"/rust/chapter2/ownership.html#_2-数据的交互方式二-克隆","104":"/rust/chapter2/ownership.html#所有权和函数"},"fieldIds":{"title":0,"titles":1,"text":2},"fieldLength":{"0":[1,1,9],"1":[2,1,1],"2":[2,2,42],"3":[3,2,26],"4":[3,2,30],"5":[3,2,20],"6":[3,2,17],"7":[3,2,28],"8":[3,2,24],"9":[2,1,1],"10":[1,2,13],"11":[1,2,15],"12":[1,2,34],"13":[1,1,9],"14":[2,1,48],"15":[2,1,29],"16":[2,1,5],"17":[4,2,20],"18":[6,2,20],"19":[4,2,19],"20":[3,2,30],"21":[3,2,24],"22":[3,2,37],"23":[3,2,36],"24":[1,1,14],"25":[3,1,22],"26":[3,1,27],"27":[1,1,7],"28":[1,1,17],"29":[1,1,14],"30":[1,1,104],"31":[1,1,88],"32":[1,1,26],"33":[1,1,1],"34":[2,1,142],"35":[2,1,1],"36":[3,1,55],"37":[1,1,93],"38":[1,1,9],"39":[2,1,45],"40":[2,1,1],"41":[3,2,33],"42":[2,2,34],"43":[3,2,41],"44":[3,2,47],"45":[3,2,49],"46":[2,1,31],"47":[2,1,1],"48":[3,2,16],"49":[3,2,57],"50":[3,1,15],"51":[2,1,1],"52":[2,2,25],"53":[3,2,19],"54":[3,2,18],"55":[3,2,25],"56":[3,2,4],"57":[3,2,13],"58":[2,1,93],"59":[1,1,14],"60":[2,1,108],"61":[2,1,83],"62":[1,1,10],"63":[2,1,43],"64":[2,1,12],"65":[3,2,88],"66":[2,2,1],"67":[1,1,8],"68":[2,1,1],"69":[3,2,49],"70":[5,2,34],"71":[1,1,7],"72":[2,1,15],"73":[2,1,27],"74":[3,1,47],"75":[4,1,72],"76":[1,1,3],"77":[1,1,10],"78":[1,1,7],"79":[2,1,83],"80":[2,1,22],"81":[2,1,45],"82":[2,1,14],"83":[2,1,21],"84":[1,1,7],"85":[2,1,45],"86":[2,1,52],"87":[1,1,29],"88":[1,1,19],"89":[1,1,35],"90":[1,1,9],"91":[2,1,32],"92":[2,1,25],"93":[1,1,51],"94":[1,1,51],"95":[3,1,72],"96":[1,1,20],"97":[1,1,9],"98":[1,1,1],"99":[2,1,7],"100":[2,1,51],"101":[1,1,44],"102":[5,1,106],"103":[3,1,62],"104":[1,1,74]},"averageFieldLength":[2.1142857142857157,1.3238095238095235,31.904761904761905],"storedFields":{"0":{"title":"数组","titles":[]},"1":{"title":"1. 数组的常见操作","titles":[]},"2":{"title":"1.1 初始化数组","titles":["1. 数组的常见操作"]},"3":{"title":"1.2 访问数组元素","titles":["1. 数组的常见操作"]},"4":{"title":"1.3  插入元素","titles":["1. 数组的常见操作"]},"5":{"title":"1.4 删除元素","titles":["1. 数组的常见操作"]},"6":{"title":"1.5 遍历数组","titles":["1. 数组的常见操作"]},"7":{"title":"1.6 查找元素","titles":["1. 数组的常见操作"]},"8":{"title":"1.7 扩容数组","titles":["1. 数组的常见操作"]},"9":{"title":"数组的优、缺点和应用","titles":[]},"10":{"title":"优点","titles":["数组的优、缺点和应用"]},"11":{"title":"缺点","titles":["数组的优、缺点和应用"]},"12":{"title":"应用","titles":["数组的优、缺点和应用"]},"13":{"title":"时间复杂度","titles":[]},"14":{"title":"1. 时间增长趋势","titles":[]},"15":{"title":"2. 判断渐进上界","titles":[]},"16":{"title":"3. 常见时间复杂度类型","titles":[]},"17":{"title":"3.1 常数阶O(1)","titles":["3. 常见时间复杂度类型"]},"18":{"title":"3.2 对数阶O(log n)","titles":["3. 常见时间复杂度类型"]},"19":{"title":"3.3 线性阶O(n)","titles":["3. 常见时间复杂度类型"]},"20":{"title":"3.4 线性对数阶","titles":["3. 常见时间复杂度类型"]},"21":{"title":"3.5 平方阶","titles":["3. 常见时间复杂度类型"]},"22":{"title":"3.6 指数阶","titles":["3. 常见时间复杂度类型"]},"23":{"title":"3.7 阶乘","titles":["3. 常见时间复杂度类型"]},"24":{"title":"数据结构","titles":[]},"25":{"title":"1 逻辑结构：线性和非线性","titles":[]},"26":{"title":"2 物理结构：连续和非连续","titles":[]},"27":{"title":"小结","titles":[]},"28":{"title":"哈希算法","titles":[]},"29":{"title":"常见的哈希算法","titles":["哈希算法"]},"30":{"title":"简单哈希算法的设计","titles":["哈希算法"]},"31":{"title":"数据结构的哈希值","titles":["哈希算法"]},"32":{"title":"哈希冲突与扩容","titles":[]},"33":{"title":"解决哈希冲突","titles":[]},"34":{"title":"1.链式地址","titles":["解决哈希冲突"]},"35":{"title":"2.开放寻址","titles":["解决哈希冲突"]},"36":{"title":"什么是Hash Table?","titles":[]},"37":{"title":"实现哈希表数据结构","titles":[]},"38":{"title":"哈希冲突","titles":[]},"39":{"title":"1. 链表简介","titles":[]},"40":{"title":"2. 链表相关操作","titles":[]},"41":{"title":"2.1 初始化链表","titles":["2. 链表相关操作"]},"42":{"title":"2.2 插入节点","titles":["2. 链表相关操作"]},"43":{"title":"2.3 删除节点","titles":["2. 链表相关操作"]},"44":{"title":"2.4 访问节点","titles":["2. 链表相关操作"]},"45":{"title":"2.5 查找节点","titles":["2. 链表相关操作"]},"46":{"title":"3. 链表VS数组","titles":[]},"47":{"title":"4. 链表的类型及应用","titles":[]},"48":{"title":"4.1 常见的链表类型","titles":["4. 链表的类型及应用"]},"49":{"title":"4.2 各类链表的应用","titles":["4. 链表的类型及应用"]},"50":{"title":"列表（List）","titles":[]},"51":{"title":"1. 列表的常用操作","titles":[]},"52":{"title":"1.1 初始化列表","titles":["1. 列表的常用操作"]},"53":{"title":"1.2 访问列表元素","titles":["1. 列表的常用操作"]},"54":{"title":"1.3 遍历列表元素","titles":["1. 列表的常用操作"]},"55":{"title":"1.4 插入和删除元素","titles":["1. 列表的常用操作"]},"56":{"title":"1.5 排序列表","titles":["1. 列表的常用操作"]},"57":{"title":"1.6 组合列表","titles":["1. 列表的常用操作"]},"58":{"title":"2. 列表的实现原理","titles":[]},"59":{"title":"实现简单结构的队列","titles":[]},"60":{"title":"1. 链表实现队列","titles":[]},"61":{"title":"2. 数组实现队列","titles":[]},"62":{"title":"栈","titles":[]},"63":{"title":"1. 认识栈","titles":[]},"64":{"title":"2. 栈的实现","titles":[]},"65":{"title":"2.1. 基于链表实现栈","titles":["2. 栈的实现"]},"66":{"title":"2.2. 基于数组实现栈","titles":["2. 栈的实现"]},"67":{"title":"控制流","titles":[]},"68":{"title":"if 表达式","titles":[]},"69":{"title":"1. if 表达式的特征","titles":["if 表达式"]},"70":{"title":"2. 在 let 语句中使用 if","titles":["if 表达式"]},"71":{"title":"循环","titles":[]},"72":{"title":"1. loop循环","titles":["循环"]},"73":{"title":"2. while条件循环","titles":["循环"]},"74":{"title":"3. for 循环遍历集合","titles":["循环"]},"75":{"title":"4. 循环标签、continue、break","titles":["循环"]},"76":{"title":"模式匹配","titles":[]},"77":{"title":"基本数据类型","titles":[]},"78":{"title":"标量类型","titles":[]},"79":{"title":"1. 整型","titles":["标量类型"]},"80":{"title":"2.  浮点型","titles":["标量类型"]},"81":{"title":"3.  数字运算","titles":["标量类型"]},"82":{"title":"4. 布尔类型","titles":["标量类型"]},"83":{"title":"5. 字符类型","titles":["标量类型"]},"84":{"title":"复合类型","titles":[]},"85":{"title":"1. 元组","titles":["复合类型"]},"86":{"title":"2. 数组","titles":["复合类型"]},"87":{"title":"函数","titles":[]},"88":{"title":"具有参数的函数","titles":[]},"89":{"title":"具有返回值的函数","titles":[]},"90":{"title":"语句和表达式","titles":[]},"91":{"title":"1. 语句","titles":["语句和表达式"]},"92":{"title":"2. 表达式","titles":["语句和表达式"]},"93":{"title":"变量与可变性","titles":[]},"94":{"title":"常量","titles":[]},"95":{"title":"遮蔽（Shadow）","titles":[]},"96":{"title":"所有权的目标","titles":[]},"97":{"title":"所有权的规则","titles":[]},"98":{"title":"变量作用域","titles":[]},"99":{"title":"1. 什么是作用域","titles":["变量作用域"]},"100":{"title":"2. String类型","titles":["变量作用域"]},"101":{"title":"内存与分配","titles":[]},"102":{"title":"1. 数据的交互方式一：移动(move)","titles":["内存与分配"]},"103":{"title":"2. 数据的交互方式二：克隆","titles":["内存与分配"]},"104":{"title":"所有权和函数","titles":[]}},"dirtCount":0,"index":[["原因是calculate",{"2":{"104":1}}],["原则",{"2":{"59":1}}],["程序报错",{"2":{"104":1}}],["程序并不会panic",{"2":{"79":1}}],["占用的内存被释放",{"2":{"104":1}}],["占用空间大",{"2":{"46":1}}],["占用空间小",{"2":{"46":1}}],["移出作用域",{"2":{"104":1}}],["移出作用域并调用",{"2":{"104":1}}],["移动就是拷贝一份",{"2":{"102":1}}],["移动",{"0":{"102":1}}],["浅拷贝是没有区别的",{"2":{"103":1}}],["思考一下存储在栈上的数据",{"2":{"103":1}}],["思考一个问题",{"2":{"100":1}}],["克隆",{"0":{"103":1}}],["被清理掉",{"2":{"104":1}}],["被move的数据已经不再可用",{"2":{"102":1}}],["被break跳出",{"2":{"75":1}}],["两次释放",{"2":{"102":1}}],["两层循环的时间复杂度分别为",{"2":{"20":1}}],["真实数据只有一份在堆之上",{"2":{"102":1}}],["已知大小数据的move操作后",{"2":{"102":1}}],["你可能认为会生成s的拷贝并绑定到z上",{"2":{"102":1}}],["你要请求一定大小的空间",{"2":{"96":1}}],["声明变量x的值为5",{"2":{"102":1}}],["声明具有更高的灵活性",{"2":{"95":1}}],["此时s和z在内存中的表现形式如下图所示",{"2":{"102":1}}],["此作用域已结束",{"2":{"101":1}}],["此外每个参数都必须标注类型",{"2":{"88":1}}],["此外浮点数和整数之间可以进行运算",{"2":{"81":1}}],["开始有效",{"2":{"101":1}}],["开放寻址",{"0":{"35":1}}],["释放相应的内存",{"2":{"101":1}}],["向内存管理器返回内存",{"2":{"101":1}}],["运行时向内存分配器申请一定的内存",{"2":{"101":1}}],["运算结果为浮点数",{"2":{"81":1}}],["运算符包括加",{"2":{"81":1}}],["drop",{"2":{"103":1,"104":1}}],["drop函数是一个特殊的函数",{"2":{"102":1}}],["double",{"2":{"102":1}}],["does",{"2":{"100":1,"102":1}}],["dead",{"2":{"60":1}}],["del",{"2":{"58":2}}],["delete",{"2":{"5":1,"43":1,"58":1}}],["debug",{"2":{"34":2,"37":2,"60":2,"65":1}}],["derive",{"2":{"34":2,"37":2,"60":2,"65":1}}],["dec",{"2":{"31":6}}],["defaulthasher",{"2":{"31":7}}],["管辖范围",{"2":{"100":1}}],["属于所有权系统的",{"2":{"100":1}}],["属性",{"2":{"64":1}}],["引入string类型帮助理解作用域",{"2":{"100":1}}],["项",{"2":{"99":1}}],["什么是作用域",{"0":{"99":1}}],["什么是hash",{"0":{"36":1}}],["离开作用域后",{"2":{"97":1}}],["把它标记为已使用",{"2":{"96":1}}],["把索引",{"2":{"4":1}}],["关于长度和容量并不是同样的概念",{"2":{"102":1}}],["关于为什么是管理堆内存而不是栈内存",{"2":{"96":1}}],["关键字+",{"2":{"89":1}}],["关键字告诉程序跳过当前迭代中的任何剩余代码",{"2":{"75":1}}],["关键字来告诉程序何时停止循环",{"2":{"75":1}}],["追踪哪些代码在堆上使用了哪些数据",{"2":{"96":1}}],["准确来说",{"2":{"96":1}}],["恢复成",{"2":{"95":1}}],["来清理堆上分配的内存",{"2":{"102":1}}],["来遮蔽之前的",{"2":{"95":1}}],["来自",{"2":{"59":1,"60":1,"61":1}}],["绑定到",{"2":{"95":1}}],["作用域有两个重要的时间节点",{"2":{"99":1}}],["作用域结束",{"2":{"95":1}}],["作为",{"2":{"31":1}}],["遮蔽相较于",{"2":{"95":1}}],["遮蔽失效",{"2":{"95":1}}],["遮蔽是当以相同的名字再次声明变量时",{"2":{"95":1}}],["遮蔽",{"0":{"95":1}}],["包括全局作用域",{"2":{"94":1}}],["特别是第二部分代码只是偶尔变更了原来的值",{"2":{"93":1}}],["特殊的元组",{"2":{"85":1}}],["接下来尝试用下面的代码来分析",{"2":{"93":1}}],["提供的安全性和简单并发性的方式来编写代码",{"2":{"93":1}}],["默认情况下的变量是不可变的immutable",{"2":{"93":1}}],["初特殊声明外",{"2":{"93":1}}],["初始容量",{"2":{"58":1}}],["初始值应为0",{"2":{"45":1}}],["初始状态为1个细胞",{"2":{"22":1}}],["初始化栈",{"2":{"65":1}}],["初始化该入列节点为option",{"2":{"60":1}}],["初始化队列",{"2":{"60":1}}],["初始化列表的容量",{"2":{"58":1}}],["初始化列表通常分为",{"2":{"52":1}}],["初始化列表",{"0":{"52":1}}],["初始化各个节点",{"2":{"41":1}}],["初始化链表",{"0":{"41":1}}],["初始化值",{"2":{"2":1}}],["初始化值和不初始化值",{"2":{"2":1}}],["初始化数组有两种方式",{"2":{"2":1}}],["初始化数组时计算机会在内存中分配一块连续的空间",{"2":{"2":1}}],["初始化数组",{"0":{"2":1}}],["该语句计算并返回值",{"2":{"92":1}}],["该表达式以语句结尾",{"2":{"92":1}}],["该值被称为单元值",{"2":{"85":1}}],["该值为",{"2":{"32":1}}],["隐式地返回单元类型unit",{"2":{"91":1}}],["多个参数之间使用",{"2":{"88":1}}],["多重判断",{"2":{"69":1}}],["参数的数量可以是多个",{"2":{"88":1}}],["参数说明",{"2":{"42":1,"43":1,"44":1,"45":1}}],["信息",{"2":{"87":1}}],["打印",{"2":{"87":1}}],["打印函数的执行时间固定",{"2":{"17":1}}],["首先",{"2":{"87":1}}],["连接",{"2":{"87":1}}],["连续存储",{"2":{"46":1}}],["连续和非连续",{"0":{"26":1}}],["单词之间使用英文下划线",{"2":{"87":1}}],["单向链表",{"2":{"48":1,"49":1}}],["蛇形命名法",{"2":{"87":1}}],["告诉编译器函数从哪里开始和结束",{"2":{"87":1}}],["函数本身也是一种语句",{"2":{"91":1}}],["函数体由一系列语句构成",{"2":{"90":1}}],["函数可以向调用它的表达式返回值",{"2":{"89":1}}],["函数在声明时可以指定参数",{"2":{"88":1}}],["函数并打印它的信息",{"2":{"87":1}}],["函数中的代码会按顺序执行",{"2":{"87":1}}],["函数",{"0":{"87":1}}],["那它就真的不可改变",{"2":{"93":1}}],["那很可能第一部分代码以不可意料的方式运行",{"2":{"93":1}}],["那就应该使用一个",{"2":{"86":1}}],["那么一个旧的变量在将其赋值给其他变量后仍然可用",{"2":{"103":1}}],["那么要向队尾插入的的下标应为",{"2":{"61":1}}],["那么就无法在内存中访问到该节点了",{"2":{"43":1}}],["那么无论使用合数还是质数",{"2":{"30":1}}],["那么哈希值就会出现聚堆",{"2":{"30":1}}],["那么所有可以被",{"2":{"30":1}}],["那么可以用数组存储",{"2":{"12":1}}],["称之为向量",{"2":{"86":1}}],["没有值或者只有一个值的元组称为单元类型",{"2":{"85":1}}],["创建string",{"2":{"100":1}}],["创建数组有很多方式",{"2":{"86":1}}],["创建元组",{"2":{"85":1}}],["创建hash",{"2":{"36":1}}],["😻",{"2":{"83":1}}],["ℤ",{"2":{"83":1}}],["字面量采用单引号括起来",{"2":{"83":1}}],["字符大小为4字节",{"2":{"83":1}}],["字符",{"2":{"83":1}}],["字符类型",{"0":{"83":1},"2":{"103":1}}],["字符型",{"2":{"78":1}}],["字符串字面量就是被硬编进程序的部分",{"2":{"100":1}}],["字符串字面量是用双引号括起来",{"2":{"83":1}}],["字符串",{"2":{"31":1}}],["显式声明",{"2":{"82":1}}],["示例如下",{"2":{"81":1}}],["示例使用key取模映射index",{"2":{"37":1}}],["除非数据被移动为另一个变量所有",{"2":{"104":1}}],["除",{"2":{"81":1}}],["除声明值外",{"2":{"39":1}}],["乘",{"2":{"81":1}}],["乘法哈希",{"2":{"30":2}}],["减",{"2":{"81":1}}],["y=",{"2":{"81":4}}],["y",{"2":{"80":1,"81":8,"85":6,"91":2,"102":2,"103":4}}],["速度与f32基本相同",{"2":{"80":1}}],["双精度浮点数精度更高",{"2":{"80":1}}],["双向链表的特性使得这种操作变得简单",{"2":{"49":1}}],["双向链表常用于需要快速查找前一个和后一个元素的场景",{"2":{"49":1}}],["双向链表",{"2":{"48":1}}],["区别在于位数不同",{"2":{"80":1}}],["值被清理",{"2":{"97":1}}],["值为",{"2":{"95":1}}],["值得注意的是",{"2":{"94":1}}],["值",{"2":{"79":1}}],["值之间的映射关系实现高效存储和读取数据的一种数据结构",{"2":{"36":1}}],["~",{"2":{"79":4}}],["布尔类型只有两个值",{"2":{"82":1}}],["布尔类型",{"0":{"82":1},"2":{"103":1}}],["布尔型",{"2":{"78":1}}],["布尔量",{"2":{"31":1}}],["浮点数与整数运算结果取整数",{"2":{"81":1}}],["浮点数和字符串的哈希值计算较为复杂",{"2":{"31":1}}],["浮点类型声明的示例",{"2":{"80":1}}],["浮点型就是含有小数部分的整数",{"2":{"80":1}}],["浮点型",{"0":{"80":1},"2":{"78":1}}],["复合类型",{"0":{"84":1},"1":{"85":1,"86":1},"2":{"77":1}}],["标明类型",{"2":{"86":1}}],["标量类型标识单个值",{"2":{"78":1}}],["标量类型",{"0":{"78":1},"1":{"79":1,"80":1,"81":1,"82":1,"83":1},"2":{"77":1}}],["标识loop",{"2":{"75":1}}],["标识其在数组中的位置",{"2":{"0":1}}],["变量在离开作用域之前",{"2":{"99":1}}],["变量出现在作用域之后",{"2":{"99":1}}],["变量作用域",{"0":{"98":1},"1":{"99":1,"100":1}}],["变量",{"2":{"97":1}}],["变量与可变性",{"0":{"93":1}}],["变量类型的不确定性也就更高了",{"2":{"77":1}}],["变量的类型是有效的",{"2":{"70":1}}],["基本加减乘除",{"2":{"81":1}}],["基本数据类型",{"0":{"77":1}}],["基于数组实现栈",{"0":{"66":1}}],["基于数组实现队列的入队出队操作",{"2":{"61":1}}],["基于数组可实现",{"2":{"26":1}}],["基于链表实现栈",{"0":{"65":1}}],["基于链表实现队列的入队出队操作",{"2":{"60":1}}],["基于链表可实现",{"2":{"26":1}}],["基于内容值",{"2":{"31":1}}],["至此程序结束",{"2":{"75":1}}],["跳出``outer",{"2":{"75":1}}],["差异是",{"2":{"75":1}}],["重复执行步骤一",{"2":{"75":1}}],["进入作用域",{"2":{"104":4}}],["进入inner",{"2":{"75":1}}],["进入outer",{"2":{"75":1}}],["进栈和出栈",{"2":{"62":1}}],["回到outer",{"2":{"75":1}}],["满足第一个",{"2":{"75":1}}],["后",{"2":{"75":1}}],["后续再讨论",{"2":{"76":1}}],["后续的分支不会再执行了",{"2":{"69":1}}],["后续会有",{"2":{"52":1}}],["执行流程如下",{"2":{"75":1}}],["执行循环",{"2":{"73":1}}],["z的存储方式会如何改变",{"2":{"102":1}}],["z可为其他不重复名称",{"2":{"85":1}}],["z=",{"2":{"81":1}}],["z被重新声明为10",{"2":{"75":1}}],["z",{"2":{"75":11,"81":6,"83":2,"85":4,"91":1,"92":1,"102":4}}],["与while遍历集合不同的是",{"2":{"74":1}}],["与输入数据n无关",{"2":{"17":1}}],["更简洁的替代方案是for循环",{"2":{"74":1}}],["更新元素",{"2":{"53":1,"58":1}}],["之间使用",{"2":{"89":1}}],["之间不存在公约数",{"2":{"30":1}}],["之前就停止了",{"2":{"74":1}}],["会引起程序panic",{"2":{"86":1}}],["会越界",{"2":{"74":1}}],["会触发panic",{"2":{"70":1}}],["第二步对于有gc的语言",{"2":{"101":1}}],["第二个变量遮蔽了第一个变量",{"2":{"95":1}}],["第一步在创建string时",{"2":{"101":1}}],["第一个分支满足条件了",{"2":{"69":1}}],["第三个",{"2":{"95":1}}],["第5个元素是",{"2":{"74":1}}],["第4个元素是",{"2":{"74":2}}],["第3个元素是",{"2":{"74":2}}],["第2个元素是",{"2":{"74":2}}],["第1个元素是",{"2":{"74":1}}],["第",{"2":{"74":2}}],["条件被满足",{"2":{"75":1}}],["条件",{"2":{"75":1}}],["条件判断为false",{"2":{"73":1}}],["条件为真",{"2":{"73":1}}],["停止循环",{"2":{"73":1}}],["调用break终止循环",{"2":{"73":1}}],["调用",{"2":{"73":1}}],["调度算法",{"2":{"49":1}}],["上述只是单个变量的简单引用场景",{"2":{"101":1}}],["上述操作就可行了",{"2":{"93":1}}],["上述代码中当",{"2":{"75":1}}],["上述代码为双层嵌套的loop循环",{"2":{"75":1}}],["上面的while循环会执行三次",{"2":{"73":1}}],["上面的代码会不断地在控制台打印hello",{"2":{"72":1}}],["上一个节点通过将引用指向下一个节点来访问节点内存地址",{"2":{"39":1}}],["直到我使用",{"2":{"72":1}}],["直至你要求停止",{"2":{"72":1}}],["直接使用x=",{"2":{"95":1}}],["直接使用封装的api操作",{"2":{"56":1}}],["直接创建",{"2":{"86":1}}],["直接访问",{"2":{"6":1}}],["编译时期就知道它的内容",{"2":{"101":1}}],["编译时期就要准确地知道每个变量地类型",{"2":{"70":1}}],["编译器保证了当声明了一个值不会改变时",{"2":{"93":1}}],["编译器会忽略整型溢出",{"2":{"79":1}}],["编译器会检查整型溢出",{"2":{"79":1}}],["编程语言都会为哈希表预留充足的空间防止频繁扩容造成性能损耗",{"2":{"32":1}}],["编程语言通常会为这些数据类型提供内置的哈希算法",{"2":{"31":1}}],["语句同样遮蔽前面的",{"2":{"95":1}}],["语句计算并返回值",{"2":{"92":1}}],["语句不返回值",{"2":{"91":1}}],["语句",{"0":{"91":1},"2":{"90":1}}],["语句和表达式",{"0":{"90":1},"1":{"91":1,"92":1}}],["语句的右侧使用它来将结果赋值给一个变量",{"2":{"70":1}}],["语句中使用",{"0":{"70":1}}],["语法",{"2":{"36":1}}],["类似这样的存储在栈上的类型",{"2":{"103":1}}],["类似x这样的已知大小整型数据是存储在栈上的",{"2":{"103":1}}],["类似于双向链表",{"2":{"49":1}}],["类型是该语言最基本的字母类型",{"2":{"83":1}}],["类型的函数等",{"2":{"69":1}}],["类型",{"2":{"69":1}}],["顺序地执行后续的代码",{"2":{"69":1}}],["表达式可以同样可以作为语句的结束",{"2":{"92":1}}],["表达式可选地组合else",{"2":{"69":1}}],["表达式计算并返回一个值",{"2":{"92":1}}],["表达式的示例",{"2":{"69":1}}],["表达式的判断条件必须为",{"2":{"69":1}}],["表达式的特征",{"0":{"69":1}}],["表达式当条件为true时就执行表达式内的代码",{"2":{"69":1}}],["表达式",{"0":{"68":1,"92":1},"1":{"69":1,"70":1},"2":{"90":1}}],["表示为",{"2":{"85":1}}],["表示这个整数只表示正整数",{"2":{"79":1}}],["表示这个整数是否可以取负数",{"2":{"79":1}}],["表示哈希冲突程度",{"2":{"32":1}}],["表示标识算法操作次数的函数的",{"2":{"14":1}}],["模式匹配来解构",{"2":{"85":1}}],["模式匹配需要用到枚举相关知识",{"2":{"76":1}}],["模式匹配",{"0":{"76":1},"2":{"67":1}}],["控制流",{"0":{"67":1}}],["控制访问范围",{"2":{"44":1}}],["入栈",{"2":{"63":1,"65":1}}],["入队",{"2":{"60":1,"61":1}}],["忽略其一些属性和方法来达到栈的状态",{"2":{"63":1}}],["忽略t",{"2":{"14":1}}],["出栈",{"2":{"63":1,"65":1}}],["出入栈示意图",{"2":{"63":1}}],["出队",{"2":{"60":1,"61":1}}],["出队的时候",{"2":{"60":1}}],["取之前的值并乘上",{"2":{"95":1}}],["取模操作除外",{"2":{"81":1}}],["取模等",{"2":{"81":1}}],["取球只能从顶部一个一个拿出来",{"2":{"63":1}}],["取得原本链表头节点后面的节点",{"2":{"42":1}}],["认识栈",{"0":{"63":1}}],["容量",{"2":{"102":1}}],["容量已满",{"2":{"58":1}}],["容器式",{"2":{"62":1}}],["越过数组尾部后回到头部",{"2":{"61":1}}],["越大越好",{"2":{"30":1}}],["使实现的栈对外仅保持栈的特性",{"2":{"64":1}}],["使其重新回到数组头部",{"2":{"61":1}}],["使用clone函数后",{"2":{"103":1}}],["使用move之后的string类型数据",{"2":{"102":1}}],["使用",{"2":{"75":1,"79":3,"89":1,"101":1}}],["使用while循环也可以遍历合集的元素",{"2":{"74":1}}],["使用extend方法将两个列表组合成一个列表",{"2":{"57":1}}],["使用insert",{"2":{"55":1}}],["使用next建立引用关系",{"2":{"41":1}}],["使用rust定义的链表结构体",{"2":{"39":1}}],["使用大质数作为模数",{"2":{"30":1}}],["代码就不会执行了",{"2":{"75":1}}],["代码实现",{"2":{"60":1,"61":1}}],["代表数组的第一个元素下标",{"2":{"61":1}}],["定义一个front",{"2":{"61":1}}],["始终满足size",{"2":{"61":1}}],["换句话说我们不实现数组的所有特性来实现队列",{"2":{"61":1}}],["屏蔽",{"2":{"61":1}}],["就没有",{"2":{"103":1}}],["就自动触发调用drop函数来释放内存",{"2":{"101":1}}],["就再也不会改变",{"2":{"94":1}}],["就隐式地返回单元值",{"2":{"85":1}}],["就使用continue跳出当前迭代",{"2":{"75":1}}],["就可以在编译时验证在每处使用的",{"2":{"70":1}}],["就让头节点的下一个节点作为新的节点",{"2":{"60":1}}],["就把老节点的指针指向传入的节点",{"2":{"60":1}}],["就能获得目标返回类型vec",{"2":{"37":1}}],["匹配当前队列的尾节点",{"2":{"60":1}}],["q",{"2":{"60":5,"61":12}}],["queue",{"2":{"60":2}}],["quot",{"2":{"34":4}}],["二次释放",{"2":{"102":1}}],["二者都可以通过链表和数组来实现",{"2":{"59":1}}],["二分查找等都主要在数组上进行",{"2":{"12":1}}],["同样进行上述操作",{"2":{"102":1}}],["同时string是可变的",{"2":{"100":1}}],["同时也代表队列的",{"2":{"61":1}}],["同时队尾又可以不断加入需要结账的人",{"2":{"59":1}}],["同删除操作",{"2":{"36":1}}],["队首指针向后移动1",{"2":{"61":1}}],["队首指针",{"2":{"61":1}}],["队首",{"2":{"61":1}}],["队首完成结账后离开队列",{"2":{"59":1}}],["队列已满",{"2":{"61":1}}],["队列为空",{"2":{"61":1}}],["队列容量",{"2":{"61":1}}],["队列长度减一",{"2":{"60":1}}],["队列长度加一",{"2":{"60":1}}],["队列长度",{"2":{"60":1,"61":1}}],["队列示意图",{"2":{"59":1}}],["队列与栈的差异在于栈遵循",{"2":{"59":1}}],["队列",{"2":{"12":1,"24":1,"25":1,"26":2}}],["元素数量+1",{"2":{"58":1}}],["元组中的元素数量和类型就不能改变",{"2":{"85":1}}],["元组是固定长度的",{"2":{"85":1}}],["元组是rust中一个非常特殊的复合类型",{"2":{"85":1}}],["元组",{"0":{"85":1},"2":{"31":1,"103":1}}],["元组的哈希值是对其中每一个元素进行哈希",{"2":{"31":1}}],["超出索引",{"2":{"58":3}}],["超出后自动扩容2倍",{"2":{"32":1}}],["unit",{"2":{"85":2}}],["unwrap",{"2":{"60":2,"63":2,"65":2}}],["u128",{"2":{"79":1}}],["u16",{"2":{"79":1}}],["u64",{"2":{"79":1}}],["u32",{"2":{"79":1,"103":1}}],["u8的取值范围则是",{"2":{"79":1}}],["u8",{"2":{"79":1,"85":3}}],["update",{"2":{"58":1}}],["use",{"2":{"31":1,"34":1,"37":1,"39":1,"60":1,"65":2}}],["usize>",{"2":{"7":1}}],["usize",{"2":{"4":1,"5":1,"8":1,"34":4,"37":2,"58":10,"60":1,"61":3,"65":3,"79":2,"104":1}}],["构造函数",{"2":{"58":1}}],["构成的输入空间映射到数组所有索引构成的输出空间",{"2":{"38":1}}],["再尝试访问s1",{"2":{"104":1}}],["再尝试使用被移动的数据会发生什么",{"2":{"102":1}}],["再次声明则不限制数据类型",{"2":{"95":1}}],["再次使用这个变量时",{"2":{"95":1}}],["再将当前数组的所有元素依次移动至新数组",{"2":{"58":1}}],["再匹配key相等的实现冲突情况下能够正确访问",{"2":{"34":1}}],["相同",{"2":{"102":1}}],["相较于mut声明的变量x",{"2":{"95":1}}],["相较于let声明可以使用函数调用结果",{"2":{"94":1}}],["相较于变量而言",{"2":{"94":1}}],["相应修改该标记",{"2":{"58":1}}],["相关代码如下",{"2":{"20":1}}],["拼接在尾部",{"2":{"57":1}}],["注意",{"2":{"57":1}}],["组合列表",{"0":{"57":1}}],["排序列表",{"0":{"56":1}}],["排序和搜索",{"2":{"12":1}}],["清空列表",{"2":{"55":1}}],["跟数组一样",{"2":{"54":1}}],["有两种方式访问元组中的元素",{"2":{"85":1}}],["有符号类型表示的取值范围是",{"2":{"79":1}}],["有符号类型以i开头即integer",{"2":{"79":1}}],["有符号型",{"2":{"79":1}}],["有关",{"2":{"69":1}}],["有初始值",{"2":{"52":2}}],["有兴趣的读者请自行学习",{"2":{"31":1}}],["长度永远都是小于等于容量的",{"2":{"102":1}}],["长度",{"2":{"79":1,"102":1}}],["长度和扩容问题显然使得实现后得列表具有较大缺陷",{"2":{"50":1}}],["长度不可表",{"2":{"46":1}}],["长度不可变",{"2":{"11":1}}],["倘若使用数组来实现列表",{"2":{"50":1}}],["倘若key能以均匀随机的规律分布",{"2":{"30":1}}],["而rust是无gc的",{"2":{"101":1}}],["而string可变呢",{"2":{"100":1}}],["而string类型则可变",{"2":{"100":1}}],["而shadow需要使用let再次声明才能更改x的值",{"2":{"95":1}}],["而使用shadow通过",{"2":{"95":1}}],["而不能是函数调用的结果或是只能在运行时计算得到的值",{"2":{"94":1}}],["而不是借助索引",{"2":{"74":1}}],["而代码的另一部分更改了该值",{"2":{"93":1}}],["而声明可变时",{"2":{"93":1}}],["而采取一种二进制补码的方式将该数值转换为该类型取值范围内的最小值",{"2":{"79":1}}],["而数组或者链表可以在任何位置添加和删除数据",{"2":{"64":1}}],["而数组可以看作一个长度固定的列表",{"2":{"50":1}}],["而队列更像生活中的排队结账",{"2":{"59":1}}],["而链表则是分散的",{"2":{"26":1}}],["灵活程度远高于链表和数组",{"2":{"50":1}}],["列表长度",{"2":{"58":1}}],["列表的实现原理",{"0":{"58":1}}],["列表的常用操作",{"0":{"51":1},"1":{"52":1,"53":1,"54":1,"55":1,"56":1,"57":1}}],["列表是一种抽象的数据结构概念",{"2":{"50":1}}],["列表",{"0":{"50":1}}],["视频播放器中",{"2":{"49":1}}],["也不会再执行其它代码块了",{"2":{"69":1}}],["也可能会使用环形链表",{"2":{"49":1}}],["也就意味着分配的内存空间大是固定的",{"2":{"8":1}}],["浏览器需要知道用户访问过的前一个和后一个网页",{"2":{"49":1}}],["浏览器历史",{"2":{"49":1}}],["高级数据结构",{"2":{"49":1}}],["其值将通过",{"2":{"104":1}}],["其在内存上的表达",{"2":{"100":1}}],["其他位置插入的时间复杂度为o",{"2":{"55":1}}],["其中图的每个顶点都与一个链表相关联",{"2":{"49":1}}],["其长度就固定了",{"2":{"0":1}}],["邻接表是表示图的一种常用方式",{"2":{"49":1}}],["各类链表的应用",{"0":{"49":1}}],["头节点",{"2":{"60":1}}],["头节点和尾节点相连接形成闭环的链表",{"2":{"48":1}}],["头既是尾",{"2":{"48":1}}],["头尾的概念也就消失了",{"2":{"48":1}}],["环形链表常用于需要周期性操作的场景",{"2":{"49":1}}],["环形链表",{"2":{"48":1}}],["尾插法添加新元素的时候需要遍历链表至尾节点来实现",{"2":{"65":1}}],["尾既是头",{"2":{"48":1}}],["尾节点都指向该节点",{"2":{"60":1}}],["尾节点",{"2":{"60":1}}],["尾节点指向空none",{"2":{"48":1}}],["尾节点结束",{"2":{"48":1}}],["尾部即可",{"2":{"36":1}}],["由此衍生了一种更灵活的字符串类型",{"2":{"100":1}}],["由头节点开始",{"2":{"48":1}}],["由于z只是s的指针copy",{"2":{"102":1}}],["由于列表继承数组特性",{"2":{"53":1}}],["由于其动态扩容性",{"2":{"50":1}}],["由于数组在创建时的长度固定",{"2":{"8":1}}],["由于",{"2":{"2":1,"30":1}}],["分隔",{"2":{"88":1}}],["分别对应f32和f64",{"2":{"80":1}}],["分别对应头插法和尾插法",{"2":{"65":1}}],["分散存储",{"2":{"46":1}}],["分裂n轮后有",{"2":{"22":1}}],["分裂两轮后变为4个",{"2":{"22":1}}],["分裂一轮后变为2个",{"2":{"22":1}}],["`drop`",{"2":{"104":1}}],["`copy`",{"2":{"102":1}}],["`string`",{"2":{"102":1}}],["`s`",{"2":{"102":2}}],["`usize`",{"2":{"95":1}}],["`",{"2":{"46":2,"70":1,"81":2,"91":2,"95":1}}],["具体原因为",{"2":{"93":1}}],["具体因为这样可以告诉编译器你的意图而不需编译器在其他代码部分使用到参数时不明确",{"2":{"88":1}}],["具体如下图所示",{"2":{"46":1}}],["具有返回值的函数",{"0":{"89":1}}],["具有参数的函数",{"0":{"88":1}}],["具有显示声明的bool类型",{"2":{"82":1}}],["具有线性关系还是非线性关系",{"2":{"25":1}}],["效率",{"2":{"46":1}}],["效率较低",{"2":{"11":1}}],["目标链表元素",{"2":{"45":1}}],["返回字符串的长度",{"2":{"104":1}}],["返回值的类型需要在声明函数时就进行标志",{"2":{"89":1}}],["返回不同的类型时",{"2":{"70":1}}],["返回",{"2":{"69":1}}],["返回被删除的元素",{"2":{"58":1}}],["返回此时的索引",{"2":{"45":1}}],["返回其索引的方法",{"2":{"45":1}}],["返回空\\t\\t\\t\\t\\t\\t\\t\\t\\t",{"2":{"43":1}}],["索引访问数组的元素",{"2":{"86":1}}],["索引越界",{"2":{"58":1}}],["索引",{"2":{"44":1,"45":1,"85":1}}],["索引从0开始",{"2":{"3":1,"86":1}}],["起始为头节点",{"2":{"44":1,"45":1}}],["起始节点称为头节点",{"2":{"39":1}}],["动态参数",{"2":{"44":1,"45":1}}],["动态数组在完美继承数组的所有特点的同时",{"2":{"50":1}}],["动态数组dynamic",{"2":{"50":1}}],["动态数组",{"2":{"31":1}}],["遍历列表元素",{"0":{"54":1}}],["遍历每个节点",{"2":{"44":1}}],["遍历数组可以使用索引index来获取元素本身",{"2":{"6":1}}],["遍历数组",{"0":{"6":1}}],["访问数组的元素",{"2":{"86":1}}],["访问数组元素",{"0":{"3":1}}],["访问",{"2":{"85":1}}],["访问元组",{"2":{"85":1}}],["访问元素",{"2":{"53":1}}],["访问索引",{"2":{"53":1}}],["访问列表元素",{"0":{"53":1},"2":{"58":1}}],["访问链表中的元素需要从头节点出发",{"2":{"44":1}}],["访问节点",{"0":{"44":1}}],["获得要删除节点后面的节点",{"2":{"43":1}}],["获得要删除的节点",{"2":{"43":1}}],["获取栈长度",{"2":{"63":1,"65":1}}],["获取栈顶元素",{"2":{"63":1,"65":1}}],["获取队首元素",{"2":{"61":1}}],["获取队列的长度",{"2":{"61":1}}],["获取队列的容量",{"2":{"61":1}}],["获取队列长度",{"2":{"60":1}}],["获取头节点的下一个节点",{"2":{"60":1}}],["获取头节点",{"2":{"60":1}}],["获取列表长度",{"2":{"58":1}}],["获取列表容量",{"2":{"58":1}}],["获取对应key的value",{"2":{"36":1}}],["获取元素",{"2":{"34":2}}],["需插入节点",{"2":{"42":1}}],["需要在堆上分配一块在编译时未知大小的内存来存放内容",{"2":{"101":1}}],["需要了解内存管理",{"2":{"100":1}}],["需要存储指针引用",{"2":{"46":1}}],["需要执行n",{"2":{"44":1}}],["需要将插入位置前一个节点的引用指向该节点",{"2":{"42":1}}],["需要重新计算原本的key在哈希表中映射的位置",{"2":{"32":1}}],["需要注意的是",{"2":{"26":1,"69":1}}],["需要先计算出算法的操作数函数t",{"2":{"14":1}}],["需要遍历数组或者链表找到要删除目标的index",{"2":{"36":1}}],["需要遍历数组",{"2":{"7":1}}],["需要把插入位置后面的元素全部向后移一位",{"2":{"4":1}}],["比如",{"2":{"103":3}}],["比如一筒羽毛球",{"2":{"63":1}}],["比如在音频",{"2":{"49":1}}],["比如在红黑树",{"2":{"49":1}}],["比如操作系统的资源调度",{"2":{"49":1}}],["比如以上代码中的链表可记作链表",{"2":{"41":1}}],["比如链表节点",{"2":{"31":1}}],["我们直接调用即可",{"2":{"52":1}}],["我们需要快速找到最近最少使用的数据",{"2":{"49":1}}],["我们需要访问节点的父节点",{"2":{"49":1}}],["我们就认为这个节点从链表中删除了",{"2":{"43":1}}],["我们就无法在哈希表中查询到原先的",{"2":{"31":1}}],["我们通常将头节点当作链表的代称",{"2":{"41":1}}],["建立节点间的引用关系",{"2":{"41":1}}],["\\tconst",{"2":{"94":2}}],["\\tcount",{"2":{"54":1}}],["\\tlet",{"2":{"63":3,"73":1,"94":1}}],["\\tstack",{"2":{"63":5}}],["\\tstruct",{"2":{"39":1}}],["\\timpl",{"2":{"58":1}}],["\\tvec2",{"2":{"55":4,"57":1}}],["\\tfor",{"2":{"54":2}}],["\\tfn",{"2":{"42":1,"43":1,"44":1,"45":1,"94":1}}],["\\t删除元素",{"2":{"46":1}}],["\\t添加元素",{"2":{"46":1}}],["\\t访问元素",{"2":{"46":1}}],["\\t内存效率",{"2":{"46":1}}],["\\t扩容",{"2":{"46":1}}],["\\t存储方式",{"2":{"46":1}}],["\\t\\tprintln",{"2":{"72":1}}],["\\t\\t\\t",{"2":{"58":1}}],["\\t\\t\\tlet",{"2":{"58":3}}],["\\t\\tif",{"2":{"58":1}}],["\\t\\t数组",{"2":{"46":1}}],["\\t\\t链表",{"2":{"46":1}}],["\\t\\t",{"2":{"42":1,"43":1,"95":1}}],["\\t\\tlet",{"2":{"41":1,"93":2}}],["\\t",{"2":{"39":2,"41":1,"42":3,"43":4,"44":3,"45":4,"46":3,"52":1,"54":2,"55":3,"58":3,"63":6,"69":1,"72":1,"93":2,"94":3,"95":1}}],["还允许在程序运行时进行动态扩容",{"2":{"50":1}}],["还要声明一个引用计数器",{"2":{"39":1}}],["还会缓存其周围的其他数据",{"2":{"10":1}}],["结束节点称为尾节点",{"2":{"39":1}}],["节点值",{"2":{"65":1}}],["节点间通过引用连接",{"2":{"39":1}}],["节点对象",{"2":{"31":1}}],["空间上对比二者的存储方式",{"2":{"46":1}}],["空间效率高",{"2":{"10":1}}],["空闲的内存空间并非都是连续的",{"2":{"39":1}}],["然而当需要的空间比较大时",{"2":{"39":1}}],["然后是",{"2":{"104":1}}],["然后声明变量y的值等于x即同样是5",{"2":{"102":1}}],["然后通过重复使用",{"2":{"95":1}}],["然后赋值给x",{"2":{"92":1}}],["然后调用",{"2":{"87":1}}],["然后进入outer",{"2":{"75":1}}],["然后打印hello",{"2":{"73":1}}],["然后再回到开头重新执行",{"2":{"71":1}}],["然后将该节点的引用指向插入位置的下一个节点",{"2":{"42":1}}],["然后将这些哈希值组合起来",{"2":{"31":1}}],["然后把原数组中的元素复制到新空间中",{"2":{"8":1}}],["然后根据数组元素的类型和数量来确定数组的大小",{"2":{"2":1}}],["理论上存在多个输入对应一个输出的情况",{"2":{"38":1}}],["理想状态下哈希表中进行增删查改的时间复杂度都是o",{"2":{"36":1}}],["理想情况下键值对均匀分布在各个桶中",{"2":{"28":1}}],["发现x即为",{"2":{"37":1}}],["发生哈希冲突的概率越低",{"2":{"32":1}}],["|",{"2":{"102":7}}],["|old",{"2":{"65":1}}],["|cur",{"2":{"60":1}}],["|x|",{"2":{"37":3}}],["|pair|",{"2":{"37":4}}],["实际上",{"2":{"63":1}}],["实际应用中存在更复杂的映射",{"2":{"37":1}}],["实时标识列表内的元素的数量",{"2":{"58":1}}],["实现了",{"2":{"103":1}}],["实现简单结构的队列",{"0":{"59":1}}],["实现哈希表数据结构",{"0":{"37":1}}],["实现哈希表的高效存储和安全性",{"2":{"28":1}}],["实现如下",{"2":{"34":1}}],["实现使用动态数组vec",{"2":{"34":1}}],["核心就是编写hash函数来实现由key",{"2":{"37":1}}],["本质上就是对二者一些",{"2":{"64":1}}],["本质上就是",{"2":{"61":1}}],["本质上是将hash表看作一个大的",{"2":{"34":1}}],["本质",{"2":{"37":1}}],["测试四个方法",{"2":{"37":1}}],["测试扩容",{"2":{"34":1}}],["测试添加相同key的元素",{"2":{"34":1}}],["测试创建",{"2":{"34":1}}],["which",{"2":{"102":1}}],["while条件循环",{"0":{"73":1}}],["while",{"2":{"18":1,"71":1,"73":1,"74":1,"75":1}}],["wrapping",{"2":{"79":2}}],["world结束程序",{"2":{"73":1}}],["world",{"2":{"72":2,"73":1,"87":2,"91":1,"102":3}}],["works",{"2":{"34":1}}],["warning",{"2":{"100":1}}],["warn",{"2":{"60":1}}],["删除头节点",{"2":{"60":1}}],["删除位置后的元素向前移一位",{"2":{"58":1}}],["删除指定索引处的元素",{"2":{"55":1}}],["删除操作在链表的另一端进行",{"2":{"49":1}}],["删除链表节点相较于插入操作更简单",{"2":{"43":1}}],["删除节点的前一节点",{"2":{"43":1}}],["删除节点",{"0":{"43":1}}],["删除",{"2":{"34":1,"36":1}}],["删除元素需要将删除位置后面的元素都往前移动一位",{"2":{"5":1}}],["删除元素",{"0":{"5":1},"2":{"34":1,"55":1,"58":1}}],["新增",{"2":{"34":1}}],["否则就不执行",{"2":{"69":1}}],["否则return",{"2":{"34":1}}],["否则key",{"2":{"34":1}}],["若插入元素时列表容量已满",{"2":{"58":1}}],["若存在则替换",{"2":{"34":1}}],["若超载则扩容",{"2":{"34":1}}],["添加元素",{"2":{"34":1,"36":1}}],["内容存储在堆",{"2":{"100":1}}],["内存会导致内存污染",{"2":{"102":1}}],["内存与分配",{"0":{"101":1},"1":{"102":1,"103":1}}],["内存分配器",{"2":{"96":1}}],["内存管理",{"2":{"96":1}}],["内部遮蔽结束并且",{"2":{"95":1}}],["内的元素重新设置位置",{"2":{"34":1}}],["内访问任何元素",{"2":{"10":1,"53":1}}],["先移出了作用域",{"2":{"104":1}}],["先认识一下drop函数",{"2":{"102":1}}],["先进后出",{"2":{"59":1}}],["先根据扩容倍数创建一个更大的数组",{"2":{"58":1}}],["先暂存原本的bucket",{"2":{"34":1}}],["先前讲到的哈希扩容本质上并不能减少哈希冲突的发生",{"2":{"28":1}}],["pointer",{"2":{"96":1}}],["pop",{"2":{"60":1,"61":1,"63":1,"65":1}}],["plus3",{"2":{"91":2}}],["plus2",{"2":{"91":2,"92":1}}],["plus1",{"2":{"91":2}}],["plus",{"2":{"88":2,"89":2,"92":1,"94":3}}],["peek|",{"2":{"60":1}}],["peek",{"2":{"60":9,"61":4,"65":9}}],["preek",{"2":{"60":2}}],["prev",{"2":{"43":5}}],["println",{"2":{"6":2,"14":2,"17":2,"58":4,"61":2,"69":6,"70":2,"73":2,"74":2,"75":4,"81":9,"85":2,"86":4,"87":2,"88":1,"89":1,"91":1,"93":4,"95":2,"102":3,"103":2,"104":4}}],["put",{"2":{"37":3}}],["push",{"2":{"34":2,"55":2,"60":1,"61":1,"63":4,"65":1}}],["pub",{"2":{"34":7,"37":9,"58":9,"60":9,"61":8,"65":6,"69":1}}],["panic",{"2":{"58":1,"74":1,"86":1,"91":1,"94":1}}],["pair类型",{"2":{"37":1}}],["pair>",{"2":{"34":2,"37":2}}],["pair>>",{"2":{"34":1,"37":1}}],["pair",{"2":{"34":16,"37":8}}],["partialeq>",{"2":{"45":1}}],["partialeq",{"2":{"34":1,"37":1}}],["扩容列表",{"2":{"58":1}}],["扩容机制",{"2":{"58":1}}],["扩容后要对",{"2":{"34":1}}],["扩容",{"2":{"34":1,"58":1}}],["扩容倍率2为初始化参数",{"2":{"34":1}}],["扩容数组需要重新分配一块更大的内存空间",{"2":{"8":1}}],["扩容数组",{"0":{"8":1}}],["即可完成更改",{"2":{"95":1}}],["即全部小写单词",{"2":{"87":1}}],["即使后续分支的条件也满足",{"2":{"69":1}}],["即使对象的内容发生了变化",{"2":{"31":1}}],["即只有单向出口",{"2":{"59":1}}],["即第二节点",{"2":{"42":1}}],["即把发生冲突的元素存在一起",{"2":{"34":1}}],["经由",{"2":{"34":1}}],["里面又存在若干个小",{"2":{"34":1}}],["必要时再进行扩容操作",{"2":{"34":1}}],["想更好地解决哈希冲突",{"2":{"34":1}}],["权宜之计",{"2":{"34":1}}],["链式地址是解决哈希冲突的主流方案之一",{"2":{"49":1}}],["链式地址",{"0":{"34":1}}],["链表节点类",{"2":{"65":1}}],["链表节点由值和指针两部分组成",{"2":{"39":1}}],["链表实现队列",{"0":{"60":1}}],["链表本身就一个列表",{"2":{"50":1}}],["链表中的每个元素都代表与该顶点相连的其他顶点",{"2":{"49":1}}],["链表中插入节点",{"2":{"42":1}}],["链表vs数组",{"0":{"46":1}}],["链表访问元素则相对复杂",{"2":{"44":1}}],["链表的类型及应用",{"0":{"47":1},"1":{"48":1,"49":1}}],["链表的头节点",{"2":{"42":1}}],["链表的每个节点对象由引用",{"2":{"39":1}}],["链表相关操作",{"0":{"40":1},"1":{"41":1,"42":1,"43":1,"44":1,"45":1}}],["链表结构体",{"2":{"39":1,"60":1,"65":1}}],["链表结构体说明",{"2":{"39":1}}],["链表示意图",{"2":{"39":1}}],["链表需要的空间比数组更多",{"2":{"39":1}}],["链表是一种线性数据结构",{"2":{"39":1}}],["链表简介",{"0":{"39":1}}],["链表",{"2":{"24":1,"25":1}}],["解决哈希冲突",{"0":{"33":1},"1":{"34":1,"35":1}}],["负载因子2",{"2":{"34":1}}],["负载因子",{"2":{"32":1}}],["存在更加复杂的数据交互",{"2":{"101":1}}],["存在一个哈希函数处理输入的key来获取对应",{"2":{"37":1}}],["存在一个衡量标准",{"2":{"32":1}}],["存储在堆上的是内容数据",{"2":{"102":1}}],["存储在栈上的数据由一个指向堆的指针",{"2":{"102":1}}],["存储队列元素的数组",{"2":{"61":1}}],["存储空间更多但也更为灵活",{"2":{"48":1}}],["存储数组的空间是连续的",{"2":{"39":1}}],["存储链表的指针和数据通常是分开的",{"2":{"26":1}}],["存储结构并且封装相应操作方法的数据集合",{"2":{"24":1}}],["存储的数据类型相同",{"2":{"0":1}}],["很容易发现存在哈希冲突的情况",{"2":{"32":1}}],["得益于它的不可变性",{"2":{"101":1}}],["得到的",{"2":{"95":1}}],["得到单一的哈希值",{"2":{"31":1}}],["得出其操作数函数",{"2":{"13":1}}],["整型溢出可能导致发生以下两种行为之一",{"2":{"79":1}}],["整型溢出是指给整型变量赋的值超出了变量的取值范围",{"2":{"79":1}}],["整型溢出",{"2":{"79":1}}],["整型还分为有符号和无符号类型",{"2":{"79":1}}],["整型是不包含小数部分的数字",{"2":{"79":1}}],["整型",{"0":{"79":1},"2":{"78":1}}],["整数和浮点数之间不能进行取模运算",{"2":{"81":1}}],["整数和布尔量的哈希值就是其本身",{"2":{"31":1}}],["整数相除向下取整",{"2":{"81":1}}],["整数除法会向下取整",{"2":{"81":1}}],["整数",{"2":{"31":1}}],["整除2时",{"2":{"75":1}}],["整除的",{"2":{"30":1}}],["整除",{"2":{"30":1}}],["用于计算哈希表中的桶索引",{"2":{"31":1}}],["小桶",{"2":{"34":1}}],["小哈",{"2":{"31":2}}],["小数",{"2":{"31":1}}],["小数或字符串等数据类型",{"2":{"31":1}}],["小结",{"0":{"27":1}}],["虽然在多数情况下编译器能够推测出你想要使用的类型",{"2":{"77":1}}],["虽然许多的高级语言都已经封装了列表的实现以及一系列的方法",{"2":{"58":1}}],["虽然自定义对象",{"2":{"31":1}}],["虽然打印程序需要循环1000次",{"2":{"17":1}}],["了",{"2":{"31":1}}],["variants",{"2":{"94":1}}],["variable",{"2":{"93":1,"100":1}}],["vaue",{"2":{"55":1}}],["vals",{"2":{"37":1}}],["val",{"2":{"31":2,"34":6,"37":8,"45":1,"65":2}}],["valuetype>",{"2":{"36":1}}],["value组合",{"2":{"34":1}}],["value",{"2":{"31":2,"34":3,"39":1,"41":3,"58":6,"60":3,"85":1,"88":1,"89":1,"95":2,"102":3,"104":1}}],["vec3",{"2":{"57":2}}],["vec2",{"2":{"52":1,"53":1,"54":3}}],["vec1",{"2":{"52":1}}],["vec",{"2":{"8":1,"34":8,"37":6,"52":4,"57":1,"58":16,"61":2,"63":1}}],["vector",{"2":{"2":2,"86":3}}],["只会执行第一个条件为真的代码块",{"2":{"69":1}}],["只需要取消删除节点上一个节点对其的引用",{"2":{"43":1}}],["只需collect到vec中",{"2":{"37":1}}],["只有不可变对象才可作为哈希表的",{"2":{"31":1}}],["只是能保证在发生哈希冲冲突的情况下能够继续使用哈希表",{"2":{"28":1}}],["选取模数总倾向于大质数",{"2":{"30":1}}],["替换为质数",{"2":{"30":1}}],["假如我们将列表",{"2":{"31":1}}],["假如我们想实现字符到",{"2":{"12":1}}],["假设将",{"2":{"30":1}}],["现在",{"2":{"30":1}}],["恰好满足这种等差数列的数据分布",{"2":{"30":1}}],["9",{"2":{"30":4,"55":1,"75":5}}],["都有一个称其",{"2":{"97":1}}],["都能保证hash分布的均匀性",{"2":{"30":1}}],["都会被映射到",{"2":{"30":1}}],["都可以简化记为n次",{"2":{"14":1}}],["它的值是",{"2":{"103":1}}],["它的哈希值也随之改变",{"2":{"31":1}}],["它可能会导致潜在的安全漏洞",{"2":{"102":1}}],["它可以被",{"2":{"30":1}}],["它允许将多个相同类型的值组合在一起",{"2":{"86":1}}],["它允许将多个不同类型的值组合在一起",{"2":{"85":1}}],["它需要对一组进程进行循环",{"2":{"49":1}}],["它表现的特性为先进先出",{"2":{"49":1}}],["它表现的特性为先进后出",{"2":{"49":1}}],["它们可以将任意长度的输入数据映射到恒定长度的哈希值",{"2":{"29":1}}],["这回产生一个叫做",{"2":{"102":1}}],["这就需要一个方法",{"2":{"101":1}}],["这就是哈希冲突",{"2":{"38":1}}],["这意味着拷贝是非常迅速的",{"2":{"103":1}}],["这意味着",{"2":{"101":1}}],["这意味着在编译期就需要知道所有值的类型",{"2":{"77":1}}],["这取决于两种类型在内存的处理上存在差异",{"2":{"100":1}}],["这些代码一般被称为",{"2":{"99":1}}],["这些数据都是以数组的形式构建的",{"2":{"12":1}}],["这对于代码中很多部分都需要知道一个值的情况特别有用",{"2":{"94":1}}],["这可以使得代码更容易理解",{"2":{"93":1}}],["这可以通过在节点中保存一个指向父节点的引用来实现",{"2":{"49":1}}],["这个方法就是drop",{"2":{"101":1}}],["这个程序首先将数值",{"2":{"95":1}}],["这个概念",{"2":{"94":1}}],["这个",{"2":{"93":1}}],["这个名字就叫做",{"2":{"75":1}}],["这点很重要",{"2":{"93":1}}],["这一特征让你充分利用",{"2":{"93":1}}],["这很好地避免了集合的边界问题",{"2":{"74":1}}],["这使程序更慢",{"2":{"74":1}}],["这时两个drop都会尝试释放堆上的数据",{"2":{"102":1}}],["这时对s进行move操作",{"2":{"102":1}}],["这时第二个",{"2":{"75":1}}],["这时x变为2",{"2":{"75":1}}],["这时x变成0",{"2":{"73":1}}],["这时候使用双向链表就非常合适",{"2":{"49":1}}],["这种循环操作可以通过环形链表来实现",{"2":{"49":1}}],["这里",{"2":{"104":3}}],["这里主要介绍两大类数据类型",{"2":{"77":1}}],["这里使用头插法来不断替换链表的头节点实现栈",{"2":{"65":1}}],["这里通过取余计算",{"2":{"61":1}}],["这里通过固定的倍率来创建更大的新数组",{"2":{"58":1}}],["这里着手实现一个简易列表",{"2":{"58":1}}],["这里是访问所有的元素",{"2":{"44":1}}],["这里用数组的每一个连续空间存储",{"2":{"37":1}}],["这是因为对象的哈希值通常是基于内存地址生成的",{"2":{"31":1}}],["这三个哈希值",{"2":{"30":1}}],["这样并不能清晰直观地展示出质数相较于合数作为模数的优势",{"2":{"30":1}}],["质数仅有1和它本身两个公约数",{"2":{"30":1}}],["^",{"2":{"30":2,"102":1}}],["^=",{"2":{"30":1}}],["keys",{"2":{"37":1}}],["keytype",{"2":{"36":1}}],["key=",{"2":{"30":2}}],["key",{"2":{"30":11,"31":3,"34":21,"37":13,"38":1}}],["here",{"2":{"102":2,"104":1}}],["heart",{"2":{"83":1}}],["head|",{"2":{"65":1}}],["head",{"2":{"42":4,"44":5,"45":4,"65":4}}],["hello算法",{"2":{"59":1,"60":1,"61":1}}],["hello",{"2":{"25":1,"26":1,"31":2,"72":1,"73":1,"87":2,"91":1,"100":1,"101":1,"102":3,"103":1,"104":2}}],["has",{"2":{"102":1}}],["hasn",{"2":{"34":5}}],["hashmap",{"2":{"36":5}}],["hasher",{"2":{"31":19}}],["hash",{"2":{"30":22,"31":15,"37":16,"38":1}}],["旋转哈希",{"2":{"30":2}}],["异或哈希",{"2":{"30":2}}],["利用乘法的不相关性",{"2":{"30":1}}],["加法哈希",{"2":{"30":2}}],["但因为",{"2":{"104":1}}],["但",{"2":{"103":1,"104":1}}],["但实际rust为了避免二次释放的问题",{"2":{"102":1}}],["但事实并非如此",{"2":{"102":1}}],["但对于在编译期不确定内容的文本",{"2":{"101":1}}],["但对于一下要求不高的场景",{"2":{"30":1}}],["但并不是所有场景都适合",{"2":{"100":1}}],["但函数可以通过返回值赋值给变量",{"2":{"91":1}}],["但大部分函数隐式的返回最后的表达式所计算的值",{"2":{"89":1}}],["但当你明确元素数量不需要改变时",{"2":{"86":1}}],["但将会得到非期望的值",{"2":{"79":1}}],["但随着程序的庞大和复杂",{"2":{"77":1}}],["但只有单向出口",{"2":{"62":1}}],["但是为了更好的理解深层原理",{"2":{"58":1}}],["但分配较大时会造成浪费",{"2":{"46":1}}],["但它的内存地址不变",{"2":{"31":1}}],["但它是可哈希的",{"2":{"31":1}}],["但总而言之",{"2":{"30":1}}],["但打印函数的执行时间固定",{"2":{"17":1}}],["简单哈希算法的设计",{"0":{"30":1}}],["下面来着手实现简单的栈结构",{"2":{"64":1}}],["下面是一些栈的常用操作",{"2":{"63":1}}],["下面是已知标准哈希算法的具体信息",{"2":{"29":1}}],["下面实现查找target节点",{"2":{"45":1}}],["下面实现一个时间复杂度为o",{"2":{"3":1,"7":1}}],["和数组",{"2":{"84":1}}],["和大多数语言一样",{"2":{"82":1}}],["和值组成",{"2":{"39":1}}],["和",{"2":{"29":1,"30":1,"45":1,"52":1,"64":1,"79":1,"89":1,"103":1}}],["和o",{"2":{"20":1}}],["moved",{"2":{"102":2}}],["move",{"0":{"102":1},"2":{"102":2,"104":1}}],["mod",{"2":{"34":1,"37":1}}],["modulus",{"2":{"30":12}}],["memory",{"2":{"96":1}}],["methods",{"2":{"37":1}}],["mian",{"2":{"73":1,"91":1,"92":1}}],["mylist",{"2":{"58":2}}],["makes",{"2":{"104":2}}],["match",{"2":{"60":2,"65":1,"67":1,"69":1}}],["main",{"2":{"36":1,"37":1,"52":1,"69":1,"70":1,"72":1,"74":2,"75":2,"80":1,"81":1,"83":1,"87":2,"88":1,"89":1,"93":2,"95":2,"101":1,"102":2,"103":2,"104":2}}],["map",{"2":{"31":1,"36":7,"37":7,"60":1,"65":1}}],["mul",{"2":{"30":1}}],["mutable",{"2":{"100":1}}],["mut变量直接再赋值时不允许改变变量的类型",{"2":{"95":1}}],["mut",{"2":{"4":1,"5":1,"8":2,"14":1,"18":2,"19":1,"20":1,"21":1,"22":2,"23":1,"30":4,"31":12,"34":8,"36":2,"37":3,"41":2,"42":3,"43":3,"44":1,"45":1,"54":1,"58":2,"60":4,"61":2,"63":1,"65":2,"73":1,"74":1,"75":3,"93":1,"95":3}}],["md5",{"2":{"29":1}}],["桶是动态vec",{"2":{"34":1}}],["桶",{"2":{"28":1,"34":2,"37":2}}],["每一个对象节点都存储两个方向的指针",{"2":{"48":1}}],["每一层循环依然可以分别套用第",{"2":{"14":1}}],["每个放进的球只能在顶部",{"2":{"63":1}}],["每个进程被赋予一个时间片",{"2":{"49":1}}],["每个节点散落分布在内存空间中",{"2":{"39":1}}],["每个桶里包含hash每个子项的键值对",{"2":{"37":1}}],["每个小桶用于存储",{"2":{"34":1}}],["每个哈希元素在",{"2":{"28":1}}],["每次累积之前都会对哈希值进行旋转操作",{"2":{"30":1}}],["每轮乘以一个常数",{"2":{"30":1}}],["最大限度地减少堆数据的重复",{"2":{"96":1}}],["最后一个不同点是常量只能设置为常量表达式",{"2":{"94":1}}],["最终进入inner",{"2":{"75":1}}],["最终的哈希值都要对一个大质数取模运算",{"2":{"30":1}}],["最普遍的链表类型",{"2":{"48":1}}],["最差情况下所有键值对都存储到同一个桶中",{"2":{"28":1}}],["最高阶对时间增长的趋势的影响是其他项所不能相比的",{"2":{"15":1}}],["达到最佳查询效率",{"2":{"28":1}}],["优化结构示意图",{"2":{"34":1}}],["优化hash的实现结构以更优地解决哈希冲的问题",{"2":{"34":1}}],["优化哈希表的数据结构以在冲突情况下可以正常使用作为第一策略",{"2":{"34":1}}],["优化哈希函数使无规律分布的key均匀分布在桶中",{"2":{"28":1}}],["优化哈希算法从根源上降低哈希冲突的发生概率",{"2":{"28":1}}],["优点",{"0":{"10":1}}],["哈希冲突",{"0":{"38":1}}],["哈希冲突与扩容",{"0":{"32":1}}],["哈希函数的本质就是把所有",{"2":{"38":1}}],["哈希函数",{"2":{"34":2}}],["哈希扩容需要将原来的桶迁移到新的哈希表中",{"2":{"32":1}}],["哈希值仍然是不变的",{"2":{"31":1}}],["哈希算法的高效性和安全性一直都是优化哈希算法的关键",{"2":{"29":1}}],["哈希算法",{"0":{"28":1},"1":{"29":1,"30":1,"31":1}}],["哈希表中多个输入对应同一输出的情况称为哈希冲突",{"2":{"38":1}}],["哈希表相当高效",{"2":{"36":1}}],["哈希表又称散列表",{"2":{"36":1}}],["哈希表扩容某种意义上是牺牲一定性能的暂时的",{"2":{"34":1}}],["哈希表元素数量和容量的比值",{"2":{"32":1}}],["哈希表的容量capcity越大",{"2":{"32":1}}],["哈希表的",{"2":{"31":1}}],["哈希表",{"2":{"12":1,"24":1,"25":3,"26":2,"49":1}}],["要想进一步探讨这个问题",{"2":{"100":1}}],["要想真正地理解数据",{"2":{"27":1}}],["要改为存储在堆上",{"2":{"96":1}}],["要显式处理溢出的可能性",{"2":{"79":1}}],["要考虑末端元素将失效",{"2":{"4":1}}],["等",{"2":{"26":1,"29":1}}],["维度",{"2":{"26":1}}],["张量",{"2":{"26":1}}],["张量之间的线性代数运算",{"2":{"12":1}}],["所发生的事情便不完全相同了",{"2":{"102":1}}],["所有浮点数类型",{"2":{"103":1}}],["所有整数类型",{"2":{"103":1}}],["所有者",{"2":{"97":2}}],["所有权和函数",{"0":{"104":1}}],["所有权的规则",{"0":{"97":1}}],["所有权的目标",{"0":{"96":1}}],["所有权系统是管理处于堆内存上的数据",{"2":{"96":1}}],["所有冲突的元素都会被放到一个链表中",{"2":{"49":1}}],["所有的数据结构都可以基于数组或者链表",{"2":{"26":1}}],["所以不会有特殊操作",{"2":{"104":1}}],["所以不必亲自跟踪这个值",{"2":{"93":1}}],["所以在后面可继续使用",{"2":{"104":1}}],["所以到这里不再有效",{"2":{"104":1}}],["所以x和y的大小都是已知的",{"2":{"102":1}}],["所以",{"2":{"95":1}}],["所以输出2",{"2":{"81":1}}],["所以可以在",{"2":{"70":1}}],["所以只会输出",{"2":{"69":1}}],["所以时间复杂度为o",{"2":{"44":1}}],["所以对时间复杂度不产生影响",{"2":{"14":1}}],["物理结构是指数据在内存中的存储方式是连续的还是非连续的",{"2":{"26":1}}],["物理结构",{"0":{"26":1}}],["非常的耗时",{"2":{"32":1}}],["非网状结构",{"2":{"25":1}}],["非线性数据结构又可以分为",{"2":{"25":1}}],["非线性数据结构",{"2":{"25":1}}],["网状结构",{"2":{"25":1}}],["网状结构和非网状结构",{"2":{"25":1}}],["逻辑结构主要是描述数据之间的逻辑关系",{"2":{"25":1}}],["逻辑结构",{"0":{"25":1}}],["逻辑结构和物理结构",{"2":{"24":1}}],["​理解数据机构可以从两个层面理解",{"2":{"24":1}}],["树中",{"2":{"49":1}}],["树",{"2":{"24":1,"25":2,"26":2}}],["栈只能在栈顶添加和删除元素",{"2":{"64":1}}],["栈的实现",{"0":{"64":1},"1":{"65":1,"66":1}}],["栈顶被清空",{"2":{"65":1}}],["栈顶",{"2":{"62":1}}],["栈与队列",{"2":{"49":1}}],["栈",{"0":{"62":1},"2":{"24":1,"25":1,"26":2,"62":1,"63":1}}],["个值",{"2":{"74":1}}],["个元素是",{"2":{"74":2}}],["个",{"2":{"23":1}}],["个分裂出",{"2":{"23":1}}],["从此处起",{"2":{"101":1}}],["从0开始",{"2":{"85":1}}],["从栈顶取出元素的操作",{"2":{"63":1}}],["从当前队列头节点开始遍历",{"2":{"60":1}}],["从头节点向后依次访问",{"2":{"45":1}}],["从头节点出发",{"2":{"44":1}}],["从hashmap中移除指定键的键值对",{"2":{"36":1}}],["从而加重哈希冲突",{"2":{"30":1}}],["从而降低哈希冲突的概率",{"2":{"28":1}}],["从而借助高速缓存来提升后续操作的执行速度",{"2":{"10":1}}],["从",{"2":{"23":1}}],["递归实现",{"2":{"23":1}}],["∗1rust",{"2":{"23":1}}],["∗",{"2":{"23":2}}],["方向单一",{"2":{"48":1}}],["方案数量为",{"2":{"23":1}}],["方法使值达到最小值或最大值",{"2":{"79":1}}],["方法返回该值和一个指示是否存在溢出的布尔值",{"2":{"79":1}}],["方法时发生溢出",{"2":{"79":1}}],["方法在所有模式下进行包裹",{"2":{"79":1}}],["方法",{"2":{"2":1,"64":1,"104":1}}],["求其所有可能的排列方案",{"2":{"23":1}}],["给定",{"2":{"23":1}}],["问题",{"2":{"23":1}}],["全排列",{"2":{"23":1}}],["阶乘阶",{"2":{"23":1}}],["阶乘阶对应数学上的",{"2":{"23":1}}],["阶乘",{"0":{"23":1}}],["8位",{"2":{"79":1}}],["8",{"2":{"22":2,"30":1,"34":1,"37":1,"57":1}}],["形成数列",{"2":{"22":1}}],["细胞每轮一分为二",{"2":{"22":1}}],["细胞分裂",{"2":{"22":1}}],["because",{"2":{"102":1}}],["be",{"2":{"100":1}}],["bug",{"2":{"93":2}}],["buckets",{"2":{"37":12}}],["bucket",{"2":{"34":13}}],["byte",{"2":{"83":1}}],["break关键字",{"2":{"75":1}}],["break",{"0":{"75":1},"2":{"73":1,"75":3}}],["brr",{"2":{"2":1}}],["b",{"2":{"49":1}}],["bob",{"2":{"86":2}}],["bool",{"2":{"34":1,"61":1,"65":1,"69":3,"70":1,"82":1,"100":1,"103":1}}],["borrowed",{"2":{"102":1,"104":1}}],["borrow",{"2":{"31":1,"41":2,"42":3,"43":4,"44":1,"45":2,"60":2,"65":2,"102":1}}],["bol",{"2":{"31":6}}],["bits",{"2":{"31":1}}],["base",{"2":{"22":3}}],["生物学的",{"2":{"22":1}}],["指向下一节点的指针",{"2":{"65":1}}],["指向队尾索引",{"2":{"61":1}}],["指定值",{"2":{"89":1}}],["指定位置插入",{"2":{"55":1}}],["指定长度时",{"2":{"2":1}}],["指针",{"2":{"39":1}}],["指数阶",{"0":{"22":1},"2":{"22":1}}],["外层循环和内层循环的时间复杂度都为o",{"2":{"21":1}}],["平方阶通常出现在嵌套循环中",{"2":{"21":1}}],["平方阶的操作数量相对于输入数据大小n以平方级别增长",{"2":{"21":1}}],["平方阶",{"0":{"21":1}}],["线性数据结构",{"2":{"25":1}}],["线性和非线性",{"0":{"25":1}}],["线性对数阶常出现于嵌套循环中",{"2":{"20":1}}],["线性对数阶",{"0":{"20":1},"2":{"20":1}}],["线性阶o",{"0":{"19":1}}],["calculate",{"2":{"104":3}}],["calls",{"2":{"94":1}}],["cannot",{"2":{"93":1}}],["carol",{"2":{"86":2}}],["cat",{"2":{"83":1}}],["capacity翻倍了",{"2":{"34":1}}],["capacity",{"2":{"34":8,"58":14,"61":12}}],["char等",{"2":{"100":1}}],["char",{"2":{"83":2,"103":1}}],["chars",{"2":{"30":4}}],["checked",{"2":{"79":1}}],["c来终止程序",{"2":{"72":1}}],["ctrl",{"2":{"72":1}}],["cur",{"2":{"60":2}}],["clear",{"2":{"55":1}}],["clone",{"2":{"34":3,"37":1,"41":2,"44":1,"45":1,"60":3,"103":1}}],["cpu",{"2":{"49":2}}],["cell",{"2":{"39":1,"60":1,"65":1}}],["cfg",{"2":{"34":1,"37":1}}],["c",{"2":{"30":8,"58":2,"83":1}}],["copy",{"2":{"103":5,"104":3}}],["code",{"2":{"60":1,"93":1}}],["collision",{"2":{"38":1}}],["collect",{"2":{"37":3}}],["collections",{"2":{"31":1,"36":1}}],["continue关键字",{"2":{"75":1}}],["continue",{"0":{"75":1},"2":{"75":2}}],["content",{"2":{"34":3}}],["condition",{"2":{"70":3}}],["const声明只能使用常量表达式",{"2":{"94":1}}],["constants",{"2":{"94":1}}],["constant",{"2":{"94":2}}],["const",{"2":{"30":4}}],["counting",{"2":{"39":1}}],["count",{"2":{"18":3,"19":2,"20":3,"21":2,"22":4,"23":3,"54":3,"75":11}}],["crr",{"2":{"2":1}}],["对于string类型的move",{"2":{"102":1}}],["对于第二步let",{"2":{"102":1}}],["对于运行时不确定其大小的数据",{"2":{"102":1}}],["对于已知固定大小的数据",{"2":{"102":1}}],["对于多个变量的复杂场景",{"2":{"101":1}}],["对于可变的string类型",{"2":{"101":1}}],["对于字面量值",{"2":{"101":1}}],["对于在rust中的任何值",{"2":{"97":1}}],["对应入栈",{"2":{"63":1}}],["对应出栈",{"2":{"63":1}}],["对应队列",{"2":{"49":1}}],["对应栈",{"2":{"49":1}}],["对应的元素存放在数组中的对应位置",{"2":{"12":1}}],["对比链表和数组从空间和时间上出发",{"2":{"46":1}}],["对象的哈希值基于其内存地址生成",{"2":{"31":1}}],["对输入的每个字符的",{"2":{"30":1}}],["对数据结构的种类",{"2":{"27":1}}],["对数阶",{"2":{"18":1}}],["对数阶o",{"0":{"18":1}}],["算法中",{"2":{"49":1}}],["算法",{"2":{"25":1,"26":1,"31":2,"49":1}}],["算法属于线性阶",{"2":{"19":1}}],["算法属于对数阶",{"2":{"18":1}}],["算法属于常数阶",{"2":{"17":1}}],["算法函数的时间增长趋势",{"2":{"13":1}}],["常量声明必须标注类型",{"2":{"94":1}}],["常量可以在任意作用域内声明",{"2":{"94":1}}],["常量用const声明",{"2":{"94":1}}],["常量一旦声明",{"2":{"94":1}}],["常量不存在",{"2":{"94":1}}],["常量",{"0":{"94":1}}],["常见操作",{"2":{"36":1}}],["常见标准哈希算法",{"2":{"29":1}}],["常见的复合类型有元组",{"2":{"84":1}}],["常见的链表类型",{"0":{"48":1}}],["常见的哈希算法",{"0":{"29":1}}],["常见的数据类型有",{"2":{"24":1}}],["常见时间复杂度类型图",{"2":{"16":1}}],["常见时间复杂度类型",{"0":{"16":1},"1":{"17":1,"18":1,"19":1,"20":1,"21":1,"22":1,"23":1}}],["常数阶o",{"0":{"17":1}}],["趋势",{"2":{"16":1}}],["gc会自动记录和标记数据的状态",{"2":{"101":1}}],["gt",{"2":{"15":1,"37":1,"89":1}}],["gen",{"2":{"3":1}}],["get",{"2":{"3":1,"34":3,"36":1,"37":3,"58":3}}],["操作数",{"2":{"15":1}}],["应选择合适的容量",{"2":{"58":1}}],["应该移动函数里",{"2":{"104":1}}],["应该搞清楚以下概念",{"2":{"58":1}}],["应该深度的学习每一种数据结构类型",{"2":{"27":1}}],["应为当n趋于无穷大是",{"2":{"15":1}}],["应用",{"0":{"12":1}}],["判断条件必须为bool类型",{"2":{"69":1}}],["判断栈是否空",{"2":{"65":1}}],["判断栈是否为空",{"2":{"63":1}}],["判断队列长度是否为0",{"2":{"61":1}}],["判断队列是否为空",{"2":{"60":1}}],["判断是否已经存在相同的key",{"2":{"34":1}}],["判断是否超载",{"2":{"34":1}}],["判断是否需要扩容",{"2":{"34":1}}],["判断渐进上界",{"0":{"15":1}}],["判断操作数函数的渐进上界",{"2":{"13":1}}],["jack",{"2":{"34":2}}],["j",{"2":{"14":1,"21":1}}],["技巧",{"2":{"14":4}}],["点的技巧",{"2":{"14":1}}],["点和第",{"2":{"14":1}}],["总操作数量等于外层循环和内层循环操作数量之积",{"2":{"14":1}}],["循环标签",{"0":{"75":1},"2":{"75":1}}],["循环遍历集合",{"0":{"74":1}}],["循环是指遍历执行循环体中的代码直至结尾",{"2":{"71":1}}],["循环",{"0":{"71":1},"1":{"72":1,"73":1,"74":1,"75":1},"2":{"67":1}}],["循环到栈尾实现出栈",{"2":{"65":1}}],["循环实现",{"2":{"18":1,"22":1}}],["循环嵌套时使用乘法",{"2":{"14":1}}],["循环2n次",{"2":{"14":1}}],["省略所有系数",{"2":{"14":1}}],["因为字符串字面量是不可变的",{"2":{"100":1}}],["因为这种情况很可能导致",{"2":{"93":1}}],["因为在第二行第一次声明该变量时",{"2":{"93":1}}],["因为编译器增加了运行时代码来对每次循环进行条件检查",{"2":{"74":1}}],["因为rust在",{"2":{"70":1}}],["因为rust不会隐式地转换数据地类型",{"2":{"69":1}}],["因为链表节点间指针引用的单向性",{"2":{"43":1}}],["因为它们都与n无关",{"2":{"14":1}}],["因链表节点除存储值外还存储引用",{"2":{"39":1}}],["因此收到上述报错信息",{"2":{"102":1}}],["因此move之后x仍旧有效",{"2":{"102":1}}],["因此他们都被压入了栈中",{"2":{"102":1}}],["因此它是高效且易用的",{"2":{"101":1}}],["因此它需要被分配到堆上",{"2":{"100":1}}],["因此其的存储位置在栈上",{"2":{"100":1}}],["因此语句不能赋值给变量",{"2":{"91":1}}],["因此声明数据时进行类型标注是有必要的",{"2":{"77":1}}],["因此当前迭代后续的",{"2":{"75":1}}],["因此想要通过二者实现栈",{"2":{"64":1}}],["因此想获得算法的时间复杂度",{"2":{"14":1}}],["因此引入",{"2":{"50":1}}],["因此引入链表这种相较于数组更灵活的数据结构",{"2":{"39":1}}],["因此在定义节点对象时",{"2":{"39":1}}],["因此在相同数据量下",{"2":{"39":1}}],["因此扩容哈希表可以一定程度有效避免哈希冲突",{"2":{"32":1}}],["因此输出的哈希值的均匀性会明显提升",{"2":{"30":1}}],["因此总体的时间复杂度为",{"2":{"21":1}}],["因此该算法的时间复杂度是常数阶",{"2":{"17":2}}],["因此该算法的的时间复杂度",{"2":{"15":1}}],["因此只能使用常量来指定长度",{"2":{"2":1}}],["🎉一些推算操作数的技巧",{"2":{"14":1}}],["渐进上界",{"2":{"14":1}}],["ownership",{"2":{"104":2}}],["occurs",{"2":{"102":1}}],["of",{"2":{"95":2,"102":1,"104":1}}],["or",{"2":{"89":1}}],["overflowing",{"2":{"79":1}}],["outer",{"2":{"75":2}}],["ok",{"2":{"60":1,"65":1}}],["one",{"2":{"36":1,"43":1}}],["old",{"2":{"34":2,"60":2,"65":2}}],["o",{"2":{"14":1,"15":8,"20":1,"21":1,"46":6}}],["option",{"2":{"7":1,"34":1,"37":2,"39":1,"60":3,"65":4}}],["通俗的讲就是一段代码在程序中的有效范围",{"2":{"99":1}}],["通常应用于文本常见",{"2":{"100":1}}],["通常适用于一些永远不会改变的值",{"2":{"94":1}}],["通常为0",{"2":{"32":1}}],["通常情况下",{"2":{"32":1}}],["通常将线性时间复杂度记为",{"2":{"14":1}}],["通过重复使用let声明实现遮蔽变量",{"2":{"95":1}}],["通过重写对象的哈希方法",{"2":{"31":1}}],["通过运行上述代码",{"2":{"93":1}}],["通过",{"2":{"85":1,"86":1}}],["通过将判断条件设定问集合索引的边界实现循环访问",{"2":{"74":1}}],["通过链表实现栈要考虑使用链表的头节点还是尾节点作为栈顶",{"2":{"65":1}}],["通过取余操作实现",{"2":{"61":1}}],["通过pair",{"2":{"37":1}}],["通过一个数组简单实现hash数据结构",{"2":{"37":1}}],["通过构建键",{"2":{"36":1}}],["通过对数据结构在逻辑层面和物理层面上的不同理解",{"2":{"27":1}}],["通过索引访问",{"2":{"6":1}}],["通过索引index访问数组中的元素",{"2":{"3":1}}],["时间内完成操作",{"2":{"55":1}}],["时间内访问任意元素",{"2":{"44":1}}],["时间片轮转调度算法是一种常见的",{"2":{"49":1}}],["时间片轮转调度算法",{"2":{"49":1}}],["时间上对比它们的操作方法的时间复杂度",{"2":{"46":1}}],["时间增长趋势",{"0":{"14":1}}],["时间复杂度o",{"2":{"36":2}}],["时间复杂度退化至o",{"2":{"28":1}}],["时间复杂度为2^n",{"2":{"22":1}}],["时间复杂度为o",{"2":{"11":1,"45":1}}],["时间复杂度类型是根据输入数据n的大小与算法执行时间",{"2":{"16":1}}],["时间复杂度由t",{"2":{"15":1}}],["时间复杂度",{"0":{"13":1},"2":{"15":1}}],["或者深",{"2":{"103":1}}],["或者循环执行某段代码",{"2":{"67":1}}],["或者链表",{"2":{"36":1}}],["或者二者组合而实现",{"2":{"26":1}}],["或者直接遍历元素本身",{"2":{"6":1}}],["或推断",{"2":{"13":1}}],["根据条件是否为true来决定是否执行某段代码",{"2":{"67":1}}],["根据传入的入队元素",{"2":{"60":1}}],["根据",{"2":{"13":1}}],["根据索引实现随机抽样",{"2":{"12":1}}],["计算并产生一个值",{"2":{"90":1}}],["计算队尾指针",{"2":{"61":1}}],["计算时间复杂度通常需要两个步骤",{"2":{"13":1}}],["计算机不仅会加载它",{"2":{"10":1}}],["图三",{"2":{"102":1}}],["图二",{"2":{"102":1}}],["图一",{"2":{"100":1}}],["图5",{"2":{"59":1}}],["图等",{"2":{"26":1}}],["图等数据结构",{"2":{"12":1}}],["图3",{"2":{"25":1,"26":1}}],["图选自",{"2":{"25":1,"26":1}}],["图",{"2":{"24":1,"25":2,"26":1,"49":1}}],["图的邻接矩阵表示实际上是一个二维数组",{"2":{"12":1}}],["例如",{"2":{"12":1,"14":1,"29":1,"79":1}}],["堆",{"2":{"12":1,"24":1,"25":2,"26":2}}],["数字运算",{"0":{"81":1}}],["数量标记",{"2":{"58":1}}],["数据的交互方式二",{"0":{"103":1}}],["数据的交互方式一",{"0":{"102":1}}],["数据流可能会被分成多个缓冲块并放入一个环形链表",{"2":{"49":1}}],["数据缓冲区",{"2":{"49":1}}],["数据结构的哈希值",{"0":{"31":1}}],["数据结构是在计算机中具有一定逻辑关系",{"2":{"24":1}}],["数据结构",{"0":{"24":1}}],["数据结构实现",{"2":{"12":1}}],["数组会更加高效",{"2":{"86":1}}],["数组中的元素数量和类型就不能改变",{"2":{"86":1}}],["数组中元素通过索引",{"2":{"0":1}}],["数组队列结构体",{"2":{"61":1}}],["数组实现队列",{"0":{"61":1},"2":{"61":2}}],["数组与链表的效率对比",{"2":{"46":1}}],["数组可以用于实现栈",{"2":{"12":1}}],["数组可通过索引在时间o",{"2":{"10":1}}],["数组是固定长度的",{"2":{"86":1}}],["数组是rust中一个重要的复合类型",{"2":{"86":1}}],["数组是神经网络编程中最常使用的数据结构",{"2":{"12":1}}],["数组是排序和搜索算法最常用的数据结构",{"2":{"12":1}}],["数组需要预先分配固定大小的内存空间",{"2":{"11":1}}],["数组为数据分配了连续的内存块",{"2":{"10":1}}],["数组的长度是固定的",{"2":{"11":1}}],["数组的插入和删除操作需要大量移动元素",{"2":{"11":1}}],["数组的优",{"0":{"9":1},"1":{"10":1,"11":1,"12":1}}],["数组的常见操作",{"0":{"1":1},"1":{"2":1,"3":1,"4":1,"5":1,"6":1,"7":1,"8":1}}],["数组将数据存储在计算机中一段连续的存储空间",{"2":{"0":1}}],["数组",{"0":{"0":1,"86":1},"2":{"24":1,"25":1,"100":1}}],["矩阵",{"2":{"12":1,"26":1}}],["神经网络中大量使用了向量",{"2":{"12":1}}],["机器学习",{"2":{"12":1}}],["码累积到一个哈希值中",{"2":{"30":1}}],["码累积到哈希值中",{"2":{"30":1}}],["码进行相加",{"2":{"30":1}}],["码值作为索引",{"2":{"12":1}}],["码的映射",{"2":{"12":1}}],["则返回",{"2":{"79":1}}],["则会发生整型溢出",{"2":{"79":1}}],["则会造成很大的开销",{"2":{"11":1}}],["则会造成浪费",{"2":{"11":1}}],["则更新栈顶为下一个元素",{"2":{"65":1}}],["则令头",{"2":{"60":1}}],["则需要进行扩容",{"2":{"58":1}}],["则添加到对应小桶的尾部",{"2":{"34":1}}],["则可以将字符的",{"2":{"12":1}}],["可能会造成变量的移动或者复制",{"2":{"104":1}}],["可能造成内存浪费",{"2":{"11":1}}],["可增长的文本片段",{"2":{"101":1}}],["可变",{"2":{"94":1}}],["可选地以表达式结尾",{"2":{"90":1}}],["可从函数中提前返回",{"2":{"89":1}}],["可基于链表和数组实现",{"2":{"50":1}}],["可扩展",{"2":{"46":1}}],["可实现基于内容生成哈希值",{"2":{"31":1}}],["可以以表达式结尾来返回值",{"2":{"92":1}}],["可以接收参数",{"2":{"87":1}}],["可以使用通用函数clone实现",{"2":{"103":1}}],["可以使用标准库针对原始数字类型提供的以下一系列方法",{"2":{"79":1}}],["可以使用该语言的数组或者链表",{"2":{"63":1}}],["可以使用数组作为查找表",{"2":{"12":1}}],["可以理为一种具有双向数据方向",{"2":{"62":1}}],["可以不断加入新的节点",{"2":{"60":1}}],["可以通过索引或者直接访问列表元素的方式来遍历列表",{"2":{"54":1}}],["可以像访问数组元素那样通过索引在o",{"2":{"53":1}}],["可以动态扩展长度",{"2":{"50":1}}],["可以是整数",{"2":{"31":1}}],["可以最大化地保证哈希值的均匀分布",{"2":{"30":1}}],["可以设计一些简单的哈希算法来满足要求",{"2":{"30":1}}],["查找链表节点是一种线性查找",{"2":{"45":1}}],["查找节点",{"0":{"45":1}}],["查找",{"2":{"36":1}}],["查找表",{"2":{"12":1}}],["查找元素",{"0":{"7":1}}],["归并排序",{"2":{"12":1}}],["快速排序",{"2":{"12":1}}],["并返回一个表示该位置地址的指针",{"2":{"96":1}}],["并返回被移除的值",{"2":{"36":1}}],["并及时清理不再使用的数据",{"2":{"96":1}}],["并取原来的值加上",{"2":{"95":1}}],["并且它的大小还可能随着程序运行而改变",{"2":{"101":1}}],["并且必须标注常量类型",{"2":{"94":1}}],["并且按照一定的顺序排列",{"2":{"0":1}}],["并未标识其为可变",{"2":{"93":1}}],["并转到下一个迭代",{"2":{"75":1}}],["并将头节点的下一节点作为新的头节点",{"2":{"60":1}}],["并根据与初始容量的比较决定是否扩容",{"2":{"58":1}}],["并传递动态head",{"2":{"45":1}}],["并生成一个随机序列",{"2":{"12":1}}],["随机访问",{"2":{"12":1}}],["如下图所示",{"2":{"100":1}}],["如下所示",{"2":{"95":1}}],["如元组",{"2":{"100":1}}],["如函数本身就是语句",{"2":{"92":1}}],["如let",{"2":{"85":1}}],["如u8时为256",{"2":{"79":1}}],["如将一个u8赋值",{"2":{"79":1}}],["如i8的取值范围为",{"2":{"79":1}}],["如数组可以从任意位置删除",{"2":{"61":1}}],["如数组在内存中的空间一般是连续的",{"2":{"26":1}}],["如何避免哈希冲突",{"2":{"32":1}}],["如果一个类型实现了",{"2":{"103":1}}],["如果想深拷贝string在堆上的数据",{"2":{"103":1}}],["如果代码的一部分假设某个值永远不会更改",{"2":{"93":1}}],["如果尝试改变会发生什么",{"2":{"93":1}}],["如果不确定是使用数组还是",{"2":{"86":1}}],["如果不为空",{"2":{"60":1}}],["如果表达式不返回任何其他值",{"2":{"85":1}}],["如果使用",{"2":{"79":1}}],["如果存在会导致程序panic",{"2":{"79":1}}],["如果索引值或测试条件不正确会导致程序",{"2":{"74":1}}],["如果有下一个元素",{"2":{"65":1}}],["如果队列为空",{"2":{"60":1}}],["如果队列不为空",{"2":{"60":1}}],["如果只有头节点",{"2":{"43":1}}],["如果将模数从9替换为13",{"2":{"30":1}}],["如果输入",{"2":{"30":1}}],["如果我们想随机抽取一些样本",{"2":{"12":1}}],["如果分配的空间超过需要存储的数据",{"2":{"11":1}}],["如需要扩容",{"2":{"11":1}}],["无需用户关心",{"2":{"101":1}}],["无需全部解除头尾节点的引用",{"2":{"43":1}}],["无符号类型表示的取值范围是",{"2":{"79":1}}],["无符号类型以u开头即unsigned",{"2":{"79":1}}],["无符号型",{"2":{"79":1}}],["无限循环执行表达式里的代码块",{"2":{"72":1}}],["无初始值",{"2":{"52":2}}],["无法匹配之前的位置导致无法访问",{"2":{"34":1}}],["无法动态调整",{"2":{"11":1}}],["无须额外的结构开销",{"2":{"10":1}}],["插入和删除元素",{"0":{"55":1}}],["插入和删除操作效率低",{"2":{"11":1}}],["插入节点",{"0":{"42":1}}],["插入",{"2":{"36":1}}],["插入元素",{"0":{"4":1},"2":{"61":1}}],["缺点",{"0":{"11":1}}],["缺点和应用",{"0":{"9":1},"1":{"10":1,"11":1,"12":1}}],["缓存局部性",{"2":{"10":1}}],["支持随机访问",{"2":{"10":1}}],["s2",{"2":{"103":3,"104":2}}],["s1将继续可用",{"2":{"103":1}}],["s1",{"2":{"103":4,"104":4}}],["src",{"2":{"102":1}}],["srtuct",{"2":{"65":1}}],["s分为两部分分别存储在栈和堆上",{"2":{"102":1}}],["s的存储方式是按照图一的方式",{"2":{"102":1}}],["sapces",{"2":{"95":1}}],["saturating",{"2":{"79":1}}],["spaces",{"2":{"95":5}}],["scope",{"2":{"95":1}}],["s",{"2":{"88":1,"89":1,"100":1,"101":4,"102":11,"104":9}}],["shellerror",{"2":{"102":1}}],["shellcount",{"2":{"75":1}}],["shellx",{"2":{"75":1}}],["shell第1个元素是",{"2":{"74":1}}],["shell第0个元素是",{"2":{"74":1}}],["shadow更加的灵活",{"2":{"95":1}}],["shadow更加不容易更改变量的值",{"2":{"95":1}}],["shadow",{"0":{"95":1},"2":{"95":1}}],["sha",{"2":{"29":3}}],["six",{"2":{"70":1}}],["size",{"2":{"8":2,"34":6,"58":14,"60":7,"61":10,"65":7}}],["second",{"2":{"69":1,"86":1}}],["self",{"2":{"34":30,"37":17,"58":40,"60":20,"61":24,"65":17}}],["slef",{"2":{"58":1}}],["sort",{"2":{"56":1}}],["some",{"2":{"7":1,"34":5,"37":4,"41":2,"42":1,"43":1,"44":1,"45":1,"60":4,"65":3,"104":8}}],["super",{"2":{"34":1,"37":1}}],["statement",{"2":{"90":1}}],["stacklist",{"2":{"65":2}}],["stack",{"2":{"62":1,"63":5,"65":11}}],["stk",{"2":{"65":1}}],["std",{"2":{"31":2,"36":1,"39":2,"60":2,"65":2}}],["str表示每个元素的类型",{"2":{"86":1}}],["str`",{"2":{"70":1,"95":1}}],["string是大小不固定且可变",{"2":{"100":1}}],["string类型的move更像是其他语言中的浅拷贝",{"2":{"102":1}}],["string类型move后再使用会发生什么",{"2":{"102":1}}],["string类型move",{"2":{"102":2}}],["string类型数据在内存的表现形式",{"2":{"100":1}}],["string类型基于字符串字面量实现",{"2":{"100":1}}],["string类型",{"0":{"100":1}}],["string>",{"2":{"36":1,"37":2}}],["string",{"2":{"34":6,"36":3,"37":5,"100":2,"101":2,"102":3,"103":2,"104":9}}],["structs",{"2":{"94":1}}],["struct",{"2":{"34":2,"37":2,"60":2,"61":1,"65":1}}],["str",{"2":{"30":4,"31":6,"34":1,"37":1,"86":1}}],["square",{"2":{"21":1}}],["75",{"2":{"32":1}}],["7",{"0":{"8":1,"23":1},"2":{"75":1}}],["x未发生移动且继续生效",{"2":{"103":1}}],["x的移动是在栈上进行的copy",{"2":{"102":1}}],["x恢复为6",{"2":{"95":1}}],["x=",{"2":{"81":1}}],["x+y",{"2":{"81":1}}],["x+y=",{"2":{"81":1}}],["x变为1",{"2":{"75":1}}],["x",{"2":{"37":2,"70":2,"73":5,"74":4,"75":7,"80":1,"81":10,"85":7,"89":3,"91":1,"92":1,"93":13,"94":2,"95":16,"102":7,"103":5,"104":6}}],["xor",{"2":{"30":1}}],["x3c",{"2":{"7":1,"20":1,"30":2,"34":4,"36":2,"37":7,"39":3,"42":7,"43":4,"44":7,"45":4,"52":2,"58":1,"60":15,"61":1,"65":13,"74":1,"75":1}}],["x26",{"2":{"2":2,"3":1,"4":1,"5":1,"6":1,"7":1,"8":1,"30":5,"31":8,"34":10,"36":2,"37":17,"42":1,"43":1,"44":2,"45":2,"54":1,"58":8,"60":6,"61":6,"65":5,"70":1,"86":2,"95":1}}],["twice",{"2":{"93":1}}],["two",{"2":{"36":1}}],["third",{"2":{"86":1}}],["the",{"2":{"86":4,"95":3,"102":1,"104":1}}],["three",{"2":{"36":1}}],["thread",{"2":{"3":1}}],["type声明",{"2":{"89":1}}],["type",{"2":{"85":1,"91":1,"102":1}}],["trait的类型",{"2":{"103":1}}],["trait标注概念",{"2":{"103":1}}],["trait",{"2":{"102":1,"103":3}}],["try",{"2":{"60":1,"65":1}}],["true和false",{"2":{"82":1}}],["true",{"2":{"31":2,"69":2,"70":1,"82":1,"103":1}}],["t>>>>",{"2":{"65":2}}],["t>>>",{"2":{"43":1,"44":1,"45":1}}],["t>>",{"2":{"42":2,"44":1}}],["t>",{"2":{"42":1,"43":1,"44":1,"65":2}}],["tagart元素对应索引",{"2":{"45":1}}],["takes",{"2":{"104":2}}],["take",{"2":{"42":1,"43":2,"60":4,"65":3}}],["table",{"0":{"36":1}}],["target",{"2":{"7":2,"45":4}}],["test",{"2":{"34":5,"37":6}}],["tupl",{"2":{"85":5}}],["tupl2",{"2":{"85":1}}],["tupl1",{"2":{"85":2}}],["tuple",{"2":{"84":1,"94":2}}],["tup",{"2":{"31":4}}],["top",{"2":{"63":1}}],["to",{"2":{"31":1,"34":5,"36":3,"37":4,"93":1,"94":1,"100":1}}],["t",{"2":{"14":1,"45":2,"65":1,"82":1}}],["tip",{"2":{"14":1,"15":1,"30":1}}],["的时候",{"2":{"103":1}}],["的类型使用",{"2":{"103":1}}],["的错误",{"2":{"102":1}}],["的值已被移走",{"2":{"104":1}}],["的值移动到函数里",{"2":{"104":1}}],["的值",{"2":{"102":1}}],["的值变成了",{"2":{"95":1}}],["的变量",{"2":{"97":1}}],["的变化来决定的",{"2":{"16":1}}],["的根源在实际开发中可能很难追踪",{"2":{"93":1}}],["的形式",{"2":{"87":1}}],["的编译期",{"2":{"79":1}}],["的主要应用场景是用作某些集合的索引",{"2":{"79":1}}],["的整型默认是",{"2":{"79":1}}],["的限制",{"2":{"64":1}}],["的数据结构",{"2":{"62":1}}],["的数组",{"2":{"26":1}}],["的数组访问函数",{"2":{"3":1}}],["的数组被设计为在编译期确定长度",{"2":{"2":1}}],["的",{"2":{"62":1,"83":1,"104":1}}],["的索引",{"2":{"37":1}}],["的元素链式存储",{"2":{"34":1}}],["的哈希值为15387811073369036852",{"2":{"31":1}}],["的哈希值为",{"2":{"31":5}}],["的成员变量是可变的",{"2":{"31":1}}],["的位置是由哈希函数决定的",{"2":{"28":1}}],["的查找算法",{"2":{"7":1}}],["name",{"2":{"87":1}}],["names",{"2":{"86":6}}],["n代表该数据类型的位数",{"2":{"79":1}}],["n1",{"2":{"41":3,"42":2,"43":2}}],["n0",{"2":{"41":3}}],["need",{"2":{"100":1}}],["next",{"2":{"31":1,"39":1,"41":5,"42":3,"43":6,"44":1,"45":1,"60":4,"65":3}}],["new",{"2":{"8":3,"31":7,"34":4,"36":2,"37":4,"41":6,"52":1,"58":5,"60":12,"61":1,"63":1,"65":4}}],["not",{"2":{"100":1,"102":1}}],["no",{"2":{"36":2,"69":1,"81":1}}],["node",{"2":{"31":2,"42":5,"43":10,"44":4,"45":4,"65":3}}],["none=>",{"2":{"60":2}}],["none",{"2":{"7":1,"31":1,"34":2,"37":4,"41":3,"60":3,"65":3,"79":1}}],["n−2",{"2":{"23":1}}],["n−1",{"2":{"23":1}}],["n互不重复的元素",{"2":{"23":1}}],["n2",{"2":{"15":1,"41":2}}],["n^3",{"2":{"15":2}}],["n^2",{"2":{"15":2,"21":1}}],["n",{"0":{"18":1,"19":1},"2":{"7":1,"11":1,"14":10,"15":5,"17":2,"18":4,"19":2,"20":7,"21":4,"22":4,"23":6,"28":1,"36":1,"44":1,"45":1,"46":3,"55":1}}],["number",{"2":{"70":5}}],["nums",{"2":{"4":5,"5":4,"53":1,"61":4}}],["num",{"2":{"4":4,"31":6,"53":1,"60":4,"61":2,"65":2,"69":2,"88":3,"89":3,"91":4,"92":2,"94":2}}],["知道找到对应值",{"2":{"7":1}}],["64位",{"2":{"79":1}}],["6",{"0":{"7":1,"22":1,"57":1},"2":{"30":7,"52":1,"55":1,"57":1,"69":3,"74":1,"85":3,"91":1,"95":2}}],["label",{"2":{"75":1}}],["labelname",{"2":{"75":1}}],["last",{"2":{"58":2,"63":1}}],["lru",{"2":{"49":2}}],["lucy",{"2":{"37":2}}],["ls",{"2":{"34":14}}],["limited",{"2":{"94":1}}],["lisstnode>>>",{"2":{"60":1}}],["lisstnode",{"2":{"41":3}}],["list",{"0":{"50":1},"2":{"41":1,"46":1,"58":3}}],["listnode>>>",{"2":{"39":1,"60":4,"65":1}}],["listnode",{"2":{"31":2,"39":1,"42":2,"43":1,"44":1,"45":1,"60":3,"65":4}}],["lily",{"2":{"34":5,"37":2}}],["link",{"2":{"41":1,"46":1}}],["linklisthash",{"2":{"34":6}}],["linear",{"2":{"19":1,"20":3}}],["load",{"2":{"34":3}}],["logarithmic",{"2":{"18":1}}],["log",{"0":{"18":1},"2":{"20":4}}],["loop`",{"2":{"75":1}}],["loop的下一个迭代",{"2":{"75":1}}],["loop的下一次迭代",{"2":{"75":1}}],["loop继续执行后续代码",{"2":{"75":1}}],["loop执行一次使",{"2":{"75":1}}],["loop循环",{"0":{"72":1}}],["loop",{"2":{"6":1,"71":1,"72":1,"75":5}}],["lt",{"2":{"15":1,"61":1}}],["length返回的是元组",{"2":{"104":1}}],["length函数并未返回其所有权并赋值给s1",{"2":{"104":1}}],["length函数后",{"2":{"104":1}}],["length",{"2":{"104":5}}],["len",{"2":{"3":1,"4":1,"5":1,"6":1,"7":1,"8":2,"54":1,"58":1,"63":2,"95":2,"104":4}}],["let",{"0":{"70":1},"2":{"2":4,"3":2,"8":1,"14":1,"18":1,"19":1,"20":1,"21":1,"22":2,"23":1,"30":4,"31":18,"34":10,"36":4,"37":6,"41":2,"42":1,"43":3,"44":1,"45":1,"52":2,"53":1,"58":1,"60":1,"61":2,"65":1,"70":4,"74":2,"75":3,"80":2,"81":4,"82":2,"83":3,"85":4,"86":3,"89":1,"91":5,"92":3,"95":9,"101":1,"102":7,"103":4,"104":5}}],["末端位置的元素将为none",{"2":{"5":1}}],["处理后发生的冲突的key",{"2":{"34":1}}],["处的元素更新为",{"2":{"53":1}}],["处的元素",{"2":{"4":1,"53":1}}],["处插入元素",{"2":{"4":1}}],["赋给",{"2":{"4":1}}],["将值传递给函数在语义上与给变量赋值相似",{"2":{"104":1}}],["将会收到如下报错信息",{"2":{"102":1}}],["将会收到来自编译器的警告",{"2":{"100":1}}],["将获得第二个值",{"2":{"95":1}}],["将收到编译器的报错",{"2":{"93":1}}],["将多个值组合在一起可以组成复合类型",{"2":{"84":1}}],["将被转换后为0",{"2":{"79":1}}],["将链表的头节点看作队首",{"2":{"60":1}}],["将链表的尾节点看作队尾",{"2":{"60":1}}],["将索引",{"2":{"53":1}}],["将切换到下一个进程",{"2":{"49":1}}],["将头节点的指针修改指向至删除节点后面的节点",{"2":{"43":1}}],["将头节点指针指向插入节点",{"2":{"42":1}}],["将插入节点的指针指向原本第二节点",{"2":{"42":1}}],["将元素添加到数组",{"2":{"36":1}}],["将每个字符的",{"2":{"30":1}}],["将输入数据的每个元素通过异或操作累积到一个哈希值中",{"2":{"30":1}}],["将各个字符的",{"2":{"30":1}}],["将得到的总和作为哈希值",{"2":{"30":1}}],["将",{"2":{"4":1}}],["+=",{"2":{"18":1,"19":1,"20":1,"21":1,"22":1,"23":1,"34":1,"54":2,"58":2,"60":1,"61":1,"65":1,"75":2}}],["+1",{"2":{"15":1}}],["+n",{"2":{"14":2}}],["+0",{"2":{"14":2}}],["+",{"2":{"4":1,"5":1,"8":1,"14":3,"15":5,"20":1,"22":5,"30":2,"61":4,"72":1,"85":1,"86":1,"89":2,"91":1,"92":2,"94":1,"95":1}}],["free",{"2":{"102":1}}],["from已经完成向内存分配器申请内存",{"2":{"101":1}}],["from",{"2":{"100":1,"101":1,"102":3,"103":1,"104":2}}],["from函数赋予字符串字面量string的命名空间",{"2":{"100":1}}],["front",{"2":{"61":7}}],["f",{"2":{"82":1}}],["float",{"2":{"81":1}}],["f64",{"2":{"80":1,"85":2,"103":1}}],["focus",{"2":{"93":1}}],["fourth",{"2":{"86":1}}],["found",{"2":{"70":1,"95":1}}],["for循环直接遍历集合的元素",{"2":{"74":1}}],["for等",{"2":{"71":1}}],["for",{"0":{"74":1},"2":{"4":1,"5":1,"6":2,"7":1,"8":1,"14":3,"17":1,"19":1,"20":1,"21":2,"22":2,"23":1,"30":4,"34":5,"58":2,"74":1,"81":1}}],["false",{"2":{"69":1,"82":1,"103":1}}],["factorial",{"2":{"23":2}}],["first",{"2":{"86":1}}],["fisrt",{"2":{"69":2}}],["filter",{"2":{"37":3}}],["finish",{"2":{"31":6}}],["find",{"2":{"7":1,"45":2}}],["functions",{"2":{"94":1}}],["function",{"2":{"87":5}}],["func",{"2":{"34":5,"37":6}}],["f32",{"2":{"31":1,"34":2,"80":2}}],["fn关键字用来声明函数",{"2":{"87":1}}],["fn",{"2":{"3":1,"4":1,"5":1,"6":1,"7":1,"8":1,"14":1,"17":2,"18":1,"19":1,"20":1,"21":1,"22":1,"23":1,"30":4,"34":10,"36":1,"37":11,"41":1,"58":9,"60":7,"61":7,"65":6,"69":1,"80":1,"81":1,"87":1,"88":1,"89":1,"91":3,"92":1,"95":1,"104":3}}],["以确定在循环的每次迭代中索引是否在数组的边界内",{"2":{"74":1}}],["以便实现无缝播放",{"2":{"49":1}}],["以上述结构体为例",{"2":{"41":1}}],["以上四个简单哈希算法的设计都存在一个共同点",{"2":{"30":1}}],["以初始容量4",{"2":{"34":1}}],["以链表原理将发生冲突的hash",{"2":{"34":1}}],["以链式存储实现的哈希为例",{"2":{"28":1}}],["以key取模运算来映射index为例",{"2":{"32":1}}],["以合数9为模数",{"2":{"30":1}}],["以下是一个所有权通过函数参数移动的示例",{"2":{"104":1}}],["以下面例子来展示其优势",{"2":{"30":1}}],["以下将",{"2":{"2":1}}],["以及支持快速添加和删除节点",{"2":{"49":1}}],["以及不同数据结构之间的关系有了一定的了解",{"2":{"27":1}}],["以及之后的所有元素向后移动一位",{"2":{"4":1}}],["以此类推",{"2":{"22":1}}],["当持有堆中数据值的变量离开作用域时",{"2":{"104":1}}],["当且仅当其包含的类型也都实现",{"2":{"103":1}}],["当s和z都离开作用域时",{"2":{"102":1}}],["当变量离开作用域时它被自动调用",{"2":{"102":1}}],["当尝试将字符串字面量设置为可变",{"2":{"100":1}}],["当尝试改变一个前面指定为不可变的值时我们会得到编译期错误",{"2":{"93":1}}],["当向堆放入数据时",{"2":{"96":1}}],["当该作用域结束时",{"2":{"95":1}}],["当函数没有返回值时",{"2":{"91":1}}],["当plus函数有返回值时可行",{"2":{"91":1}}],["当超出索引来访问时",{"2":{"86":1}}],["当数组中的所有元素都相等时",{"2":{"86":1}}],["当使用",{"2":{"79":1}}],["当条件不再为真",{"2":{"73":1}}],["当某一个分支的条件满足后",{"2":{"69":1}}],["当栈顶元素没有下一个元素时",{"2":{"65":1}}],["当把球放进筒时",{"2":{"63":1}}],["当front到数组尾端时",{"2":{"61":1}}],["当进行增删等操作时",{"2":{"58":1}}],["当然也可实现自己构造函数",{"2":{"52":1}}],["当然这些都还是很浅显的认知",{"2":{"27":1}}],["当时间片用完时",{"2":{"49":1}}],["当用户点击前进或后退按钮时",{"2":{"49":1}}],["当插入操作在链表的一端进行",{"2":{"49":1}}],["当插入和删除操作都在链表的一端进行时",{"2":{"49":1}}],["当前节点值等于target时",{"2":{"45":1}}],["当列表的内容发生变化时",{"2":{"31":1}}],["当算法的运行时间跟输入数据n成正比时",{"2":{"19":1}}],["当算法的运行时间跟输入数据n的log成正比时",{"2":{"18":1}}],["当算法的运行时间跟输入数据n无关时",{"2":{"17":1}}],["当需要快速查找一个元素或其对应关系时",{"2":{"12":1}}],["当访问数组元素时",{"2":{"10":1}}],["当元素超出数组长度的时候",{"2":{"4":1}}],["当索引超出数组长度时会产生无效的访问",{"2":{"3":1}}],["rs",{"2":{"102":1}}],["rc",{"2":{"39":3,"41":3,"42":2,"43":1,"44":2,"45":1,"60":9,"65":6}}],["rc即引用计数",{"2":{"39":1}}],["ratio",{"2":{"34":3}}],["rate",{"2":{"34":3,"58":3}}],["range",{"2":{"3":1}}],["rand",{"2":{"3":5}}],["rot",{"2":{"30":1}}],["release时",{"2":{"79":1}}],["rear",{"2":{"61":1}}],["resize",{"2":{"58":2}}],["reference",{"2":{"39":1}}],["ref",{"2":{"37":5,"60":1,"65":1}}],["refcell",{"2":{"31":1,"39":2,"41":3,"42":2,"43":1,"44":2,"45":1,"60":7,"65":4}}],["repeat",{"2":{"34":1}}],["removed",{"2":{"34":4,"36":1}}],["remove",{"2":{"34":3,"36":1,"37":3,"55":2}}],["return",{"2":{"20":2,"23":1,"34":3,"43":1,"44":3,"45":3,"58":1,"61":1,"89":2}}],["recur",{"2":{"20":3,"23":2}}],["rev",{"2":{"4":1}}],["rng",{"2":{"3":1}}],["rust有一个",{"2":{"103":1}}],["rust的策略是在变量离开作用域时",{"2":{"101":1}}],["rust的所有的数字类型都支持基本的数学运算",{"2":{"81":1}}],["rustlet",{"2":{"100":1,"102":3}}],["rust函数采用",{"2":{"87":1}}],["rust标准库存在一种动态数组",{"2":{"86":1}}],["rust标量类型包括",{"2":{"78":1}}],["rust默认的浮点类型是f64",{"2":{"80":1}}],["rust是一门静态类型语言",{"2":{"77":1}}],["rust提供了多种循环",{"2":{"71":1}}],["rustfn",{"2":{"69":1,"70":1,"72":1,"73":1,"74":2,"75":2,"83":1,"87":1,"88":1,"89":1,"91":1,"92":1,"101":1,"102":1,"103":2,"104":2}}],["rust中常见实现copy",{"2":{"103":1}}],["rust中常见的控制流有",{"2":{"67":1}}],["rust中的函数诸如fn",{"2":{"87":1}}],["rust中的整型",{"2":{"79":1}}],["rust中哈希表的基本操作",{"2":{"36":1}}],["rust\\tstruct",{"2":{"58":1}}],["rust\\tvec2",{"2":{"55":1,"56":1}}],["rust\\tlet",{"2":{"54":1,"57":1,"63":1}}],["rust\\tfn",{"2":{"52":1,"93":2,"95":1}}],["rust\\t",{"2":{"42":1,"43":1,"44":1,"45":1,"94":1}}],["rust\\tuse",{"2":{"39":1}}],["rustuse",{"2":{"31":1,"36":1,"60":1}}],["rust",{"2":{"2":4,"3":1,"4":1,"5":1,"6":1,"7":1,"8":1,"14":1,"17":1,"18":1,"19":1,"20":1,"21":1,"22":1,"30":1,"34":1,"37":1,"41":1,"53":1,"61":1,"65":1,"69":1,"79":1,"80":1,"81":1,"82":1,"83":1,"85":2,"86":2,"93":2,"95":1,"103":1}}],[">i32",{"2":{"94":1}}],[">bool",{"2":{"60":1}}],[">self",{"2":{"60":1}}],[">option",{"2":{"34":1,"60":1}}],[">=",{"2":{"34":1,"58":5}}],[">usize",{"2":{"34":1,"60":1}}],[">>",{"2":{"30":1}}],[">",{"2":{"3":1,"7":1,"17":2,"18":2,"19":1,"20":1,"21":1,"22":1,"23":1,"30":4,"34":3,"37":6,"44":1,"45":1,"58":4,"60":1,"61":6,"65":5,"69":3,"89":1,"102":1,"104":1}}],["e0382",{"2":{"102":1}}],["eyed",{"2":{"83":1}}],["else的每个分支的可能的返回值都必须是相同类型",{"2":{"70":1}}],["else",{"2":{"69":4,"70":2}}],["element",{"2":{"3":3,"5":1,"7":1,"58":3,"86":4}}],["empty",{"2":{"60":1,"61":2,"63":2,"65":1}}],["eq",{"2":{"34":6,"37":5}}],["end",{"2":{"60":13,"61":2}}],["entry",{"2":{"37":1}}],["enumerate",{"2":{"34":1}}],["enlarge",{"2":{"8":3}}],["expression",{"2":{"90":1}}],["expected",{"2":{"70":1,"95":1}}],["exponential",{"2":{"22":1}}],["extend",{"2":{"2":1,"34":9,"57":1,"58":3}}],["按照元素排列递增",{"2":{"3":1}}],["看作数组",{"2":{"2":1}}],["一个值在任一时刻都只能有且仅有一个所有者",{"2":{"97":1}}],["一个常量声明的例子",{"2":{"94":1}}],["一个具有返回值的函数声明的示例",{"2":{"89":1}}],["一个具有参数的函数声明的示例",{"2":{"88":1}}],["一个函数声明的示例",{"2":{"87":1}}],["一个标准且完善的哈希算法的设计通常要考虑的因素是相当复杂的",{"2":{"30":1}}],["一下以头插法实现栈的基本代码如下",{"2":{"65":1}}],["一下代码实现在头节点后插入节点",{"2":{"42":1}}],["一直访问下一个节点",{"2":{"44":1}}],["一些数组的特性",{"2":{"61":1}}],["一些标准哈希算法",{"2":{"29":1}}],["一些操作数对应的时间复杂度",{"2":{"15":1}}],["一般情况下用作动态数组的类型",{"2":{"2":1}}],["一旦创建",{"2":{"0":1,"85":1,"86":1}}],["是否继续有效",{"2":{"103":1}}],["是否发生移动",{"2":{"103":1}}],["是因为栈中的所有数据都必须占用已知且固定的大小",{"2":{"96":1}}],["是执行一些操作但不返回值的指令",{"2":{"90":1}}],["是一个表达式",{"2":{"70":1}}],["是目前已知最有效的方法",{"2":{"28":1}}],["是指数阶增长的典型例子",{"2":{"22":1}}],["是",{"2":{"2":1,"104":1}}],["为什么栈上的数据无需克隆仍旧有效",{"2":{"103":1}}],["为什么字符串字面量不可变",{"2":{"100":1}}],["为什么是一个大质数",{"2":{"30":1}}],["为了维持一段可变",{"2":{"101":1}}],["为了更深刻地理解栈是如何通过这两种数据结构实现的",{"2":{"64":1}}],["为了方便实现扩容",{"2":{"2":1}}],["为切片",{"2":{"2":1}}],["为数组",{"2":{"2":1}}],["不会有特殊操作",{"2":{"104":1}}],["不允许自身或其任何部分实现了",{"2":{"103":1}}],["不再有效",{"2":{"101":1}}],["不能为了每一个在编译时大小未知的文本而将一块内存放入二进制文件中",{"2":{"101":1}}],["不能对不可变变量二次赋值",{"2":{"93":1}}],["不确定大小的数据量",{"2":{"100":1}}],["不同于rust中其他已知固定大小的数据类型",{"2":{"100":1}}],["不同于变量使用let声明",{"2":{"94":1}}],["不同于数组访问可以在o",{"2":{"44":1}}],["不可变变量意味着一旦声明后值就不能改变",{"2":{"93":1}}],["不过你也可以选择让变量是可变的mutable",{"2":{"93":1}}],["不过循环在其尝试从数组获取第",{"2":{"74":1}}],["不应该依赖补码处理整型溢出",{"2":{"79":1}}],["不断将新元素放入栈顶",{"2":{"63":1}}],["不存在该key",{"2":{"34":1}}],["不难发现在key构成的输入空间趋近于无限的前提下",{"2":{"32":1}}],["不指定长度时",{"2":{"2":1}}],["不初始化值",{"2":{"2":1}}],["中最高阶的项来决定",{"2":{"15":1}}],["中的常数项",{"2":{"14":1}}],["中",{"2":{"2":1}}],["在移动后被借用",{"2":{"104":1}}],["在调用calculate",{"2":{"104":1}}],["在调试模式",{"2":{"79":1}}],["在讨论这个报错信息之前",{"2":{"102":1}}],["在上述的示例中",{"2":{"102":1}}],["在数据不在使用时",{"2":{"101":1}}],["在数据不再使用时",{"2":{"101":1}}],["在数组有效索引范围内查找元素",{"2":{"7":1}}],["在数组的索引",{"2":{"4":1}}],["在数组中插入元素",{"2":{"4":1}}],["在栈上存储一个指向堆上内容的指针",{"2":{"100":1}}],["在堆的某处找到一块足够大的空位",{"2":{"96":1}}],["在编译时大小未知或大小可能变化的数据",{"2":{"96":1}}],["在内部作用域内",{"2":{"95":1}}],["在函数中",{"2":{"89":1}}],["在很多语言中函数都是非常常见的存在",{"2":{"87":1}}],["在很多编程语言中并没有预先设定的栈数据结构",{"2":{"63":1}}],["在现代计算机中",{"2":{"80":1}}],["在某一时刻会到达值",{"2":{"74":1}}],["在某些数据缓冲区的实现中",{"2":{"49":1}}],["在生活中有许多类似栈数据结构的例子",{"2":{"63":1}}],["在rust中mian函数是很多程序的入口",{"2":{"87":1}}],["在rust中",{"2":{"84":1,"93":1}}],["在rust中浮点类型分为单精度和双精度两种",{"2":{"80":1}}],["在rust中数组存在size和capacity两个概念",{"2":{"61":1}}],["在rust中使用智能指针rc来定义链表引用",{"2":{"39":1}}],["在中间插入元素",{"2":{"58":1}}],["在尾部插入元素",{"2":{"58":1}}],["在动手编写代码前",{"2":{"58":1}}],["在索引index处插入value",{"2":{"55":1}}],["在列表的末尾可以在o",{"2":{"55":1}}],["在许多高级编程语言的标准库中都初始了动态数组的构造方法",{"2":{"52":1}}],["在许多编程语言中",{"2":{"31":1}}],["在操作系统中",{"2":{"49":1}}],["在缓存淘汰",{"2":{"49":1}}],["在网页浏览器中",{"2":{"49":1}}],["在该方案中",{"2":{"49":1}}],["在环形链表中任一节点都可以作为头节点",{"2":{"48":1}}],["在这里我们删除头节点后的节点",{"2":{"43":1}}],["在",{"0":{"70":1},"2":{"2":1,"89":1}}],["008",{"2":{"37":2}}],["007",{"2":{"37":1}}],["0",{"2":{"2":7,"3":1,"6":1,"7":1,"8":2,"14":5,"17":2,"18":1,"19":2,"20":1,"21":3,"22":3,"23":3,"30":11,"34":3,"41":1,"44":1,"53":2,"54":3,"58":3,"60":2,"61":5,"63":1,"65":1,"69":1,"73":1,"74":1,"75":4,"79":2,"80":2,"81":1,"85":2,"86":1,"93":3}}],["42",{"2":{"31":2}}],["4952851536318644461",{"2":{"31":1}}],["4",{"0":{"5":1,"20":1,"44":1,"47":1,"48":1,"49":1,"55":1,"75":1,"82":1},"1":{"48":1,"49":1},"2":{"2":2,"22":2,"30":1,"34":3,"36":1,"57":1,"59":1,"70":1,"74":3,"85":2,"102":2}}],["3表示每个元素的值",{"2":{"86":1}}],["3表示数组的长度",{"2":{"86":1}}],["32位",{"2":{"79":1}}],["36",{"2":{"32":2}}],["30",{"2":{"30":2,"94":2}}],["31",{"2":{"30":1}}],["3n+2",{"2":{"15":1}}],["3n+1次等",{"2":{"14":1}}],["3",{"0":{"4":1,"16":1,"17":1,"18":1,"19":2,"20":1,"21":1,"22":1,"23":1,"43":1,"46":1,"54":1,"74":1,"81":1},"1":{"17":1,"18":1,"19":1,"20":1,"21":1,"22":1,"23":1},"2":{"2":2,"14":1,"29":1,"30":9,"31":4,"34":2,"36":3,"52":1,"55":2,"63":1,"73":1,"74":3,"75":1,"80":1,"86":9,"102":1}}],["20",{"2":{"81":1}}],["20336",{"2":{"32":1}}],["256",{"2":{"79":1}}],["2566941990314602357",{"2":{"31":1}}],["255",{"2":{"79":1}}],["27",{"2":{"30":2}}],["24",{"2":{"30":2,"102":1}}],["21",{"2":{"30":2}}],["28",{"2":{"30":1}}],["2^",{"2":{"22":2}}],["2^n^",{"2":{"79":2}}],["2^n个细胞",{"2":{"22":1}}],["2^n",{"2":{"15":2,"22":1,"79":1}}],["2n^2",{"2":{"15":1}}],["2n",{"2":{"15":2}}],["2",{"0":{"3":1,"15":1,"18":1,"26":1,"35":1,"40":1,"41":1,"42":2,"43":1,"44":1,"45":1,"49":1,"53":1,"58":1,"61":1,"64":1,"65":1,"66":2,"70":1,"73":1,"80":1,"86":1,"92":1,"100":1,"103":1},"1":{"41":1,"42":1,"43":1,"44":1,"45":1,"65":1,"66":1},"2":{"2":2,"13":1,"14":3,"18":1,"20":2,"22":3,"26":1,"29":1,"30":1,"34":2,"36":3,"37":1,"41":1,"52":1,"58":1,"63":1,"74":3,"75":3,"80":1,"81":4,"85":1,"86":2,"95":2,"102":1}}],["=>",{"2":{"60":2,"65":2}}],["=n∗",{"2":{"23":1}}],["=n2+n",{"2":{"14":1}}],["==",{"2":{"7":1,"15":1,"23":1,"34":3,"45":1,"58":1,"60":1,"61":2,"65":1,"75":3}}],["=",{"2":{"2":3,"3":2,"4":2,"5":1,"8":2,"14":2,"18":2,"19":1,"20":2,"21":1,"22":5,"23":1,"30":15,"31":18,"32":2,"34":14,"36":4,"37":9,"41":5,"42":3,"43":4,"44":2,"45":1,"52":2,"53":2,"54":2,"57":1,"58":11,"60":7,"61":7,"63":4,"65":6,"70":3,"73":3,"74":2,"75":5,"80":2,"81":4,"82":2,"83":3,"85":11,"86":3,"89":1,"91":5,"92":3,"93":4,"94":3,"95":8,"100":1,"101":1,"102":14,"103":10,"104":6}}],["5表示数组的长度",{"2":{"86":1}}],["500",{"2":{"85":2}}],["5向下取整",{"2":{"81":1}}],["568126464209439262",{"2":{"31":1}}],["5",{"0":{"6":1,"21":1,"45":1,"56":1,"83":1},"2":{"2":8,"14":1,"30":1,"52":1,"69":1,"70":2,"74":6,"75":1,"81":1,"86":1,"88":2,"89":1,"91":3,"92":1,"94":2,"95":2,"102":3,"103":3,"104":1}}],["immutable",{"2":{"93":1}}],["implement",{"2":{"102":1}}],["implementation",{"2":{"81":1}}],["impl",{"2":{"34":1,"37":1,"60":2,"61":1,"65":1}}],["i128",{"2":{"79":1}}],["i16",{"2":{"79":1}}],["i8",{"2":{"79":1}}],["i+1",{"2":{"58":1}}],["item",{"2":{"54":2}}],["iter",{"2":{"34":4,"37":3}}],["it",{"2":{"34":1}}],["isize",{"2":{"79":2}}],["is",{"2":{"34":2,"43":1,"60":1,"61":2,"63":2,"65":1,"69":4,"70":2,"73":1,"75":16,"86":4,"88":1,"89":1,"95":2,"104":1}}],["i64",{"2":{"30":12,"79":1}}],["if的每个分支都必须返回相同的类型",{"2":{"70":1}}],["if可用于多重条件判",{"2":{"69":1}}],["if表达式",{"2":{"67":1}}],["if",{"0":{"68":1,"69":1,"70":1},"1":{"69":1,"70":1},"2":{"7":1,"20":1,"23":1,"34":4,"43":2,"44":2,"45":2,"58":5,"61":2,"69":9,"70":4,"75":5}}],["i",{"2":{"4":3,"5":3,"6":4,"7":3,"8":3,"14":2,"17":2,"19":1,"21":1,"34":2,"54":2,"58":5,"74":3}}],["integer",{"2":{"70":1,"81":1,"104":4}}],["into",{"2":{"60":1,"65":1}}],["inner",{"2":{"60":1,"65":1,"75":3,"95":1}}],["inite",{"2":{"41":1}}],["in",{"2":{"4":1,"5":1,"6":2,"7":1,"8":1,"14":3,"17":1,"19":1,"20":1,"21":2,"22":2,"23":1,"30":4,"34":5,"54":2,"58":2,"74":1,"94":1,"95":1}}],["insert",{"2":{"4":1,"36":3,"42":1,"55":1}}],["index+1",{"2":{"45":1,"58":1}}],["index的映射",{"2":{"37":1}}],["index",{"2":{"0":1,"3":2,"4":6,"5":2,"34":10,"37":10,"44":4,"45":4,"55":2,"58":15,"74":5}}],["i32>",{"2":{"37":1,"52":2,"58":1,"61":1}}],["i32",{"2":{"2":6,"3":2,"4":2,"5":1,"6":1,"7":2,"8":1,"14":1,"17":4,"18":2,"19":2,"20":3,"21":2,"22":2,"23":2,"30":8,"34":6,"36":1,"37":5,"39":1,"44":1,"45":2,"53":1,"58":5,"60":3,"61":9,"65":1,"69":1,"79":2,"85":4,"88":1,"89":2,"91":3,"92":1,"94":3,"103":3,"104":2}}],["after",{"2":{"102":1,"104":1}}],["and",{"2":{"94":1}}],["another",{"2":{"87":4}}],["a=",{"2":{"81":2}}],["are",{"2":{"94":1}}],["arch",{"2":{"79":1}}],["arm",{"2":{"69":4}}],["arrayqueue",{"2":{"61":4}}],["array这个概念来实现列表",{"2":{"50":1}}],["arrayhash",{"2":{"37":5}}],["array",{"2":{"2":1,"46":1,"84":1}}],["arr",{"2":{"2":1,"3":3,"6":4,"7":3,"8":7,"31":2}}],["acess",{"2":{"44":1}}],["access",{"2":{"44":1}}],["add",{"2":{"30":1,"34":5,"58":2,"79":1}}],["assign",{"2":{"93":1}}],["assert",{"2":{"34":6,"37":5}}],["as",{"2":{"20":1,"30":8,"34":3,"37":6,"60":1,"61":3,"65":1}}],["ascii",{"2":{"12":2,"30":3}}],["allocator",{"2":{"96":1}}],["alice",{"2":{"86":2}}],["alter",{"2":{"69":4}}],["alog",{"2":{"17":2}}],["algorithm",{"2":{"14":1}}],["a",{"2":{"2":1,"14":3,"81":4,"86":1,"91":1,"92":2}}],["1^",{"2":{"79":1}}],["16位",{"2":{"79":1}}],["16092673739211250988",{"2":{"31":1}}],["1次",{"2":{"44":1}}],["14159",{"2":{"31":2}}],["11",{"2":{"30":1,"55":1}}],["13",{"2":{"30":2}}],["1885128010422702749",{"2":{"31":1}}],["18",{"2":{"30":2}}],["15",{"2":{"30":2,"89":1}}],["127",{"2":{"79":1}}],["128",{"2":{"79":1}}],["128位",{"2":{"79":1}}],["12836",{"2":{"31":2,"32":1}}],["12",{"2":{"30":3,"34":10,"95":2}}],["102",{"2":{"37":3}}],["100",{"2":{"32":2,"37":3}}],["1000",{"2":{"17":1}}],["10000n^2",{"2":{"15":1}}],["1000000007",{"2":{"30":4}}],["1000000",{"2":{"15":1}}],["10",{"2":{"15":1,"69":1,"75":5,"81":1,"89":2,"92":1,"93":3}}],["1",{"0":{"1":1,"2":2,"3":1,"4":1,"5":1,"6":1,"7":1,"8":1,"14":1,"17":2,"25":1,"34":1,"39":1,"41":1,"48":1,"51":1,"52":2,"53":1,"54":1,"55":1,"56":1,"57":1,"60":1,"63":1,"65":1,"69":1,"72":1,"79":1,"85":1,"91":1,"99":1,"102":1},"1":{"2":1,"3":1,"4":1,"5":1,"6":1,"7":1,"8":1,"52":1,"53":1,"54":1,"55":1,"56":1,"57":1},"2":{"2":2,"3":1,"4":2,"5":2,"10":1,"13":1,"14":6,"15":1,"18":2,"19":1,"20":3,"21":1,"22":7,"23":3,"25":1,"29":1,"34":3,"36":4,"41":1,"44":2,"45":1,"46":3,"52":1,"53":5,"55":1,"58":6,"60":2,"61":4,"63":1,"65":2,"73":1,"74":3,"75":5,"79":3,"85":4,"86":2,"91":1,"92":2,"94":1,"95":2}}]],"serializationVersion":2}';export{t as default};
