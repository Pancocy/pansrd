const t='{"documentCount":46,"nextId":46,"documentIds":{"0":"/datastru/ds-array.html#数组","1":"/datastru/ds-array.html#数组的常见操作","2":"/datastru/ds-array.html#_1-初始化数组","3":"/datastru/ds-array.html#_2-访问数组元素","4":"/datastru/ds-array.html#_3-插入元素","5":"/datastru/ds-array.html#_4-删除元素","6":"/datastru/ds-array.html#_5-遍历数组","7":"/datastru/ds-array.html#_6-查找元素","8":"/datastru/ds-array.html#_7-扩容数组","9":"/datastru/ds-array.html#数组的优、缺点和应用","10":"/datastru/ds-array.html#优点","11":"/datastru/ds-array.html#缺点","12":"/datastru/ds-array.html#应用","13":"/datastru/ds-complexity.html#时间复杂度","14":"/datastru/ds-complexity.html#_1-时间增长趋势","15":"/datastru/ds-complexity.html#_2-判断渐进上界","16":"/datastru/ds-complexity.html#_3-常见时间复杂度类型","17":"/datastru/ds-datastructure.html#数据结构初识","18":"/datastru/ds-datastructure.html#常见的数据结构类型","19":"/datastru/ds-datastructure.html#逻辑结构-线性和非线性","20":"/datastru/ds-datastructure.html#物理结构-连续和非连续","21":"/datastru/ds-datastructure.html#小结","22":"/datastru/ds-linkedlist.html#链表","23":"/datastru/ds-linkedlist.html#_1-链表简介","24":"/datastru/ds-linkedlist.html#_2-链表相关操作","25":"/datastru/ds-linkedlist.html#初始化链表","26":"/datastru/ds-linkedlist.html#插入节点","27":"/datastru/ds-linkedlist.html#删除节点","28":"/datastru/ds-linkedlist.html#访问节点","29":"/datastru/ds-linkedlist.html#查找节点","30":"/datastru/ds-linkedlist.html#_3-链表vs数组","31":"/datastru/ds-linkedlist.html#_4-链表的类型及应用","32":"/datastru/ds-linkedlist.html#常见的链表类型有三种-单向链表、环形链表、双向链表。如下图所示","33":"/datastru/ds-linkedlist.html#各类链表的应用","34":"/datastru/ds-list.html#列表-list","35":"/datastru/ds-list.html#列表的常用操作","36":"/datastru/ds-list.html#_1-初始化列表","37":"/datastru/ds-list.html#_2-访问列表元素","38":"/datastru/ds-list.html#_3-遍历列表元素","39":"/datastru/ds-list.html#_4-插入和删除元素","40":"/datastru/ds-list.html#_5-排序列表","41":"/datastru/ds-list.html#_6-组合列表","42":"/datastru/ds-list.html#列表的实现原理","43":"/rust/var-loop-func/variable.html#变量与可变性","44":"/rust/var-loop-func/variable.html#常量","45":"/rust/var-loop-func/variable.html#遮蔽-shadow"},"fieldIds":{"title":0,"titles":1,"text":2},"fieldLength":{"0":[1,1,9],"1":[1,1,1],"2":[2,1,42],"3":[2,1,26],"4":[2,1,30],"5":[2,1,20],"6":[2,1,17],"7":[2,1,28],"8":[2,1,24],"9":[2,1,1],"10":[1,2,17],"11":[1,2,17],"12":[1,2,37],"13":[1,1,9],"14":[2,1,55],"15":[2,1,29],"16":[2,1,103],"17":[1,1,4],"18":[1,1,12],"19":[2,2,22],"20":[2,2,27],"21":[1,1,7],"22":[1,1,1],"23":[2,1,44],"24":[2,1,1],"25":[1,3,34],"26":[1,3,34],"27":[1,3,41],"28":[1,3,47],"29":[1,3,49],"30":[2,1,31],"31":[2,1,1],"32":[6,4,17],"33":[1,4,59],"34":[3,1,15],"35":[1,1,1],"36":[2,1,25],"37":[2,1,19],"38":[2,1,18],"39":[2,1,25],"40":[2,1,4],"41":[2,1,13],"42":[1,1,93],"43":[1,1,53],"44":[1,1,26],"45":[3,1,68]},"averageFieldLength":[1.6956521739130435,1.4565217391304348,27.304347826086957],"storedFields":{"0":{"title":"数组","titles":[]},"1":{"title":"数组的常见操作","titles":[]},"2":{"title":"1. 初始化数组","titles":["数组的常见操作"]},"3":{"title":"2. 访问数组元素","titles":["数组的常见操作"]},"4":{"title":"3.  插入元素","titles":["数组的常见操作"]},"5":{"title":"4. 删除元素","titles":["数组的常见操作"]},"6":{"title":"5.遍历数组","titles":["数组的常见操作"]},"7":{"title":"6. 查找元素","titles":["数组的常见操作"]},"8":{"title":"7. 扩容数组","titles":["数组的常见操作"]},"9":{"title":"数组的优、缺点和应用","titles":[]},"10":{"title":"优点","titles":["数组的优、缺点和应用"]},"11":{"title":"缺点","titles":["数组的优、缺点和应用"]},"12":{"title":"应用","titles":["数组的优、缺点和应用"]},"13":{"title":"时间复杂度","titles":[]},"14":{"title":"1.时间增长趋势","titles":["时间复杂度"]},"15":{"title":"2.判断渐进上界","titles":["时间复杂度"]},"16":{"title":"3.常见时间复杂度类型","titles":["时间复杂度"]},"17":{"title":"数据结构初识","titles":[]},"18":{"title":"常见的数据结构类型","titles":["数据结构初识"]},"19":{"title":"逻辑结构：线性和非线性","titles":["数据结构初识","常见的数据结构类型"]},"20":{"title":"物理结构：连续和非连续","titles":["数据结构初识","常见的数据结构类型"]},"21":{"title":"小结","titles":["数据结构初识"]},"22":{"title":"链表","titles":[]},"23":{"title":"1.链表简介","titles":["链表"]},"24":{"title":"2.链表相关操作","titles":["链表"]},"25":{"title":"初始化链表","titles":["链表","2.链表相关操作"]},"26":{"title":"插入节点","titles":["链表","2.链表相关操作"]},"27":{"title":"删除节点","titles":["链表","2.链表相关操作"]},"28":{"title":"访问节点","titles":["链表","2.链表相关操作"]},"29":{"title":"查找节点","titles":["链表","2.链表相关操作"]},"30":{"title":"3.链表VS数组","titles":["链表"]},"31":{"title":"4.链表的类型及应用","titles":["链表"]},"32":{"title":"常见的链表类型有三种：单向链表、环形链表、双向链表。如下图所示：","titles":["链表","4.链表的类型及应用","查找节点"]},"33":{"title":"各类链表的应用","titles":["链表","4.链表的类型及应用","查找节点"]},"34":{"title":"列表（List）","titles":[]},"35":{"title":"列表的常用操作","titles":[]},"36":{"title":"1.初始化列表","titles":["列表的常用操作"]},"37":{"title":"2.访问列表元素","titles":["列表的常用操作"]},"38":{"title":"3.遍历列表元素","titles":["列表的常用操作"]},"39":{"title":"4.插入和删除元素","titles":["列表的常用操作"]},"40":{"title":"5.排序列表","titles":["列表的常用操作"]},"41":{"title":"6.组合列表","titles":["列表的常用操作"]},"42":{"title":"列表的实现原理","titles":[]},"43":{"title":"变量与可变性","titles":[]},"44":{"title":"常量","titles":["变量与可变性"]},"45":{"title":"遮蔽（Shadow）","titles":["变量与可变性"]}},"dirtCount":0,"index":[["此外对于遮蔽不同类型的值时",{"2":{"45":1}}],["除非使用let重复声明",{"2":{"45":1}}],["除声明值外",{"2":{"23":1}}],["首先它不会使你轻易改变变量的值",{"2":{"45":1}}],["恢复成",{"2":{"45":1}}],["内部遮蔽结束并且",{"2":{"45":1}}],["内访问任何元素",{"2":{"10":1,"37":1}}],["值为",{"2":{"45":1}}],["值得注意的是",{"2":{"44":1}}],["得到的",{"2":{"45":1}}],["得出其操作数函数",{"2":{"13":1}}],["取之前的值并乘上",{"2":{"45":1}}],["取得原本链表头节点后面的节点",{"2":{"26":1}}],["语句同样遮蔽前面的",{"2":{"45":1}}],["第三个",{"2":{"45":1}}],["第二个变量遮蔽了第一个变量",{"2":{"45":1}}],["来遮蔽之前的",{"2":{"45":1}}],["绑定到",{"2":{"45":1}}],["作用域结束",{"2":{"45":1}}],["再次使用这个变量时",{"2":{"45":1}}],["再将当前数组的所有元素依次移动至新数组",{"2":{"42":1}}],["遮蔽相较于mut具有更高的灵活性",{"2":{"45":1}}],["遮蔽失效",{"2":{"45":1}}],["遮蔽是当以相同的名字再次声明变量时",{"2":{"45":1}}],["遮蔽",{"0":{"45":1}}],["html",{"2":{"44":1}}],["head",{"2":{"26":4,"28":5,"29":4}}],["hello",{"2":{"19":1,"20":1}}],["包括全局作用域",{"2":{"44":1}}],["就再也不会改变",{"2":{"44":1}}],["编译器保证了当我们声明了一个值不会改变时",{"2":{"43":1}}],["特别是第二部分代码只是偶尔变更了原来的值",{"2":{"43":1}}],["那它就真的不可改变",{"2":{"43":1}}],["那很可能第一部分代码以不可意料的方式运行",{"2":{"43":1}}],["那么就无法在内存中访问到该节点了",{"2":{"27":1}}],["那么可以用数组存储",{"2":{"12":1}}],["上述操作就可行了",{"2":{"43":1}}],["上一个节点通过将引用指向下一个节点来访问节点内存地址",{"2":{"23":1}}],["接下来尝试用下面的代码来分析",{"2":{"43":1}}],["提供的安全性和简单并发性的方式来编写代码",{"2":{"43":1}}],["默认情况下的变量是不可变的",{"2":{"43":1}}],["初特殊声明外",{"2":{"43":1}}],["初始容量",{"2":{"42":1}}],["初始值应为0",{"2":{"29":1}}],["初始状态为1个细胞",{"2":{"16":1}}],["初始化列表的容量",{"2":{"42":1}}],["初始化列表通常分为",{"2":{"36":1}}],["初始化列表",{"0":{"36":1}}],["初始化各个节点",{"2":{"25":1}}],["初始化链表可分为两步",{"2":{"25":1}}],["初始化链表",{"0":{"25":1}}],["初始化值",{"2":{"2":1}}],["初始化值和不初始化值",{"2":{"2":1}}],["初始化数组有两种方式",{"2":{"2":1}}],["初始化数组时计算机会在内存中分配一块连续的空间",{"2":{"2":1}}],["初始化数组",{"0":{"2":1}}],["变量与可变性",{"0":{"43":1},"1":{"44":1,"45":1}}],["元素数量+1",{"2":{"42":1}}],["容量已满",{"2":{"42":1}}],["del",{"2":{"42":2}}],["delete",{"2":{"5":1,"27":1,"42":1}}],["超出索引",{"2":{"42":3}}],["update",{"2":{"42":1}}],["use",{"2":{"23":1}}],["usize>",{"2":{"7":1}}],["usize",{"2":{"4":1,"5":1,"8":1,"42":10}}],["获取列表长度",{"2":{"42":1}}],["获取列表容量",{"2":{"42":1}}],["获得要删除节点后面的节点",{"2":{"27":1}}],["获得要删除的节点",{"2":{"27":1}}],["获得操作数函数t",{"2":{"14":1}}],["构造函数",{"2":{"42":1}}],["先根据扩容倍数创建一个更大的数组",{"2":{"42":1}}],["若插入元素时列表容量已满",{"2":{"42":1}}],["扩容列表",{"2":{"42":1}}],["扩容",{"2":{"42":1}}],["扩容机制",{"2":{"42":1}}],["扩容数组需要重新分配一块更大的内存空间",{"2":{"8":1}}],["扩容数组",{"0":{"8":1}}],["相较于变量而言",{"2":{"44":1}}],["相应修改该标记",{"2":{"42":1}}],["相关代码如下",{"2":{"16":1}}],["实时标识列表内的元素的数量",{"2":{"42":1}}],["虽然许多的高级语言都已经封装了列表的实现以及一系列的方法",{"2":{"42":1}}],["虽然打印程序需要循环1000次",{"2":{"16":1}}],["拼接在尾部",{"2":{"41":1}}],["注意",{"2":{"41":1}}],["组合列表",{"0":{"41":1}}],["直接使用封装的api操作",{"2":{"40":1}}],["直接访问",{"2":{"6":1}}],["排序列表",{"0":{"40":1}}],["排序和搜索",{"2":{"12":1}}],["清空列表",{"2":{"39":1}}],["使用extend方法将两个列表组合成一个列表",{"2":{"41":1}}],["使用insert",{"2":{"39":1}}],["使用next建立引用关系",{"2":{"25":1}}],["9",{"2":{"39":1}}],["跟数组一样",{"2":{"38":1}}],["更新元素",{"2":{"37":1,"42":1}}],["mylist",{"2":{"42":2}}],["main",{"2":{"36":1,"43":2,"45":2}}],["mut赋值时不允许更改变量的类型",{"2":{"45":1}}],["mut将收到贬义词的报错",{"2":{"45":1}}],["mutable",{"2":{"43":1}}],["mut",{"2":{"4":1,"5":1,"8":2,"14":1,"16":8,"25":2,"26":3,"27":3,"28":1,"29":1,"38":1,"42":2,"43":1,"45":2}}],["有初始值",{"2":{"36":2}}],["后续会有",{"2":{"36":1}}],["动态数组在完美继承数组的所有特点的同时",{"2":{"34":1}}],["动态数组dynamic",{"2":{"34":1}}],["动态参数",{"2":{"28":1,"29":1}}],["长度和扩容问题显然使得实现后得列表具有较大缺陷",{"2":{"34":1}}],["长度不可表",{"2":{"30":1}}],["长度不可变",{"2":{"11":1}}],["倘若使用数组来实现列表",{"2":{"34":1}}],["而遮蔽则不必要求数据类型相同",{"2":{"45":1}}],["而不能是函数调用的结果或是只能在运行时计算得到的值",{"2":{"44":1}}],["而代码的另一部分更改了该值",{"2":{"43":1}}],["而声明可变时",{"2":{"43":1}}],["而数组可以看作一个长度固定的列表",{"2":{"34":1}}],["而链表则是分散的",{"2":{"20":1}}],["灵活程度远高于链表和数组",{"2":{"34":1}}],["列表长度",{"2":{"42":1}}],["列表的实现原理",{"0":{"42":1}}],["列表的常用操作",{"0":{"35":1},"1":{"36":1,"37":1,"38":1,"39":1,"40":1,"41":1}}],["列表是一种抽象的数据结构概念",{"2":{"34":1}}],["列表",{"0":{"34":1}}],["视频播放器中",{"2":{"33":1}}],["它需要对一组进程进行循环",{"2":{"33":1}}],["它表现的特性为先进先出",{"2":{"33":1}}],["它表现的特性为先进后出",{"2":{"33":1}}],["调度算法",{"2":{"33":1}}],["浏览器需要知道用户访问过的前一个和后一个网页",{"2":{"33":1}}],["浏览器历史",{"2":{"33":1}}],["类似于双向链表",{"2":{"33":1}}],["比如在音频",{"2":{"33":1}}],["比如在红黑树",{"2":{"33":1}}],["比如操作系统的资源调度",{"2":{"33":1}}],["比如以上代码中的链表可记作链表",{"2":{"25":1}}],["高级数据结构",{"2":{"33":1}}],["其他位置插入的时间复杂度为o",{"2":{"39":1}}],["其中图的每个顶点都与一个链表相关联",{"2":{"33":1}}],["其长度就固定了",{"2":{"0":1}}],["邻接表是表示图的一种常用方式",{"2":{"33":1}}],["链式地址是解决哈希冲突的主流方案之一",{"2":{"33":1}}],["链表本身就一个列表",{"2":{"34":1}}],["链表中的每个元素都代表与该顶点相连的其他顶点",{"2":{"33":1}}],["链表中插入节点",{"2":{"26":1}}],["链表vs数组",{"0":{"30":1}}],["链表访问元素则相对复杂",{"2":{"28":1}}],["链表的类型及应用",{"0":{"31":1},"1":{"32":1,"33":1}}],["链表的头节点",{"2":{"26":1}}],["链表的每个节点对象由引用",{"2":{"23":1}}],["链表相关操作",{"0":{"24":1},"1":{"25":1,"26":1,"27":1,"28":1,"29":1}}],["链表结构体",{"2":{"23":1}}],["链表结构体说明",{"2":{"23":1}}],["链表节点由值和指针两部分组成",{"2":{"23":1}}],["链表示意图",{"2":{"23":1}}],["链表需要的空间比数组更多",{"2":{"23":1}}],["链表是一种线性数据结构",{"2":{"23":1}}],["链表简介",{"0":{"23":1}}],["链表",{"0":{"22":1},"1":{"23":1,"24":1,"25":1,"26":1,"27":1,"28":1,"29":1,"30":1,"31":1,"32":1,"33":1},"2":{"18":1,"19":1}}],["各类链表的应用",{"0":{"33":1}}],["尾既是头",{"2":{"32":1}}],["尾节点指向空none",{"2":{"32":1}}],["尾节点结束",{"2":{"32":1}}],["头既是尾",{"2":{"32":1}}],["头尾的概念也就消失了",{"2":{"32":1}}],["头节点和尾节点相连接形成闭环的链表",{"2":{"32":1}}],["由头节点开始",{"2":{"32":1}}],["由于列表继承数组特性",{"2":{"37":1}}],["由于其动态扩容性",{"2":{"34":1}}],["由于数组在创建时的长度固定",{"2":{"8":1}}],["由于",{"2":{"2":1}}],["最后一个不同点是常量只能设置为常量表达式",{"2":{"44":1}}],["最普遍的链表类型",{"2":{"32":1}}],["最高阶对时间增长的趋势的影响是其他项所不能相比的",{"2":{"15":1}}],["双向链表的特性使得这种操作变得简单",{"2":{"33":1}}],["双向链表常用于需要快速查找前一个和后一个元素的场景",{"2":{"33":1}}],["双向链表",{"0":{"32":1},"2":{"32":1}}],["环形链表常用于需要周期性操作的场景",{"2":{"33":1}}],["环形链表",{"0":{"32":1},"2":{"32":1}}],["单向链表通常用于实现栈",{"2":{"33":1}}],["单向链表",{"0":{"32":1},"2":{"32":1}}],["占用空间大",{"2":{"30":1}}],["占用空间小",{"2":{"30":1}}],["但是为了更好的理解深层原理",{"2":{"42":1}}],["但分配较大时会造成浪费",{"2":{"30":1}}],["但打印函数的执行时间固定",{"2":{"16":1}}],["连续存储",{"2":{"30":1}}],["连续和非连续",{"0":{"20":1}}],["分散存储",{"2":{"30":1}}],["分裂n轮后有",{"2":{"16":1}}],["分裂两轮后变为4个",{"2":{"16":1}}],["分裂一轮后变为2个",{"2":{"16":1}}],["`usize`",{"2":{"45":1}}],["`",{"2":{"30":2,"45":1}}],["具体原因为",{"2":{"43":1}}],["具体如下图所至",{"2":{"30":1}}],["具有线性关系还是非线性关系",{"2":{"19":1}}],["效率",{"2":{"30":1}}],["效率较低",{"2":{"11":1}}],["panic",{"2":{"42":1}}],["partialeq>",{"2":{"29":1}}],["pub",{"2":{"42":9}}],["push",{"2":{"39":2}}],["prev",{"2":{"27":5}}],["println",{"2":{"6":2,"14":2,"16":2,"42":4,"43":4,"45":2}}],["目标链表元素",{"2":{"29":1}}],["返回被删除的元素",{"2":{"42":1}}],["返回此时的索引",{"2":{"29":1}}],["返回其索引的方法",{"2":{"29":1}}],["返回空\\t\\t\\t\\t\\t\\t\\t\\t\\t",{"2":{"27":1}}],["下面实现查找target节点",{"2":{"29":1}}],["下面实现一个时间复杂度为o",{"2":{"3":1,"7":1}}],["控制访问范围",{"2":{"28":1}}],["索引越界",{"2":{"42":1}}],["索引",{"2":{"28":1,"29":1}}],["索引从0开始",{"2":{"3":1}}],["起始为头节点",{"2":{"28":1,"29":1}}],["起始节点称为头节点",{"2":{"23":1}}],["遍历列表元素",{"0":{"38":1}}],["遍历每个节点",{"2":{"28":1}}],["遍历数组可以使用索引index来获取元素本身",{"2":{"6":1}}],["遍历数组",{"0":{"6":1}}],["访问索引",{"2":{"37":1}}],["访问元素",{"2":{"37":1}}],["访问列表元素",{"0":{"37":1},"2":{"42":1}}],["访问链表中的元素需要从头节点出发",{"2":{"28":1}}],["访问节点",{"0":{"28":1}}],["访问数组元素",{"0":{"3":1}}],["我们直接调用即可",{"2":{"36":1}}],["我们需要快速找到最近最少使用的数据",{"2":{"33":1}}],["我们需要访问节点的父节点",{"2":{"33":1}}],["我们就认为这个节点从链表中删除了",{"2":{"27":1}}],["我们通常将头节点当作链表的代称",{"2":{"25":1}}],["只需要取消删除节点上一个节点对其的引用",{"2":{"27":1}}],["删除位置后的元素向前移一位",{"2":{"42":1}}],["删除指定索引处的元素",{"2":{"39":1}}],["删除操作在链表的另一端进行",{"2":{"33":1}}],["删除链表节点相较于插入操作更简单",{"2":{"27":1}}],["删除节点的前一节点",{"2":{"27":1}}],["删除节点",{"0":{"27":1}}],["删除元素需要将删除位置后面的元素都往前移动一位",{"2":{"5":1}}],["删除元素",{"0":{"5":1},"2":{"39":1,"42":1}}],["即第二节点",{"2":{"26":1}}],["需插入节点",{"2":{"26":1}}],["需要存储指针引用",{"2":{"30":1}}],["需要执行n",{"2":{"28":1}}],["需要将插入位置前一个节点的引用指向该节点",{"2":{"26":1}}],["需要注意的是",{"2":{"20":1}}],["需要先计算出算法的操作数函数t",{"2":{"14":1}}],["需要遍历数组",{"2":{"7":1}}],["需要把插入位置后面的元素全部向后移一位",{"2":{"4":1}}],["参数说明",{"2":{"26":1,"27":1,"28":1,"29":1}}],["建立节点间的引用关系",{"2":{"25":1}}],["variable",{"2":{"43":1}}],["vaue",{"2":{"39":1}}],["val",{"2":{"29":1}}],["value",{"2":{"23":1,"25":3,"42":6,"45":2}}],["vec3",{"2":{"41":2}}],["vec2",{"2":{"36":1,"37":1,"38":3}}],["vec1",{"2":{"36":1}}],["vec",{"2":{"8":1,"36":4,"41":1,"42":16}}],["vector",{"2":{"2":2}}],["\\timpl",{"2":{"42":1}}],["\\tvec2",{"2":{"39":4,"41":1}}],["\\tcount",{"2":{"38":1}}],["\\tfor",{"2":{"38":2}}],["\\tfn",{"2":{"26":1,"27":1,"28":1,"29":1}}],["\\t删除元素",{"2":{"30":1}}],["\\t添加元素",{"2":{"30":1}}],["\\t访问元素",{"2":{"30":1}}],["\\t内存效率",{"2":{"30":1}}],["\\t扩容",{"2":{"30":1}}],["\\t存储方式",{"2":{"30":1}}],["\\t\\t\\t",{"2":{"42":1}}],["\\t\\t\\tlet",{"2":{"42":3}}],["\\t\\tif",{"2":{"42":1}}],["\\t\\t数组",{"2":{"30":1}}],["\\t\\t链表",{"2":{"30":1}}],["\\t\\t",{"2":{"26":1,"27":1,"45":1}}],["\\t\\tlet",{"2":{"25":1,"43":2}}],["\\tstruct",{"2":{"23":1}}],["\\t",{"2":{"23":2,"25":1,"26":3,"27":4,"28":3,"29":4,"30":3,"36":1,"38":2,"39":3,"42":3,"43":2,"45":1}}],["还允许在程序运行时进行动态扩容",{"2":{"34":1}}],["还要声明一个引用计数器",{"2":{"23":1}}],["还会缓存其周围的其他数据",{"2":{"10":1}}],["结束节点称为尾节点",{"2":{"23":1}}],["节点间通过引用连接",{"2":{"23":1}}],["每个进程被赋予一个时间片",{"2":{"33":1}}],["每个节点散落分布在内存空间中",{"2":{"23":1}}],["每一个对象节点都存储两个方向的指针",{"2":{"32":1}}],["每一层循环依然可以分别套用第",{"2":{"14":1}}],["和",{"2":{"29":1,"36":1}}],["和值组成",{"2":{"23":1}}],["和o",{"2":{"16":1}}],["空间上对比二者的存储方式",{"2":{"30":1}}],["空间效率高",{"2":{"10":1}}],["空闲的内存空间并非都是连续的",{"2":{"23":1}}],["然而当需要的空间比较大时",{"2":{"23":1}}],["然后通过重复使用",{"2":{"45":1}}],["然后将该节点的引用指向插入位置的下一个节点",{"2":{"26":1}}],["然后把原数组中的元素复制到新空间中",{"2":{"8":1}}],["然后根据数组元素的类型和数量来确定数组的大小",{"2":{"2":1}}],["要想真正地理解数据",{"2":{"21":1}}],["要考虑末端元素将失效",{"2":{"4":1}}],["小结",{"0":{"21":1}}],["基于链表可实现",{"2":{"20":1}}],["基于数组可实现",{"2":{"20":1}}],["等",{"2":{"20":1}}],["维度",{"2":{"20":1}}],["张量",{"2":{"20":1}}],["张量之间的线性代数运算",{"2":{"12":1}}],["所有冲突的元素都会被放到一个链表中",{"2":{"33":1}}],["所有的数据结构都可以基于数组或者链表",{"2":{"20":1}}],["所以",{"2":{"45":1}}],["所以你不必亲自跟踪这个值",{"2":{"43":1}}],["所以时间复杂度为o",{"2":{"28":1}}],["所以对时间复杂度不产生影响",{"2":{"14":1}}],["物理结构是指数据在内存中的存储方式是连续的还是非连续的",{"2":{"20":1}}],["物理结构",{"0":{"20":1}}],["非网状结构",{"2":{"19":1}}],["非线性数据结构又可以分为",{"2":{"19":1}}],["非线性数据结构",{"2":{"19":1}}],["网状结构",{"2":{"19":1}}],["网状结构和非网状结构",{"2":{"19":1}}],["逻辑结构主要是描述数据之间的逻辑关系",{"2":{"19":1}}],["逻辑结构",{"0":{"19":1}}],["逻辑结构和物理结构",{"2":{"18":1}}],["​理解数据机构可以从两个层面理解",{"2":{"18":1}}],["树中",{"2":{"33":1}}],["树",{"2":{"18":1,"19":2,"20":2}}],["栈与队列",{"2":{"33":1}}],["栈",{"2":{"18":1,"19":1,"20":2}}],["🌵常见的数据类型有",{"2":{"18":1}}],["🎉一些推算操作数的技巧",{"2":{"14":1}}],["存储空间更多但也更为灵活",{"2":{"32":1}}],["存储数组的空间是连续的",{"2":{"23":1}}],["存储链表的指针和数据通常是分开的",{"2":{"20":1}}],["存储结构并且封装相应操作方法的数据集合",{"2":{"17":1}}],["存储的数据类型相同",{"2":{"0":1}}],["定义",{"2":{"17":1}}],["个",{"2":{"16":1}}],["个分裂出",{"2":{"16":1}}],["从头节点向后依次访问",{"2":{"29":1}}],["从头节点出发",{"2":{"28":1}}],["从",{"2":{"16":1}}],["从而借助高速缓存来提升后续操作的执行速度",{"2":{"10":1}}],["递归实现",{"2":{"16":1}}],["∗1",{"2":{"16":1}}],["∗",{"2":{"16":2}}],["方向单一",{"2":{"32":1}}],["方案数量为",{"2":{"16":1}}],["方法",{"2":{"2":1}}],["求其所有可能的排列方案",{"2":{"16":1}}],["给定",{"2":{"16":1}}],["问题",{"2":{"16":1}}],["全排列",{"2":{"16":1}}],["阶乘阶",{"2":{"16":1}}],["阶乘阶对应数学上的",{"2":{"16":1}}],["阶乘",{"2":{"16":1}}],["8",{"2":{"16":2,"41":1}}],["形成数列",{"2":{"16":1}}],["细胞每轮一分为二",{"2":{"16":1}}],["细胞分裂",{"2":{"16":1}}],["bug",{"2":{"43":2}}],["b",{"2":{"33":1}}],["borrow",{"2":{"25":2,"26":3,"27":4,"28":1,"29":2}}],["base",{"2":{"16":3}}],["brr",{"2":{"2":1}}],["生物学的",{"2":{"16":1}}],["指定位置插入",{"2":{"39":1}}],["指定长度时",{"2":{"2":1}}],["指针",{"2":{"23":1}}],["指数阶",{"2":{"16":2}}],["外层循环和内层循环的时间复杂度都为o",{"2":{"16":1}}],["平方阶通常出现在嵌套循环中",{"2":{"16":1}}],["平方阶的操作数量相对于输入数据大小n以平方级别增长",{"2":{"16":1}}],["平方阶",{"2":{"16":1}}],["两层循环的时间复杂度分别为",{"2":{"16":1}}],["线性数据结构",{"2":{"19":1}}],["线性和非线性",{"0":{"19":1}}],["线性对数阶常出现于嵌套循环中",{"2":{"16":1}}],["线性对数阶",{"2":{"16":2}}],["线性阶o",{"2":{"16":1}}],["while",{"2":{"16":1}}],["center>",{"2":{"44":1}}],["center>一个常量声明的例子",{"2":{"44":1}}],["cell",{"2":{"23":1}}],["constant",{"2":{"44":1}}],["code",{"2":{"43":1}}],["counting",{"2":{"23":1}}],["count",{"2":{"16":17,"38":3}}],["cannot",{"2":{"43":1}}],["capacity",{"2":{"42":14}}],["c",{"2":{"42":2}}],["clear",{"2":{"39":1}}],["clone",{"2":{"25":2,"28":1,"29":1}}],["cpu",{"2":{"33":2}}],["crr",{"2":{"2":1}}],["对应队列",{"2":{"33":1}}],["对应栈",{"2":{"33":1}}],["对应的元素存放在数组中的对应位置",{"2":{"12":1}}],["对比链表和数组从空间和时间上出发",{"2":{"30":1}}],["对数据结构的种类",{"2":{"21":1}}],["对数阶",{"2":{"16":1}}],["对数阶o",{"2":{"16":1}}],["与输入数据n无关",{"2":{"16":1}}],["打印函数的执行时间固定",{"2":{"16":1}}],["算法中",{"2":{"33":1}}],["算法",{"2":{"19":1,"20":1,"33":1}}],["算法属于线性阶",{"2":{"16":1}}],["算法属于对数阶",{"2":{"16":1}}],["算法属于常数阶",{"2":{"16":1}}],["算法函数的时间增长趋势",{"2":{"13":1}}],["常量可以在任意作用域内声明",{"2":{"44":1}}],["常量用const声明",{"2":{"44":1}}],["常量一旦声明",{"2":{"44":1}}],["常量不存在",{"2":{"44":1}}],["常量",{"0":{"44":1}}],["常见链路类型图",{"2":{"32":1}}],["常见的链表类型有三种",{"0":{"32":1}}],["常见的数据结构类型",{"0":{"18":1},"1":{"19":1,"20":1}}],["常见时间复杂度类型图",{"2":{"16":1}}],["常见时间复杂度类型",{"0":{"16":1}}],["常数阶o",{"2":{"16":1}}],["趋势",{"2":{"16":1}}],["gt",{"2":{"15":1}}],["gen",{"2":{"3":1}}],["get",{"2":{"3":1,"42":3}}],["操作数",{"2":{"15":1}}],["应选择合适的容量",{"2":{"42":1}}],["应该搞清楚以下概念",{"2":{"42":1}}],["应该深度的学习每一种数据结构类型",{"2":{"21":1}}],["应为当n趋于无穷大是",{"2":{"15":1}}],["应用",{"0":{"12":1}}],["判断渐进上界",{"0":{"15":1}}],["判断操作数函数的渐进上界",{"2":{"13":1}}],["💯",{"2":{"14":1}}],["j",{"2":{"14":1,"16":1}}],["技巧",{"2":{"14":4}}],["🥚",{"2":{"14":1}}],["点的技巧",{"2":{"14":1}}],["点和第",{"2":{"14":1}}],["总操作数量等于外层循环和内层循环操作数量之积",{"2":{"14":1}}],["循环实现",{"2":{"16":2}}],["循环嵌套时使用乘法",{"2":{"14":1}}],["循环2n次",{"2":{"14":1}}],["都可以简化记为n次",{"2":{"14":1}}],["省略所有系数",{"2":{"14":1}}],["因为这种情况很可能导致",{"2":{"43":1}}],["因为在第二行第一次声明该变量时",{"2":{"43":1}}],["因为链表节点间指针引用的单向性",{"2":{"27":1}}],["因为它们都与n无关",{"2":{"14":1}}],["因链表节点除存储值外还存储引用",{"2":{"23":1}}],["因此引入",{"2":{"34":1}}],["因此引入链表这种相较于数组更灵活的数据结构",{"2":{"23":1}}],["因此在定义节点对象时",{"2":{"23":1}}],["因此在相同数据量下",{"2":{"23":1}}],["因此总体的时间复杂度为",{"2":{"16":1}}],["因此该算法的时间复杂度是常数阶",{"2":{"16":2}}],["因此该算法的的时间复杂度",{"2":{"15":1}}],["因此想获得算法的时间复杂度",{"2":{"14":1}}],["因此只能使用常量来指定长度",{"2":{"2":1}}],["忽略t",{"2":{"14":1}}],["渐进上界",{"2":{"14":1}}],["表示标识算法操作次数的函数的",{"2":{"14":1}}],["of",{"2":{"45":2}}],["one",{"2":{"27":1}}],["o",{"2":{"14":1,"15":8,"16":2,"30":6}}],["option",{"2":{"7":1,"23":1}}],["通常适用于一些永远不会改变的值",{"2":{"44":1}}],["通常将线性时间复杂度记为",{"2":{"14":1}}],["通过重复使用let声明实现遮蔽变量",{"2":{"45":1}}],["通过运行上述代码",{"2":{"43":1}}],["通过对数据结构在逻辑层面和物理层面上的不同理解",{"2":{"21":1}}],["通过索引访问",{"2":{"6":1}}],["通过索引index访问数组中的元素",{"2":{"3":1}}],["时间内完成操作",{"2":{"39":1}}],["时间内访问任意元素",{"2":{"28":1}}],["时间片轮转调度算法是一种常见的",{"2":{"33":1}}],["时间片轮转调度算法",{"2":{"33":1}}],["时间上对比它们的操作方法的时间复杂度",{"2":{"30":1}}],["时间增长趋势",{"0":{"14":1}}],["时间复杂度为2^n",{"2":{"16":1}}],["时间复杂度为o",{"2":{"11":1,"29":1}}],["时间复杂度类型是根据输入数据n的大小与算法执行时间",{"2":{"16":1}}],["时间复杂度由t",{"2":{"15":1}}],["时间复杂度",{"0":{"13":1},"1":{"14":1,"15":1,"16":1},"2":{"15":1}}],["或者二者组合而实现",{"2":{"20":1}}],["或者直接遍历元素本身",{"2":{"6":1}}],["或推断",{"2":{"13":1}}],["根据推断规则得出",{"2":{"14":1}}],["根据",{"2":{"13":1}}],["根据索引实现随机抽样",{"2":{"12":1}}],["计算其操作数函数t",{"2":{"14":1}}],["计算操作数",{"2":{"14":1}}],["计算时间复杂度通常需要两个步骤",{"2":{"13":1}}],["计算机不仅会加载它",{"2":{"10":1}}],["图等",{"2":{"20":1}}],["图等数据结构",{"2":{"12":1}}],["图3",{"2":{"19":1,"20":1}}],["图选自",{"2":{"19":1,"20":1}}],["图",{"2":{"18":1,"19":2,"20":1,"33":1}}],["图的邻接矩阵表示实际上是一个二维数组",{"2":{"12":1}}],["例如",{"2":{"12":1,"14":1}}],["堆",{"2":{"12":1,"18":1,"19":2,"20":2}}],["哈希表和图等数据结构",{"2":{"33":1}}],["哈希表",{"2":{"12":1,"18":1,"19":3,"20":2,"33":1}}],["队列",{"2":{"12":1,"18":1,"19":1,"20":2,"33":1}}],["数量标记",{"2":{"42":1}}],["数据流可能会被分成多个缓冲块并放入一个环形链表",{"2":{"33":1}}],["数据缓冲区",{"2":{"33":1}}],["数据结构是在计算机中具有一定逻辑关系",{"2":{"17":1}}],["数据结构初识",{"0":{"17":1},"1":{"18":1,"19":1,"20":1,"21":1}}],["数据结构实现",{"2":{"12":1}}],["数组与链表的效率对比",{"2":{"30":1}}],["数组可以用于实现栈",{"2":{"12":1}}],["数组可通过索引在时间o",{"2":{"10":1}}],["数组是神经网络编程中最常使用的数据结构",{"2":{"12":1}}],["数组是排序和搜索算法最常用的数据结构",{"2":{"12":1}}],["数组是一种基础且常见的数据结构",{"2":{"12":1}}],["数组需要预先分配固定大小的内存空间",{"2":{"11":1}}],["数组也具备一下缺点",{"2":{"11":1}}],["数组为数据分配了连续的内存块",{"2":{"10":1}}],["数组在内存空间中是连续的一片空间",{"2":{"10":1}}],["数组的长度是固定的",{"2":{"11":1}}],["数组的插入和删除操作需要大量移动元素",{"2":{"11":1}}],["数组的优",{"0":{"9":1},"1":{"10":1,"11":1,"12":1}}],["数组的常见操作",{"0":{"1":1},"1":{"2":1,"3":1,"4":1,"5":1,"6":1,"7":1,"8":1}}],["数组中元素通过索引",{"2":{"0":1}}],["数组将数据存储在计算机中一段连续的存储空间",{"2":{"0":1}}],["数组",{"0":{"0":1},"2":{"18":1,"19":1}}],["这对于代码中很多部分都需要知道一个值的情况特别有用",{"2":{"44":1}}],["这可以使得代码更容易理解",{"2":{"43":1}}],["这可以通过在节点中保存一个指向父节点的引用来实现",{"2":{"33":1}}],["这个程序首先将数值",{"2":{"45":1}}],["这个概念",{"2":{"44":1}}],["这个",{"2":{"43":1}}],["这点很重要",{"2":{"43":1}}],["这一特征让你充分利用",{"2":{"43":1}}],["这里通过固定的倍率来创建更大的新数组",{"2":{"42":1}}],["这里着手实现一个简易列表",{"2":{"42":1}}],["这里是访问所有的元素",{"2":{"28":1}}],["这种循环操作可以通过环形链表来实现",{"2":{"33":1}}],["这种做法包含丰富的先验信息",{"2":{"10":1}}],["这时候使用双向链表就非常合适",{"2":{"33":1}}],["这些数据都是以数组的形式构建的",{"2":{"12":1}}],["矩阵",{"2":{"12":1,"20":1}}],["神经网络中大量使用了向量",{"2":{"12":1}}],["机器学习",{"2":{"12":1}}],["码值作为索引",{"2":{"12":1}}],["码的映射",{"2":{"12":1}}],["则需要进行扩容",{"2":{"42":1}}],["则可以将字符的",{"2":{"12":1}}],["则会造成很大的开销",{"2":{"11":1}}],["则会造成浪费",{"2":{"11":1}}],["假如我们想实现字符到",{"2":{"12":1}}],["可变",{"2":{"44":1}}],["可以通过索引或者直接访问列表元素的方式来遍历列表",{"2":{"38":1}}],["可以像访问数组元素那样通过索引在o",{"2":{"37":1}}],["可以动态扩展长度",{"2":{"34":1}}],["可以使用数组作为查找表",{"2":{"12":1}}],["可基于链表和数组实现",{"2":{"34":1}}],["可扩展",{"2":{"30":1}}],["可能造成内存浪费",{"2":{"11":1}}],["查找链表节点是一种线性查找",{"2":{"29":1}}],["查找节点",{"0":{"29":1},"1":{"32":1,"33":1}}],["查找表",{"2":{"12":1}}],["查找元素",{"0":{"7":1}}],["二分查找等都主要在数组上进行",{"2":{"12":1}}],["归并排序",{"2":{"12":1}}],["快速排序",{"2":{"12":1}}],["并取原来的值加上",{"2":{"45":1}}],["并未标识其为可变",{"2":{"43":1}}],["并根据与初始容量的比较决定是否扩容",{"2":{"42":1}}],["并传递动态head",{"2":{"29":1}}],["并生成一个随机序列",{"2":{"12":1}}],["并且必须标注常量类型",{"2":{"44":1}}],["并且存储类型相同",{"2":{"10":1}}],["并且按照一定的顺序排列",{"2":{"0":1}}],["随机访问",{"2":{"12":1}}],["也可能会使用环形链表",{"2":{"33":1}}],["也可用于实现各种复杂数据结构",{"2":{"12":1}}],["也就意味着分配的内存空间大是固定的",{"2":{"8":1}}],["既频繁应用在各类算法之中",{"2":{"12":1}}],["如下所示",{"2":{"45":2}}],["如下图所示",{"0":{"32":1}}],["如数组在内存中的空间一般是连续的",{"2":{"20":1}}],["如果我们代码的一部分假设某个值永远不会更改",{"2":{"43":1}}],["如果我们想随机抽取一些样本",{"2":{"12":1}}],["如果尝试改变会发生什么",{"2":{"43":1}}],["如果只有头节点",{"2":{"27":1}}],["如果分配的空间超过需要存储的数据",{"2":{"11":1}}],["如需要扩容",{"2":{"11":1}}],["无初始值",{"2":{"36":2}}],["无需全部解除头尾节点的引用",{"2":{"27":1}}],["无法动态调整",{"2":{"11":1}}],["无须额外的结构开销",{"2":{"10":1}}],["插入和删除元素",{"0":{"39":1}}],["插入和删除操作效率低",{"2":{"11":1}}],["插入节点",{"0":{"26":1}}],["插入元素",{"0":{"4":1}}],["缺点",{"0":{"11":1}}],["缺点和应用",{"0":{"9":1},"1":{"10":1,"11":1,"12":1}}],["缓存局部性",{"2":{"10":1}}],["支持随机访问",{"2":{"10":1}}],["系统可以利用这些信息来优化数据结构的操作效率",{"2":{"10":1}}],["优点",{"0":{"10":1}}],["str`",{"2":{"45":1}}],["std",{"2":{"23":2}}],["sapces",{"2":{"45":1}}],["spaces",{"2":{"45":5}}],["scope",{"2":{"45":1}}],["shadow",{"0":{"45":1},"2":{"45":1}}],["slef",{"2":{"42":1}}],["self",{"2":{"42":40}}],["sort",{"2":{"40":1}}],["some",{"2":{"7":1,"25":2,"26":1,"27":1,"28":1,"29":1}}],["square",{"2":{"16":1}}],["size",{"2":{"8":2,"42":14}}],["7",{"0":{"8":1}}],["x恢复为6",{"2":{"45":1}}],["x",{"2":{"43":13,"45":16}}],["x3c",{"2":{"7":1,"16":1,"23":3,"26":7,"27":4,"28":7,"29":4,"36":2,"42":1,"44":2}}],["x26",{"2":{"2":2,"3":1,"4":1,"5":1,"6":1,"7":1,"8":1,"26":1,"27":1,"28":2,"29":2,"38":1,"42":8,"45":1}}],["the",{"2":{"45":3}}],["thread",{"2":{"3":1}}],["to",{"2":{"43":1}}],["twice",{"2":{"43":1}}],["tagart元素对应索引",{"2":{"29":1}}],["take",{"2":{"26":1,"27":2}}],["target",{"2":{"7":2,"29":4}}],["t>>>",{"2":{"27":1,"28":1,"29":1}}],["t>>",{"2":{"26":2,"28":1}}],["t>",{"2":{"26":1,"27":1,"28":1}}],["t",{"2":{"14":1,"29":2}}],["tip",{"2":{"14":1}}],["的值变成了",{"2":{"45":1}}],["的根源在实际开发中可能很难追踪",{"2":{"43":1}}],["的变化来决定的",{"2":{"16":1}}],["的查找算法",{"2":{"7":1}}],["的数组",{"2":{"20":1}}],["的数组访问函数",{"2":{"3":1}}],["的数组被设计为在编译期确定长度",{"2":{"2":1}}],["node",{"2":{"26":5,"27":10,"28":4,"29":4}}],["none",{"2":{"7":1,"25":3}}],["n1",{"2":{"25":3,"26":2,"27":2}}],["n0",{"2":{"25":3}}],["next",{"2":{"23":1,"25":5,"26":3,"27":6,"28":1,"29":1}}],["new",{"2":{"8":3,"25":6,"36":1,"42":5}}],["n−2",{"2":{"16":1}}],["n−1",{"2":{"16":1}}],["n互不重复的元素",{"2":{"16":1}}],["n2",{"2":{"15":1,"25":2}}],["n^3",{"2":{"15":2}}],["n^2",{"2":{"15":2,"16":1}}],["n",{"2":{"7":1,"11":1,"14":12,"15":5,"16":31,"28":1,"29":1,"30":3,"39":1}}],["nums",{"2":{"4":5,"5":4,"37":1}}],["num",{"2":{"4":4,"37":1}}],["知道找到对应值",{"2":{"7":1}}],["6",{"0":{"7":1,"41":1},"2":{"36":1,"39":1,"41":1,"45":2}}],["last",{"2":{"42":2}}],["lru",{"2":{"33":2}}],["lisstnode",{"2":{"25":3}}],["list",{"0":{"34":1},"2":{"25":1,"30":1,"42":3}}],["listnode>>>",{"2":{"23":1}}],["listnode",{"2":{"23":1,"26":2,"27":1,"28":1,"29":1}}],["link",{"2":{"25":1,"30":1}}],["linear",{"2":{"16":4}}],["logarithmic",{"2":{"16":1}}],["log",{"2":{"16":5}}],["loop",{"2":{"6":1}}],["lt",{"2":{"15":1}}],["len",{"2":{"3":1,"4":1,"5":1,"6":1,"7":1,"8":2,"38":1,"42":1,"45":2}}],["let",{"2":{"2":4,"3":2,"8":1,"14":1,"16":7,"25":2,"26":1,"27":3,"28":1,"29":1,"36":2,"37":1,"42":1,"45":8}}],["末端位置的元素将为none",{"2":{"5":1}}],["处的元素更新为",{"2":{"37":1}}],["处的元素",{"2":{"4":1,"37":1}}],["处插入元素",{"2":{"4":1}}],["赋给",{"2":{"4":1}}],["将获得第二个值",{"2":{"45":1}}],["将收到编译器的报错",{"2":{"43":1}}],["将索引",{"2":{"37":1}}],["将切换到下一个进程",{"2":{"33":1}}],["将头节点的指针修改指向至删除节点后面的节点",{"2":{"27":1}}],["将头节点指针指向插入节点",{"2":{"26":1}}],["将插入节点的指针指向原本第二节点",{"2":{"26":1}}],["将",{"2":{"4":1}}],["+=",{"2":{"16":6,"38":2,"42":2}}],["+1",{"2":{"15":1}}],["+n",{"2":{"14":2}}],["+0",{"2":{"14":2}}],["+",{"2":{"4":1,"5":1,"8":1,"14":3,"15":5,"16":6,"45":1}}],["found",{"2":{"45":1}}],["focus",{"2":{"43":1}}],["for",{"2":{"4":1,"5":1,"6":2,"7":1,"8":1,"14":3,"16":8,"42":2}}],["factorial",{"2":{"16":2}}],["find",{"2":{"7":1,"29":2}}],["fn",{"2":{"3":1,"4":1,"5":1,"6":1,"7":1,"8":1,"14":1,"16":8,"25":1,"42":9,"45":1}}],["以便实现无缝播放",{"2":{"33":1}}],["以上述结构体为例",{"2":{"25":1}}],["以及支持快速添加和删除节点",{"2":{"33":1}}],["以及不同数据结构之间的关系有了一定的了解",{"2":{"21":1}}],["以及之后的所有元素向后移动一位",{"2":{"4":1}}],["以此类推",{"2":{"16":1}}],["以下面算法为例",{"2":{"14":1}}],["以下将",{"2":{"2":1}}],["把索引",{"2":{"4":1}}],["当该作用域结束时",{"2":{"45":1}}],["当我们尝试改变一个前面指定为不可变的值时我们会得到编译期错误",{"2":{"43":1}}],["当进行增删等操作时",{"2":{"42":1}}],["当然也可实现自己构造函数",{"2":{"36":1}}],["当然这些都还是很浅显的认知",{"2":{"21":1}}],["当时间片用完时",{"2":{"33":1}}],["当用户点击前进或后退按钮时",{"2":{"33":1}}],["当插入操作在链表的一端进行",{"2":{"33":1}}],["当插入和删除操作都在链表的一端进行时",{"2":{"33":1}}],["当前节点值等于target时",{"2":{"29":1}}],["当算法的运行时间跟输入数据n成正比时",{"2":{"16":1}}],["当算法的运行时间跟输入数据n的log成正比时",{"2":{"16":1}}],["当算法的运行时间跟输入数据n无关时",{"2":{"16":1}}],["当需要快速查找一个元素或其对应关系时",{"2":{"12":1}}],["当访问数组元素时",{"2":{"10":1}}],["当元素超出数组长度的时候",{"2":{"4":1}}],["当索引超出数组长度时会产生无效的访问",{"2":{"3":1}}],["rate",{"2":{"42":3}}],["range",{"2":{"3":1}}],["rand",{"2":{"3":5}}],["rc",{"2":{"23":3,"25":3,"26":2,"27":1,"28":2,"29":1}}],["rc即引用计数",{"2":{"23":1}}],["resize",{"2":{"42":2}}],["remove",{"2":{"39":2}}],["refcell",{"2":{"23":2,"25":3,"26":2,"27":1,"28":2,"29":1}}],["reference",{"2":{"23":1}}],["return",{"2":{"16":3,"27":1,"28":3,"29":3,"42":1}}],["recur",{"2":{"16":5}}],["rev",{"2":{"4":1}}],["rng",{"2":{"3":1}}],["rust\\tconst",{"2":{"44":1}}],["rust\\tstruct",{"2":{"42":1}}],["rust\\tvec2",{"2":{"39":1,"40":1}}],["rust\\tlet",{"2":{"38":1,"41":1}}],["rust\\tfn",{"2":{"36":1,"43":2,"45":1}}],["rust\\t",{"2":{"26":1,"27":1,"28":1,"29":1}}],["rust\\tuse",{"2":{"23":1}}],["rust",{"2":{"2":4,"3":1,"4":1,"5":1,"6":1,"7":1,"8":1,"14":1,"16":7,"25":1,"37":1,"43":2,"45":1}}],[">=",{"2":{"42":5}}],[">",{"2":{"3":1,"7":1,"16":9,"28":1,"29":1,"42":4}}],["expected",{"2":{"45":1}}],["exponential",{"2":{"16":1}}],["extend",{"2":{"2":1,"41":1,"42":3}}],["enlarge",{"2":{"8":3}}],["element",{"2":{"3":3,"5":1,"7":1,"42":3}}],["按照元素排列递增",{"2":{"3":1}}],["看作数组",{"2":{"2":1}}],["一直访问下一个节点",{"2":{"28":1}}],["一下代码实现在头节点后插入节点",{"2":{"26":1}}],["一些操作数对应的时间复杂度",{"2":{"15":1}}],["一般情况下用作动态数组的类型",{"2":{"2":1}}],["一旦创建",{"2":{"0":1}}],["是指数阶增长的典型例子",{"2":{"16":1}}],["是",{"2":{"2":1}}],["为了方便实现扩容",{"2":{"2":1}}],["为切片",{"2":{"2":1}}],["为数组",{"2":{"2":1}}],["不同于变量使用let声明",{"2":{"44":1}}],["不同于数组访问可以在o",{"2":{"28":1}}],["不能对不可变变量二次赋值",{"2":{"43":1}}],["不可变变量意味着一旦声明后值就不能改变",{"2":{"43":1}}],["不过你也可以选择让变量是可变的",{"2":{"43":1}}],["不指定长度时",{"2":{"2":1}}],["不初始化值",{"2":{"2":1}}],["中最高阶的项来决定",{"2":{"15":1}}],["中的常数项",{"2":{"14":1}}],["中",{"2":{"2":1}}],["在内部作用域内",{"2":{"45":1}}],["在rust中",{"2":{"43":1}}],["在rust中使用智能指针rc来定义链表引用",{"2":{"23":1}}],["在中间插入元素",{"2":{"42":1}}],["在尾部插入元素",{"2":{"42":1}}],["在动手编写代码前",{"2":{"42":1}}],["在索引index处插入value",{"2":{"39":1}}],["在列表的末尾可以在o",{"2":{"39":1}}],["在许多高级编程语言的标准库中都初始了动态数组的构造方法",{"2":{"36":1}}],["在某些数据缓冲区的实现中",{"2":{"33":1}}],["在操作系统中",{"2":{"33":1}}],["在缓存淘汰",{"2":{"33":1}}],["在网页浏览器中",{"2":{"33":1}}],["在该方案中",{"2":{"33":1}}],["在环形链表中任一节点都可以作为头节点",{"2":{"32":1}}],["在这里我们删除头节点后的节点",{"2":{"27":1}}],["在具备这些优点的同时",{"2":{"11":1}}],["在数组有效索引范围内查找元素",{"2":{"7":1}}],["在数组的索引",{"2":{"4":1}}],["在数组中插入元素",{"2":{"4":1}}],["在",{"2":{"2":1}}],["0",{"2":{"2":7,"3":1,"6":1,"7":1,"8":2,"14":5,"16":15,"25":1,"28":1,"37":2,"38":3,"42":3,"43":3}}],["4",{"0":{"5":1,"31":1,"39":1},"1":{"32":1,"33":1},"2":{"2":2,"16":2,"41":1}}],["30",{"2":{"44":2}}],["3n+2",{"2":{"15":1}}],["3n+1次等",{"2":{"14":1}}],["3",{"0":{"4":1,"16":1,"30":1,"38":1},"2":{"2":2,"14":1,"36":1,"39":2}}],["2^",{"2":{"16":2}}],["2^n个细胞",{"2":{"16":1}}],["2^n",{"2":{"15":2,"16":1}}],["2n^2",{"2":{"15":1}}],["2n",{"2":{"15":2}}],["2",{"0":{"3":1,"15":1,"24":1,"37":1},"1":{"25":1,"26":1,"27":1,"28":1,"29":1},"2":{"2":2,"13":1,"14":3,"16":6,"20":1,"25":1,"36":1,"42":1,"45":2}}],["=n∗",{"2":{"16":1}}],["=n2+n",{"2":{"14":1}}],["==",{"2":{"7":1,"15":1,"16":1,"29":1,"42":1}}],["=",{"2":{"2":3,"3":2,"4":2,"5":1,"8":2,"14":2,"16":12,"25":5,"26":3,"27":4,"28":2,"29":1,"36":2,"37":2,"38":2,"41":1,"42":11,"43":4,"44":1,"45":8}}],["5",{"0":{"6":1,"40":1},"2":{"2":8,"14":1,"36":1,"45":2}}],["immutable",{"2":{"43":1}}],["immuable",{"2":{"43":1}}],["i+1",{"2":{"42":1}}],["item",{"2":{"38":2}}],["is",{"2":{"27":1,"45":2}}],["if",{"2":{"7":1,"16":2,"27":2,"28":2,"29":2,"42":5}}],["i",{"2":{"4":3,"5":3,"6":4,"7":3,"8":3,"14":2,"16":4,"38":2,"42":5}}],["inner",{"2":{"45":1}}],["inite",{"2":{"25":1}}],["info",{"2":{"15":1}}],["in",{"2":{"4":1,"5":1,"6":2,"7":1,"8":1,"14":3,"16":8,"38":2,"42":2,"45":1}}],["insert",{"2":{"4":1,"26":1,"39":1}}],["index+1",{"2":{"29":1,"42":1}}],["index",{"2":{"0":1,"3":2,"4":6,"5":2,"28":4,"29":4,"39":2,"42":15}}],["i32>",{"2":{"36":2,"42":1}}],["i32",{"2":{"2":6,"3":2,"4":2,"5":1,"6":1,"7":2,"8":1,"14":1,"16":17,"23":1,"28":1,"29":2,"37":1,"42":5,"44":1}}],["add",{"2":{"42":2}}],["acess",{"2":{"28":1}}],["access",{"2":{"28":1}}],["assign",{"2":{"43":1}}],["as",{"2":{"16":1}}],["ascii",{"2":{"12":2}}],["alog",{"2":{"16":2}}],["algorithm",{"2":{"14":1}}],["array这个概念来实现列表",{"2":{"34":1}}],["array",{"2":{"2":1,"30":1}}],["arr",{"2":{"2":1,"3":3,"6":4,"7":3,"8":7}}],["a",{"2":{"2":1,"14":3}}],["12",{"2":{"45":2}}],["11",{"2":{"39":1}}],["1次",{"2":{"28":1}}],["1000",{"2":{"16":1}}],["10000n^2",{"2":{"15":1}}],["1000000",{"2":{"15":1}}],["10",{"2":{"15":1,"43":3}}],["1",{"0":{"2":1,"14":1,"23":1,"36":1},"2":{"2":2,"3":1,"4":2,"5":2,"10":1,"13":1,"14":6,"15":1,"16":18,"19":1,"25":1,"28":2,"29":1,"30":3,"36":1,"37":5,"39":1,"42":6,"45":2}}],["标识其在数组中的位置",{"2":{"0":1}}]],"serializationVersion":2}';export{t as default};
