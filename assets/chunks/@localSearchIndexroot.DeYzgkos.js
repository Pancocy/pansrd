const t='{"documentCount":97,"nextId":97,"documentIds":{"0":"/datastru/ds-array.html#数组","1":"/datastru/ds-array.html#_1-数组的常见操作","2":"/datastru/ds-array.html#_1-1-初始化数组","3":"/datastru/ds-array.html#_1-2-访问数组元素","4":"/datastru/ds-array.html#_1-3-插入元素","5":"/datastru/ds-array.html#_1-4-删除元素","6":"/datastru/ds-array.html#_1-5-遍历数组","7":"/datastru/ds-array.html#_1-6-查找元素","8":"/datastru/ds-array.html#_1-7-扩容数组","9":"/datastru/ds-array.html#数组的优、缺点和应用","10":"/datastru/ds-array.html#优点","11":"/datastru/ds-array.html#缺点","12":"/datastru/ds-array.html#应用","13":"/datastru/ds-complexity.html#时间复杂度","14":"/datastru/ds-complexity.html#_1-时间增长趋势","15":"/datastru/ds-complexity.html#_2-判断渐进上界","16":"/datastru/ds-complexity.html#_3-常见时间复杂度类型","17":"/datastru/ds-complexity.html#_3-1-常数阶o-1","18":"/datastru/ds-complexity.html#_3-2-对数阶o-log-n","19":"/datastru/ds-complexity.html#_3-3-线性阶o-n","20":"/datastru/ds-complexity.html#_3-4-线性对数阶","21":"/datastru/ds-complexity.html#_3-5-平方阶","22":"/datastru/ds-complexity.html#_3-6-指数阶","23":"/datastru/ds-complexity.html#_3-7-阶乘","24":"/datastru/ds-datastructure.html#数据结构","25":"/datastru/ds-datastructure.html#_1-逻辑结构-线性和非线性","26":"/datastru/ds-datastructure.html#_2-物理结构-连续和非连续","27":"/datastru/ds-datastructure.html#小结","28":"/datastru/ds-hashmap.html#什么是hash-table","29":"/datastru/ds-hashmap.html#实现哈希表数据结构","30":"/datastru/ds-hashmap.html#哈希冲突","31":"/datastru/ds-linkedlist.html#_1-链表简介","32":"/datastru/ds-linkedlist.html#_2-链表相关操作","33":"/datastru/ds-linkedlist.html#_2-1-初始化链表","34":"/datastru/ds-linkedlist.html#_2-2-插入节点","35":"/datastru/ds-linkedlist.html#_2-3-删除节点","36":"/datastru/ds-linkedlist.html#_2-4-访问节点","37":"/datastru/ds-linkedlist.html#_2-5-查找节点","38":"/datastru/ds-linkedlist.html#_3-链表vs数组","39":"/datastru/ds-linkedlist.html#_4-链表的类型及应用","40":"/datastru/ds-linkedlist.html#_4-1-常见的链表类型","41":"/datastru/ds-linkedlist.html#_4-2-各类链表的应用","42":"/datastru/ds-list.html#列表-list","43":"/datastru/ds-list.html#_1-列表的常用操作","44":"/datastru/ds-list.html#_1-1-初始化列表","45":"/datastru/ds-list.html#_1-2-访问列表元素","46":"/datastru/ds-list.html#_1-3-遍历列表元素","47":"/datastru/ds-list.html#_1-4-插入和删除元素","48":"/datastru/ds-list.html#_1-5-排序列表","49":"/datastru/ds-list.html#_1-6-组合列表","50":"/datastru/ds-list.html#_2-列表的实现原理","51":"/datastru/ds-queue.html#实现简单结构的队列","52":"/datastru/ds-queue.html#_1-链表实现队列","53":"/datastru/ds-queue.html#_2-数组实现队列","54":"/datastru/ds-stack.html#栈","55":"/datastru/ds-stack.html#_1-认识栈","56":"/datastru/ds-stack.html#_2-栈的实现","57":"/datastru/ds-stack.html#_2-1-基于链表实现栈","58":"/datastru/ds-stack.html#_2-2-基于数组实现栈","59":"/rust/chapter1/controlFlow.html#控制流","60":"/rust/chapter1/controlFlow.html#if-表达式","61":"/rust/chapter1/controlFlow.html#_1-if-表达式的特征","62":"/rust/chapter1/controlFlow.html#_2-在-let-语句中使用-if","63":"/rust/chapter1/controlFlow.html#循环","64":"/rust/chapter1/controlFlow.html#_1-loop循环","65":"/rust/chapter1/controlFlow.html#_2-while条件循环","66":"/rust/chapter1/controlFlow.html#_3-for-循环遍历集合","67":"/rust/chapter1/controlFlow.html#_4-循环标签、continue、break","68":"/rust/chapter1/controlFlow.html#模式匹配","69":"/rust/chapter1/datatype.html#基本数据类型","70":"/rust/chapter1/datatype.html#标量类型","71":"/rust/chapter1/datatype.html#_1-整型","72":"/rust/chapter1/datatype.html#_2-浮点型","73":"/rust/chapter1/datatype.html#_3-数字运算","74":"/rust/chapter1/datatype.html#_4-布尔类型","75":"/rust/chapter1/datatype.html#_5-字符类型","76":"/rust/chapter1/datatype.html#复合类型","77":"/rust/chapter1/datatype.html#_1-元组","78":"/rust/chapter1/datatype.html#_2-数组","79":"/rust/chapter1/func-loop.html#函数","80":"/rust/chapter1/func-loop.html#具有参数的函数","81":"/rust/chapter1/func-loop.html#具有返回值的函数","82":"/rust/chapter1/func-loop.html#语句和表达式","83":"/rust/chapter1/func-loop.html#_1-语句","84":"/rust/chapter1/func-loop.html#_2-表达式","85":"/rust/chapter1/variable.html#变量与可变性","86":"/rust/chapter1/variable.html#常量","87":"/rust/chapter1/variable.html#遮蔽-shadow","88":"/rust/chapter2/ownership.html#所有权的目标","89":"/rust/chapter2/ownership.html#所有权的规则","90":"/rust/chapter2/ownership.html#变量作用域","91":"/rust/chapter2/ownership.html#_1-什么是作用域","92":"/rust/chapter2/ownership.html#_2-string类型","93":"/rust/chapter2/ownership.html#内存与分配","94":"/rust/chapter2/ownership.html#_1-数据的交互方式一-移动-move","95":"/rust/chapter2/ownership.html#_2-数据的交互方式二-克隆","96":"/rust/chapter2/ownership.html#drop"},"fieldIds":{"title":0,"titles":1,"text":2},"fieldLength":{"0":[1,1,9],"1":[2,1,1],"2":[2,2,42],"3":[3,2,26],"4":[3,2,30],"5":[3,2,20],"6":[3,2,17],"7":[3,2,28],"8":[3,2,24],"9":[2,1,1],"10":[1,2,13],"11":[1,2,15],"12":[1,2,34],"13":[1,1,9],"14":[2,1,48],"15":[2,1,29],"16":[2,1,5],"17":[4,2,20],"18":[6,2,20],"19":[4,2,19],"20":[3,2,30],"21":[3,2,24],"22":[3,2,37],"23":[3,2,36],"24":[1,1,14],"25":[3,1,22],"26":[3,1,27],"27":[1,1,7],"28":[3,1,55],"29":[1,1,93],"30":[1,1,9],"31":[2,1,45],"32":[2,1,1],"33":[3,2,33],"34":[2,2,34],"35":[3,2,41],"36":[3,2,47],"37":[3,2,49],"38":[2,1,31],"39":[2,1,1],"40":[3,2,16],"41":[3,2,57],"42":[3,1,15],"43":[2,1,1],"44":[2,2,25],"45":[3,2,19],"46":[3,2,18],"47":[3,2,25],"48":[3,2,4],"49":[3,2,13],"50":[2,1,93],"51":[1,1,14],"52":[2,1,108],"53":[2,1,83],"54":[1,1,10],"55":[2,1,43],"56":[2,1,12],"57":[3,2,88],"58":[2,2,1],"59":[1,1,8],"60":[2,1,1],"61":[3,2,49],"62":[5,2,34],"63":[1,1,7],"64":[2,1,15],"65":[2,1,27],"66":[3,1,47],"67":[4,1,72],"68":[1,1,3],"69":[1,1,10],"70":[1,1,7],"71":[2,1,83],"72":[2,1,22],"73":[2,1,45],"74":[2,1,14],"75":[2,1,21],"76":[1,1,7],"77":[2,1,45],"78":[2,1,52],"79":[1,1,29],"80":[1,1,19],"81":[1,1,35],"82":[1,1,9],"83":[2,1,32],"84":[2,1,25],"85":[1,1,51],"86":[1,1,51],"87":[3,1,72],"88":[1,1,20],"89":[1,1,9],"90":[1,1,1],"91":[2,1,7],"92":[2,1,51],"93":[1,1,44],"94":[5,1,106],"95":[3,1,1],"96":[1,1,1]},"averageFieldLength":[2.1855670103092777,1.3505154639175254,29.103092783505154],"storedFields":{"0":{"title":"数组","titles":[]},"1":{"title":"1. 数组的常见操作","titles":[]},"2":{"title":"1.1 初始化数组","titles":["1. 数组的常见操作"]},"3":{"title":"1.2 访问数组元素","titles":["1. 数组的常见操作"]},"4":{"title":"1.3  插入元素","titles":["1. 数组的常见操作"]},"5":{"title":"1.4 删除元素","titles":["1. 数组的常见操作"]},"6":{"title":"1.5 遍历数组","titles":["1. 数组的常见操作"]},"7":{"title":"1.6 查找元素","titles":["1. 数组的常见操作"]},"8":{"title":"1.7 扩容数组","titles":["1. 数组的常见操作"]},"9":{"title":"数组的优、缺点和应用","titles":[]},"10":{"title":"优点","titles":["数组的优、缺点和应用"]},"11":{"title":"缺点","titles":["数组的优、缺点和应用"]},"12":{"title":"应用","titles":["数组的优、缺点和应用"]},"13":{"title":"时间复杂度","titles":[]},"14":{"title":"1. 时间增长趋势","titles":[]},"15":{"title":"2. 判断渐进上界","titles":[]},"16":{"title":"3. 常见时间复杂度类型","titles":[]},"17":{"title":"3.1 常数阶O(1)","titles":["3. 常见时间复杂度类型"]},"18":{"title":"3.2 对数阶O(log n)","titles":["3. 常见时间复杂度类型"]},"19":{"title":"3.3 线性阶O(n)","titles":["3. 常见时间复杂度类型"]},"20":{"title":"3.4 线性对数阶","titles":["3. 常见时间复杂度类型"]},"21":{"title":"3.5 平方阶","titles":["3. 常见时间复杂度类型"]},"22":{"title":"3.6 指数阶","titles":["3. 常见时间复杂度类型"]},"23":{"title":"3.7 阶乘","titles":["3. 常见时间复杂度类型"]},"24":{"title":"数据结构","titles":[]},"25":{"title":"1 逻辑结构：线性和非线性","titles":[]},"26":{"title":"2 物理结构：连续和非连续","titles":[]},"27":{"title":"小结","titles":[]},"28":{"title":"什么是Hash Table?","titles":[]},"29":{"title":"实现哈希表数据结构","titles":[]},"30":{"title":"哈希冲突","titles":[]},"31":{"title":"1. 链表简介","titles":[]},"32":{"title":"2. 链表相关操作","titles":[]},"33":{"title":"2.1 初始化链表","titles":["2. 链表相关操作"]},"34":{"title":"2.2 插入节点","titles":["2. 链表相关操作"]},"35":{"title":"2.3 删除节点","titles":["2. 链表相关操作"]},"36":{"title":"2.4 访问节点","titles":["2. 链表相关操作"]},"37":{"title":"2.5 查找节点","titles":["2. 链表相关操作"]},"38":{"title":"3. 链表VS数组","titles":[]},"39":{"title":"4. 链表的类型及应用","titles":[]},"40":{"title":"4.1 常见的链表类型","titles":["4. 链表的类型及应用"]},"41":{"title":"4.2 各类链表的应用","titles":["4. 链表的类型及应用"]},"42":{"title":"列表（List）","titles":[]},"43":{"title":"1. 列表的常用操作","titles":[]},"44":{"title":"1.1 初始化列表","titles":["1. 列表的常用操作"]},"45":{"title":"1.2 访问列表元素","titles":["1. 列表的常用操作"]},"46":{"title":"1.3 遍历列表元素","titles":["1. 列表的常用操作"]},"47":{"title":"1.4 插入和删除元素","titles":["1. 列表的常用操作"]},"48":{"title":"1.5 排序列表","titles":["1. 列表的常用操作"]},"49":{"title":"1.6 组合列表","titles":["1. 列表的常用操作"]},"50":{"title":"2. 列表的实现原理","titles":[]},"51":{"title":"实现简单结构的队列","titles":[]},"52":{"title":"1. 链表实现队列","titles":[]},"53":{"title":"2. 数组实现队列","titles":[]},"54":{"title":"栈","titles":[]},"55":{"title":"1. 认识栈","titles":[]},"56":{"title":"2. 栈的实现","titles":[]},"57":{"title":"2.1. 基于链表实现栈","titles":["2. 栈的实现"]},"58":{"title":"2.2. 基于数组实现栈","titles":["2. 栈的实现"]},"59":{"title":"控制流","titles":[]},"60":{"title":"if 表达式","titles":[]},"61":{"title":"1. if 表达式的特征","titles":["if 表达式"]},"62":{"title":"2. 在 let 语句中使用 if","titles":["if 表达式"]},"63":{"title":"循环","titles":[]},"64":{"title":"1. loop循环","titles":["循环"]},"65":{"title":"2. while条件循环","titles":["循环"]},"66":{"title":"3. for 循环遍历集合","titles":["循环"]},"67":{"title":"4. 循环标签、continue、break","titles":["循环"]},"68":{"title":"模式匹配","titles":[]},"69":{"title":"基本数据类型","titles":[]},"70":{"title":"标量类型","titles":[]},"71":{"title":"1. 整型","titles":["标量类型"]},"72":{"title":"2.  浮点型","titles":["标量类型"]},"73":{"title":"3.  数字运算","titles":["标量类型"]},"74":{"title":"4. 布尔类型","titles":["标量类型"]},"75":{"title":"5. 字符类型","titles":["标量类型"]},"76":{"title":"复合类型","titles":[]},"77":{"title":"1. 元组","titles":["复合类型"]},"78":{"title":"2. 数组","titles":["复合类型"]},"79":{"title":"函数","titles":[]},"80":{"title":"具有参数的函数","titles":[]},"81":{"title":"具有返回值的函数","titles":[]},"82":{"title":"语句和表达式","titles":[]},"83":{"title":"1. 语句","titles":["语句和表达式"]},"84":{"title":"2. 表达式","titles":["语句和表达式"]},"85":{"title":"变量与可变性","titles":[]},"86":{"title":"常量","titles":[]},"87":{"title":"遮蔽（Shadow）","titles":[]},"88":{"title":"所有权的目标","titles":[]},"89":{"title":"所有权的规则","titles":[]},"90":{"title":"变量作用域","titles":[]},"91":{"title":"1. 什么是作用域","titles":["变量作用域"]},"92":{"title":"2. String类型","titles":["变量作用域"]},"93":{"title":"内存与分配","titles":[]},"94":{"title":"1. 数据的交互方式一：移动(move)","titles":["内存与分配"]},"95":{"title":"2. 数据的交互方式二：克隆","titles":["内存与分配"]},"96":{"title":"drop","titles":["内存与分配"]}},"dirtCount":0,"index":[["克隆",{"0":{"95":1}}],["被move的数据已经不再可用",{"2":{"94":1}}],["被break跳出",{"2":{"67":1}}],["两次释放",{"2":{"94":1}}],["两层循环的时间复杂度分别为",{"2":{"20":1}}],["真实数据只有一份在堆之上",{"2":{"94":1}}],["^",{"2":{"94":1}}],["已知大小数据的move操作后",{"2":{"94":1}}],["你可能认为会生成s的拷贝并绑定到z上",{"2":{"94":1}}],["你要请求一定大小的空间",{"2":{"88":1}}],["声明变量x的值为5",{"2":{"94":1}}],["声明具有更高的灵活性",{"2":{"87":1}}],["移动就是拷贝一份",{"2":{"94":1}}],["移动",{"0":{"94":1}}],["此时s和z在内存中的表现形式如下图所示",{"2":{"94":1}}],["此作用域已结束",{"2":{"93":1}}],["此外每个参数都必须标注类型",{"2":{"80":1}}],["此外浮点数和整数之间可以进行运算",{"2":{"73":1}}],["开始有效",{"2":{"93":1}}],["释放相应的内存",{"2":{"93":1}}],["向内存管理器返回内存",{"2":{"93":1}}],["运行时向内存分配器申请一定的内存",{"2":{"93":1}}],["运算结果为浮点数",{"2":{"73":1}}],["运算符包括加",{"2":{"73":1}}],["思考一个问题",{"2":{"92":1}}],["drop",{"0":{"96":1}}],["drop函数是一个特殊的函数",{"2":{"94":1}}],["double",{"2":{"94":1}}],["does",{"2":{"92":1,"94":1}}],["dead",{"2":{"52":1}}],["del",{"2":{"50":2}}],["delete",{"2":{"5":1,"35":1,"50":1}}],["debug",{"2":{"29":2,"52":2,"57":1}}],["derive",{"2":{"29":2,"52":2,"57":1}}],["管辖范围",{"2":{"92":1}}],["属于所有权系统的",{"2":{"92":1}}],["属性",{"2":{"56":1}}],["引入string类型帮助理解作用域",{"2":{"92":1}}],["作用域有两个重要的时间节点",{"2":{"91":1}}],["作用域结束",{"2":{"87":1}}],["项",{"2":{"91":1}}],["什么是作用域",{"0":{"91":1}}],["什么是hash",{"0":{"28":1}}],["离开作用域后",{"2":{"89":1}}],["都有一个称其",{"2":{"89":1}}],["都可以简化记为n次",{"2":{"14":1}}],["把它标记为已使用",{"2":{"88":1}}],["把索引",{"2":{"4":1}}],["关于长度和容量并不是同样的概念",{"2":{"94":1}}],["关于为什么是管理堆内存而不是栈内存",{"2":{"88":1}}],["关键字+",{"2":{"81":1}}],["关键字告诉程序跳过当前迭代中的任何剩余代码",{"2":{"67":1}}],["关键字来告诉程序何时停止循环",{"2":{"67":1}}],["追踪哪些代码在堆上使用了哪些数据",{"2":{"88":1}}],["准确来说",{"2":{"88":1}}],["恢复成",{"2":{"87":1}}],["内容存储在堆",{"2":{"92":1}}],["内存会导致内存污染",{"2":{"94":1}}],["内存与分配",{"0":{"93":1},"1":{"94":1,"95":1,"96":1}}],["内存分配器",{"2":{"88":1}}],["内存管理",{"2":{"88":1}}],["内部遮蔽结束并且",{"2":{"87":1}}],["内访问任何元素",{"2":{"10":1,"45":1}}],["得益于它的不可变性",{"2":{"93":1}}],["得到的",{"2":{"87":1}}],["得出其操作数函数",{"2":{"13":1}}],["来清理堆上分配的内存",{"2":{"94":1}}],["来遮蔽之前的",{"2":{"87":1}}],["来自",{"2":{"51":1,"52":1,"53":1}}],["绑定到",{"2":{"87":1}}],["再尝试使用被移动的数据会发生什么",{"2":{"94":1}}],["再次声明则不限制数据类型",{"2":{"87":1}}],["再次使用这个变量时",{"2":{"87":1}}],["再将当前数组的所有元素依次移动至新数组",{"2":{"50":1}}],["遮蔽相较于",{"2":{"87":1}}],["遮蔽失效",{"2":{"87":1}}],["遮蔽是当以相同的名字再次声明变量时",{"2":{"87":1}}],["遮蔽",{"0":{"87":1}}],["包括全局作用域",{"2":{"86":1}}],["特别是第二部分代码只是偶尔变更了原来的值",{"2":{"85":1}}],["特殊的元组",{"2":{"77":1}}],["接下来尝试用下面的代码来分析",{"2":{"85":1}}],["提供的安全性和简单并发性的方式来编写代码",{"2":{"85":1}}],["默认情况下的变量是不可变的immutable",{"2":{"85":1}}],["初特殊声明外",{"2":{"85":1}}],["初始容量",{"2":{"50":1}}],["初始值应为0",{"2":{"37":1}}],["初始状态为1个细胞",{"2":{"22":1}}],["初始化栈",{"2":{"57":1}}],["初始化该入列节点为option",{"2":{"52":1}}],["初始化队列",{"2":{"52":1}}],["初始化列表的容量",{"2":{"50":1}}],["初始化列表通常分为",{"2":{"44":1}}],["初始化列表",{"0":{"44":1}}],["初始化各个节点",{"2":{"33":1}}],["初始化链表",{"0":{"33":1}}],["初始化值",{"2":{"2":1}}],["初始化值和不初始化值",{"2":{"2":1}}],["初始化数组有两种方式",{"2":{"2":1}}],["初始化数组时计算机会在内存中分配一块连续的空间",{"2":{"2":1}}],["初始化数组",{"0":{"2":1}}],["该语句计算并返回值",{"2":{"84":1}}],["该表达式以语句结尾",{"2":{"84":1}}],["该值被称为单元值",{"2":{"77":1}}],["隐式地返回单元类型unit",{"2":{"83":1}}],["之间使用",{"2":{"81":1}}],["之前就停止了",{"2":{"66":1}}],["多个参数之间使用",{"2":{"80":1}}],["多重判断",{"2":{"61":1}}],["参数的数量可以是多个",{"2":{"80":1}}],["参数说明",{"2":{"34":1,"35":1,"36":1,"37":1}}],["信息",{"2":{"79":1}}],["打印",{"2":{"79":1}}],["打印函数的执行时间固定",{"2":{"17":1}}],["首先",{"2":{"79":1}}],["连接",{"2":{"79":1}}],["连续存储",{"2":{"38":1}}],["连续和非连续",{"0":{"26":1}}],["单词之间使用英文下划线",{"2":{"79":1}}],["单向链表",{"2":{"40":1,"41":1}}],["蛇形命名法",{"2":{"79":1}}],["告诉编译器函数从哪里开始和结束",{"2":{"79":1}}],["函数本身也是一种语句",{"2":{"83":1}}],["函数体由一系列语句构成",{"2":{"82":1}}],["函数可以向调用它的表达式返回值",{"2":{"81":1}}],["函数在声明时可以指定参数",{"2":{"80":1}}],["函数并打印它的信息",{"2":{"79":1}}],["函数中的代码会按顺序执行",{"2":{"79":1}}],["函数",{"0":{"79":1}}],["那它就真的不可改变",{"2":{"85":1}}],["那很可能第一部分代码以不可意料的方式运行",{"2":{"85":1}}],["那就应该使用一个",{"2":{"78":1}}],["那么要向队尾插入的的下标应为",{"2":{"53":1}}],["那么就无法在内存中访问到该节点了",{"2":{"35":1}}],["那么可以用数组存储",{"2":{"12":1}}],["称之为向量",{"2":{"78":1}}],["没有值或者只有一个值的元组称为单元类型",{"2":{"77":1}}],["创建string",{"2":{"92":1}}],["创建数组有很多方式",{"2":{"78":1}}],["创建元组",{"2":{"77":1}}],["创建hash",{"2":{"28":1}}],["元组中的元素数量和类型就不能改变",{"2":{"77":1}}],["元组是固定长度的",{"2":{"77":1}}],["元组是rust中一个非常特殊的复合类型",{"2":{"77":1}}],["元组",{"0":{"77":1}}],["元素数量+1",{"2":{"50":1}}],["😻",{"2":{"75":1}}],["ℤ",{"2":{"75":1}}],["字面量采用单引号括起来",{"2":{"75":1}}],["字符串字面量就是被硬编进程序的部分",{"2":{"92":1}}],["字符串字面量是用双引号括起来",{"2":{"75":1}}],["字符大小为4字节",{"2":{"75":1}}],["字符",{"2":{"75":1}}],["字符类型",{"0":{"75":1}}],["字符型",{"2":{"70":1}}],["显式声明",{"2":{"74":1}}],["布尔类型只有两个值",{"2":{"74":1}}],["布尔类型",{"0":{"74":1}}],["布尔型",{"2":{"70":1}}],["示例如下",{"2":{"73":1}}],["示例使用key取模映射index",{"2":{"29":1}}],["除",{"2":{"73":1}}],["除声明值外",{"2":{"31":1}}],["乘",{"2":{"73":1}}],["减",{"2":{"73":1}}],["y=",{"2":{"73":4}}],["y",{"2":{"72":1,"73":8,"77":6,"83":2,"94":2}}],["浮点数与整数运算结果取整数",{"2":{"73":1}}],["浮点类型声明的示例",{"2":{"72":1}}],["浮点型就是含有小数部分的整数",{"2":{"72":1}}],["浮点型",{"0":{"72":1},"2":{"70":1}}],["速度与f32基本相同",{"2":{"72":1}}],["双精度浮点数精度更高",{"2":{"72":1}}],["双向链表的特性使得这种操作变得简单",{"2":{"41":1}}],["双向链表常用于需要快速查找前一个和后一个元素的场景",{"2":{"41":1}}],["双向链表",{"2":{"40":1}}],["区别在于位数不同",{"2":{"72":1}}],["值被清理",{"2":{"89":1}}],["值为",{"2":{"87":1}}],["值得注意的是",{"2":{"86":1}}],["值",{"2":{"71":1}}],["值之间的映射关系实现高效存储和读取数据的一种数据结构",{"2":{"28":1}}],["程序并不会panic",{"2":{"71":1}}],["编译时期就知道它的内容",{"2":{"93":1}}],["编译时期就要准确地知道每个变量地类型",{"2":{"62":1}}],["编译器保证了当声明了一个值不会改变时",{"2":{"85":1}}],["编译器会忽略整型溢出",{"2":{"71":1}}],["编译器会检查整型溢出",{"2":{"71":1}}],["~",{"2":{"71":4}}],["整数和浮点数之间不能进行取模运算",{"2":{"73":1}}],["整数相除向下取整",{"2":{"73":1}}],["整数除法会向下取整",{"2":{"73":1}}],["整型溢出可能导致发生以下两种行为之一",{"2":{"71":1}}],["整型溢出是指给整型变量赋的值超出了变量的取值范围",{"2":{"71":1}}],["整型溢出",{"2":{"71":1}}],["整型还分为有符号和无符号类型",{"2":{"71":1}}],["整型是不包含小数部分的数字",{"2":{"71":1}}],["整型",{"0":{"71":1},"2":{"70":1}}],["整除2时",{"2":{"67":1}}],["复合类型",{"0":{"76":1},"1":{"77":1,"78":1},"2":{"69":1}}],["标明类型",{"2":{"78":1}}],["标量类型标识单个值",{"2":{"70":1}}],["标量类型",{"0":{"70":1},"1":{"71":1,"72":1,"73":1,"74":1,"75":1},"2":{"69":1}}],["标识loop",{"2":{"67":1}}],["标识其在数组中的位置",{"2":{"0":1}}],["变量在离开作用域之前",{"2":{"91":1}}],["变量出现在作用域之后",{"2":{"91":1}}],["变量作用域",{"0":{"90":1},"1":{"91":1,"92":1}}],["变量",{"2":{"89":1}}],["变量与可变性",{"0":{"85":1}}],["变量类型的不确定性也就更高了",{"2":{"69":1}}],["变量的类型是有效的",{"2":{"62":1}}],["基本加减乘除",{"2":{"73":1}}],["基本数据类型",{"0":{"69":1}}],["基于数组实现栈",{"0":{"58":1}}],["基于数组实现队列的入队出队操作",{"2":{"53":1}}],["基于数组可实现",{"2":{"26":1}}],["基于链表实现栈",{"0":{"57":1}}],["基于链表实现队列的入队出队操作",{"2":{"52":1}}],["基于链表可实现",{"2":{"26":1}}],["至此程序结束",{"2":{"67":1}}],["跳出``outer",{"2":{"67":1}}],["差异是",{"2":{"67":1}}],["重复执行步骤一",{"2":{"67":1}}],["进入inner",{"2":{"67":1}}],["进入outer",{"2":{"67":1}}],["进栈和出栈",{"2":{"54":1}}],["回到outer",{"2":{"67":1}}],["满足第一个",{"2":{"67":1}}],["后",{"2":{"67":1}}],["后续再讨论",{"2":{"68":1}}],["后续的分支不会再执行了",{"2":{"61":1}}],["后续会有",{"2":{"44":1}}],["执行流程如下",{"2":{"67":1}}],["执行循环",{"2":{"65":1}}],["z的存储方式会如何改变",{"2":{"94":1}}],["z可为其他不重复名称",{"2":{"77":1}}],["z=",{"2":{"73":1}}],["z被重新声明为10",{"2":{"67":1}}],["z",{"2":{"67":11,"73":6,"75":2,"77":4,"83":1,"84":1,"94":4}}],["与while遍历集合不同的是",{"2":{"66":1}}],["与输入数据n无关",{"2":{"17":1}}],["更简洁的替代方案是for循环",{"2":{"66":1}}],["更新元素",{"2":{"45":1,"50":1}}],["会引起程序panic",{"2":{"78":1}}],["会越界",{"2":{"66":1}}],["会触发panic",{"2":{"62":1}}],["第二步对于有gc的语言",{"2":{"93":1}}],["第二个变量遮蔽了第一个变量",{"2":{"87":1}}],["第一步在创建string时",{"2":{"93":1}}],["第一个分支满足条件了",{"2":{"61":1}}],["第三个",{"2":{"87":1}}],["第5个元素是",{"2":{"66":1}}],["第4个元素是",{"2":{"66":2}}],["第3个元素是",{"2":{"66":2}}],["第2个元素是",{"2":{"66":2}}],["第1个元素是",{"2":{"66":1}}],["第",{"2":{"66":2}}],["条件被满足",{"2":{"67":1}}],["条件",{"2":{"67":1}}],["条件判断为false",{"2":{"65":1}}],["条件为真",{"2":{"65":1}}],["停止循环",{"2":{"65":1}}],["调用break终止循环",{"2":{"65":1}}],["调用",{"2":{"65":1}}],["调度算法",{"2":{"41":1}}],["上述只是单个变量的简单引用场景",{"2":{"93":1}}],["上述操作就可行了",{"2":{"85":1}}],["上述代码中当",{"2":{"67":1}}],["上述代码为双层嵌套的loop循环",{"2":{"67":1}}],["上面的while循环会执行三次",{"2":{"65":1}}],["上面的代码会不断地在控制台打印hello",{"2":{"64":1}}],["上一个节点通过将引用指向下一个节点来访问节点内存地址",{"2":{"31":1}}],["直到我使用",{"2":{"64":1}}],["直至你要求停止",{"2":{"64":1}}],["直接使用x=",{"2":{"87":1}}],["直接使用封装的api操作",{"2":{"48":1}}],["直接创建",{"2":{"78":1}}],["直接访问",{"2":{"6":1}}],["语句同样遮蔽前面的",{"2":{"87":1}}],["语句计算并返回值",{"2":{"84":1}}],["语句不返回值",{"2":{"83":1}}],["语句",{"0":{"83":1},"2":{"82":1}}],["语句和表达式",{"0":{"82":1},"1":{"83":1,"84":1}}],["语句的右侧使用它来将结果赋值给一个变量",{"2":{"62":1}}],["语句中使用",{"0":{"62":1}}],["语法",{"2":{"28":1}}],["有两种方式访问元组中的元素",{"2":{"77":1}}],["有符号类型表示的取值范围是",{"2":{"71":1}}],["有符号类型以i开头即integer",{"2":{"71":1}}],["有符号型",{"2":{"71":1}}],["有关",{"2":{"61":1}}],["有初始值",{"2":{"44":2}}],["只会执行第一个条件为真的代码块",{"2":{"61":1}}],["只需要取消删除节点上一个节点对其的引用",{"2":{"35":1}}],["只需collect到vec中",{"2":{"29":1}}],["类型是该语言最基本的字母类型",{"2":{"75":1}}],["类型的函数等",{"2":{"61":1}}],["类型",{"2":{"61":1}}],["类似于双向链表",{"2":{"41":1}}],["顺序地执行后续的代码",{"2":{"61":1}}],["否则就不执行",{"2":{"61":1}}],["表示为",{"2":{"77":1}}],["表示这个整数只表示正整数",{"2":{"71":1}}],["表示这个整数是否可以取负数",{"2":{"71":1}}],["表示标识算法操作次数的函数的",{"2":{"14":1}}],["表达式可以同样可以作为语句的结束",{"2":{"84":1}}],["表达式可选地组合else",{"2":{"61":1}}],["表达式计算并返回一个值",{"2":{"84":1}}],["表达式的示例",{"2":{"61":1}}],["表达式的判断条件必须为",{"2":{"61":1}}],["表达式的特征",{"0":{"61":1}}],["表达式当条件为true时就执行表达式内的代码",{"2":{"61":1}}],["表达式",{"0":{"60":1,"84":1},"1":{"61":1,"62":1},"2":{"82":1}}],["模式匹配来解构",{"2":{"77":1}}],["模式匹配需要用到枚举相关知识",{"2":{"68":1}}],["模式匹配",{"0":{"68":1},"2":{"59":1}}],["控制流",{"0":{"59":1}}],["控制访问范围",{"2":{"36":1}}],["节点值",{"2":{"57":1}}],["节点间通过引用连接",{"2":{"31":1}}],["入栈",{"2":{"55":1,"57":1}}],["入队",{"2":{"52":1,"53":1}}],["下面来着手实现简单的栈结构",{"2":{"56":1}}],["下面是一些栈的常用操作",{"2":{"55":1}}],["下面实现查找target节点",{"2":{"37":1}}],["下面实现一个时间复杂度为o",{"2":{"3":1,"7":1}}],["忽略其一些属性和方法来达到栈的状态",{"2":{"55":1}}],["忽略t",{"2":{"14":1}}],["出栈",{"2":{"55":1,"57":1}}],["出入栈示意图",{"2":{"55":1}}],["出队",{"2":{"52":1,"53":1}}],["出队的时候",{"2":{"52":1}}],["取之前的值并乘上",{"2":{"87":1}}],["取模操作除外",{"2":{"73":1}}],["取模等",{"2":{"73":1}}],["取球只能从顶部一个一个拿出来",{"2":{"55":1}}],["取得原本链表头节点后面的节点",{"2":{"34":1}}],["认识栈",{"0":{"55":1}}],["容量",{"2":{"94":1}}],["容量已满",{"2":{"50":1}}],["容器式",{"2":{"54":1}}],["越过数组尾部后回到头部",{"2":{"53":1}}],["使实现的栈对外仅保持栈的特性",{"2":{"56":1}}],["使其重新回到数组头部",{"2":{"53":1}}],["使用move之后的string类型数据",{"2":{"94":1}}],["使用",{"2":{"67":1,"71":3,"81":1,"93":1}}],["使用while循环也可以遍历合集的元素",{"2":{"66":1}}],["使用extend方法将两个列表组合成一个列表",{"2":{"49":1}}],["使用insert",{"2":{"47":1}}],["使用next建立引用关系",{"2":{"33":1}}],["使用rust定义的链表结构体",{"2":{"31":1}}],["代码就不会执行了",{"2":{"67":1}}],["代码实现",{"2":{"52":1,"53":1}}],["代表数组的第一个元素下标",{"2":{"53":1}}],["定义一个front",{"2":{"53":1}}],["始终满足size",{"2":{"53":1}}],["换句话说我们不实现数组的所有特性来实现队列",{"2":{"53":1}}],["屏蔽",{"2":{"53":1}}],["就自动触发调用drop函数来释放内存",{"2":{"93":1}}],["就再也不会改变",{"2":{"86":1}}],["就隐式地返回单元值",{"2":{"77":1}}],["就使用continue跳出当前迭代",{"2":{"67":1}}],["就可以在编译时验证在每处使用的",{"2":{"62":1}}],["就让头节点的下一个节点作为新的节点",{"2":{"52":1}}],["就把老节点的指针指向传入的节点",{"2":{"52":1}}],["就能获得目标返回类型vec",{"2":{"29":1}}],["匹配当前队列的尾节点",{"2":{"52":1}}],["q",{"2":{"52":5,"53":12}}],["queue",{"2":{"52":2}}],["which",{"2":{"94":1}}],["while条件循环",{"0":{"65":1}}],["while",{"2":{"18":1,"63":1,"65":1,"66":1,"67":1}}],["wrapping",{"2":{"71":2}}],["world结束程序",{"2":{"65":1}}],["world",{"2":{"64":2,"65":1,"79":2,"83":1,"94":3}}],["warning",{"2":{"92":1}}],["warn",{"2":{"52":1}}],["二次释放",{"2":{"94":1}}],["二者都可以通过链表和数组来实现",{"2":{"51":1}}],["二分查找等都主要在数组上进行",{"2":{"12":1}}],["同样进行上述操作",{"2":{"94":1}}],["同时string是可变的",{"2":{"92":1}}],["同时也代表队列的",{"2":{"53":1}}],["同时队尾又可以不断加入需要结账的人",{"2":{"51":1}}],["同删除操作",{"2":{"28":1}}],["队首指针向后移动1",{"2":{"53":1}}],["队首指针",{"2":{"53":1}}],["队首",{"2":{"53":1}}],["队首完成结账后离开队列",{"2":{"51":1}}],["队列已满",{"2":{"53":1}}],["队列为空",{"2":{"53":1}}],["队列容量",{"2":{"53":1}}],["队列长度减一",{"2":{"52":1}}],["队列长度加一",{"2":{"52":1}}],["队列长度",{"2":{"52":1,"53":1}}],["队列示意图",{"2":{"51":1}}],["队列与栈的差异在于栈遵循",{"2":{"51":1}}],["队列",{"2":{"12":1,"24":1,"25":1,"26":2}}],["即可完成更改",{"2":{"87":1}}],["即全部小写单词",{"2":{"79":1}}],["即使后续分支的条件也满足",{"2":{"61":1}}],["即只有单向出口",{"2":{"51":1}}],["即第二节点",{"2":{"34":1}}],["原则",{"2":{"51":1}}],["先认识一下drop函数",{"2":{"94":1}}],["先进后出",{"2":{"51":1}}],["先根据扩容倍数创建一个更大的数组",{"2":{"50":1}}],["超出索引",{"2":{"50":3}}],["unit",{"2":{"77":2}}],["unwrap",{"2":{"52":2,"55":2,"57":2}}],["u128",{"2":{"71":1}}],["u16",{"2":{"71":1}}],["u64",{"2":{"71":1}}],["u32",{"2":{"71":1}}],["u8的取值范围则是",{"2":{"71":1}}],["u8",{"2":{"71":1,"77":3}}],["update",{"2":{"50":1}}],["use",{"2":{"29":1,"31":1,"52":1,"57":2}}],["usize>",{"2":{"7":1}}],["usize",{"2":{"4":1,"5":1,"8":1,"29":2,"50":10,"52":1,"53":3,"57":3,"71":2}}],["构造函数",{"2":{"50":1}}],["构成的输入空间映射到数组所有索引构成的输出空间",{"2":{"30":1}}],["若插入元素时列表容量已满",{"2":{"50":1}}],["扩容列表",{"2":{"50":1}}],["扩容",{"2":{"50":1}}],["扩容机制",{"2":{"50":1}}],["扩容数组需要重新分配一块更大的内存空间",{"2":{"8":1}}],["扩容数组",{"0":{"8":1}}],["相同",{"2":{"94":1}}],["相较于mut声明的变量x",{"2":{"87":1}}],["相较于let声明可以使用函数调用结果",{"2":{"86":1}}],["相较于变量而言",{"2":{"86":1}}],["相应修改该标记",{"2":{"50":1}}],["相关代码如下",{"2":{"20":1}}],["虽然在多数情况下编译器能够推测出你想要使用的类型",{"2":{"69":1}}],["虽然许多的高级语言都已经封装了列表的实现以及一系列的方法",{"2":{"50":1}}],["虽然打印程序需要循环1000次",{"2":{"17":1}}],["拼接在尾部",{"2":{"49":1}}],["注意",{"2":{"49":1}}],["组合列表",{"0":{"49":1}}],["排序列表",{"0":{"48":1}}],["排序和搜索",{"2":{"12":1}}],["清空列表",{"2":{"47":1}}],["9",{"2":{"47":1,"67":5}}],["跟数组一样",{"2":{"46":1}}],["动态数组在完美继承数组的所有特点的同时",{"2":{"42":1}}],["动态数组dynamic",{"2":{"42":1}}],["动态参数",{"2":{"36":1,"37":1}}],["长度永远都是小于等于容量的",{"2":{"94":1}}],["长度",{"2":{"71":1,"94":1}}],["长度和扩容问题显然使得实现后得列表具有较大缺陷",{"2":{"42":1}}],["长度不可表",{"2":{"38":1}}],["长度不可变",{"2":{"11":1}}],["倘若使用数组来实现列表",{"2":{"42":1}}],["而rust是无gc的",{"2":{"93":1}}],["而string可变呢",{"2":{"92":1}}],["而string类型则可变",{"2":{"92":1}}],["而shadow需要使用let再次声明才能更改x的值",{"2":{"87":1}}],["而使用shadow通过",{"2":{"87":1}}],["而不能是函数调用的结果或是只能在运行时计算得到的值",{"2":{"86":1}}],["而不是借助索引",{"2":{"66":1}}],["而代码的另一部分更改了该值",{"2":{"85":1}}],["而声明可变时",{"2":{"85":1}}],["而采取一种二进制补码的方式将该数值转换为该类型取值范围内的最小值",{"2":{"71":1}}],["而数组或者链表可以在任何位置添加和删除数据",{"2":{"56":1}}],["而数组可以看作一个长度固定的列表",{"2":{"42":1}}],["而队列更像生活中的排队结账",{"2":{"51":1}}],["而链表则是分散的",{"2":{"26":1}}],["灵活程度远高于链表和数组",{"2":{"42":1}}],["列表长度",{"2":{"50":1}}],["列表的实现原理",{"0":{"50":1}}],["列表的常用操作",{"0":{"43":1},"1":{"44":1,"45":1,"46":1,"47":1,"48":1,"49":1}}],["列表是一种抽象的数据结构概念",{"2":{"42":1}}],["列表",{"0":{"42":1}}],["视频播放器中",{"2":{"41":1}}],["也不会再执行其它代码块了",{"2":{"61":1}}],["也可能会使用环形链表",{"2":{"41":1}}],["也就意味着分配的内存空间大是固定的",{"2":{"8":1}}],["它可能会导致潜在的安全漏洞",{"2":{"94":1}}],["它允许将多个相同类型的值组合在一起",{"2":{"78":1}}],["它允许将多个不同类型的值组合在一起",{"2":{"77":1}}],["它需要对一组进程进行循环",{"2":{"41":1}}],["它表现的特性为先进先出",{"2":{"41":1}}],["它表现的特性为先进后出",{"2":{"41":1}}],["浏览器需要知道用户访问过的前一个和后一个网页",{"2":{"41":1}}],["浏览器历史",{"2":{"41":1}}],["比如一筒羽毛球",{"2":{"55":1}}],["比如在音频",{"2":{"41":1}}],["比如在红黑树",{"2":{"41":1}}],["比如操作系统的资源调度",{"2":{"41":1}}],["比如以上代码中的链表可记作链表",{"2":{"33":1}}],["高级数据结构",{"2":{"41":1}}],["其在内存上的表达",{"2":{"92":1}}],["其他位置插入的时间复杂度为o",{"2":{"47":1}}],["其中图的每个顶点都与一个链表相关联",{"2":{"41":1}}],["其长度就固定了",{"2":{"0":1}}],["邻接表是表示图的一种常用方式",{"2":{"41":1}}],["链式地址是解决哈希冲突的主流方案之一",{"2":{"41":1}}],["链表节点类",{"2":{"57":1}}],["链表节点由值和指针两部分组成",{"2":{"31":1}}],["链表实现队列",{"0":{"52":1}}],["链表本身就一个列表",{"2":{"42":1}}],["链表中的每个元素都代表与该顶点相连的其他顶点",{"2":{"41":1}}],["链表中插入节点",{"2":{"34":1}}],["链表vs数组",{"0":{"38":1}}],["链表访问元素则相对复杂",{"2":{"36":1}}],["链表的类型及应用",{"0":{"39":1},"1":{"40":1,"41":1}}],["链表的头节点",{"2":{"34":1}}],["链表的每个节点对象由引用",{"2":{"31":1}}],["链表相关操作",{"0":{"32":1},"1":{"33":1,"34":1,"35":1,"36":1,"37":1}}],["链表结构体",{"2":{"31":1,"52":1,"57":1}}],["链表结构体说明",{"2":{"31":1}}],["链表示意图",{"2":{"31":1}}],["链表需要的空间比数组更多",{"2":{"31":1}}],["链表是一种线性数据结构",{"2":{"31":1}}],["链表简介",{"0":{"31":1}}],["链表",{"2":{"24":1,"25":1}}],["各类链表的应用",{"0":{"41":1}}],["头节点",{"2":{"52":1}}],["头节点和尾节点相连接形成闭环的链表",{"2":{"40":1}}],["头既是尾",{"2":{"40":1}}],["头尾的概念也就消失了",{"2":{"40":1}}],["环形链表常用于需要周期性操作的场景",{"2":{"41":1}}],["环形链表",{"2":{"40":1}}],["尾插法添加新元素的时候需要遍历链表至尾节点来实现",{"2":{"57":1}}],["尾既是头",{"2":{"40":1}}],["尾节点都指向该节点",{"2":{"52":1}}],["尾节点",{"2":{"52":1}}],["尾节点指向空none",{"2":{"40":1}}],["尾节点结束",{"2":{"40":1}}],["尾部即可",{"2":{"28":1}}],["由此衍生了一种更灵活的字符串类型",{"2":{"92":1}}],["由头节点开始",{"2":{"40":1}}],["由于z只是s的指针copy",{"2":{"94":1}}],["由于列表继承数组特性",{"2":{"45":1}}],["由于其动态扩容性",{"2":{"42":1}}],["由于数组在创建时的长度固定",{"2":{"8":1}}],["由于",{"2":{"2":1}}],["最大限度地减少堆数据的重复",{"2":{"88":1}}],["最后一个不同点是常量只能设置为常量表达式",{"2":{"86":1}}],["最终进入inner",{"2":{"67":1}}],["最普遍的链表类型",{"2":{"40":1}}],["最高阶对时间增长的趋势的影响是其他项所不能相比的",{"2":{"15":1}}],["占用空间大",{"2":{"38":1}}],["占用空间小",{"2":{"38":1}}],["但实际rust为了避免二次释放的问题",{"2":{"94":1}}],["但事实并非如此",{"2":{"94":1}}],["但对于在编译期不确定内容的文本",{"2":{"93":1}}],["但并不是所有场景都适合",{"2":{"92":1}}],["但函数可以通过返回值赋值给变量",{"2":{"83":1}}],["但大部分函数隐式的返回最后的表达式所计算的值",{"2":{"81":1}}],["但当你明确元素数量不需要改变时",{"2":{"78":1}}],["但将会得到非期望的值",{"2":{"71":1}}],["但随着程序的庞大和复杂",{"2":{"69":1}}],["但只有单向出口",{"2":{"54":1}}],["但是为了更好的理解深层原理",{"2":{"50":1}}],["但分配较大时会造成浪费",{"2":{"38":1}}],["但打印函数的执行时间固定",{"2":{"17":1}}],["分隔",{"2":{"80":1}}],["分别对应f32和f64",{"2":{"72":1}}],["分别对应头插法和尾插法",{"2":{"57":1}}],["分散存储",{"2":{"38":1}}],["分裂n轮后有",{"2":{"22":1}}],["分裂两轮后变为4个",{"2":{"22":1}}],["分裂一轮后变为2个",{"2":{"22":1}}],["`copy`",{"2":{"94":1}}],["`string`",{"2":{"94":1}}],["`s`",{"2":{"94":2}}],["`usize`",{"2":{"87":1}}],["`",{"2":{"38":2,"62":1,"73":2,"83":2,"87":1}}],["具体原因为",{"2":{"85":1}}],["具体因为这样可以告诉编译器你的意图而不需编译器在其他代码部分使用到参数时不明确",{"2":{"80":1}}],["具体如下图所示",{"2":{"38":1}}],["具有返回值的函数",{"0":{"81":1}}],["具有参数的函数",{"0":{"80":1}}],["具有显示声明的bool类型",{"2":{"74":1}}],["具有线性关系还是非线性关系",{"2":{"25":1}}],["效率",{"2":{"38":1}}],["效率较低",{"2":{"11":1}}],["目标链表元素",{"2":{"37":1}}],["返回值的类型需要在声明函数时就进行标志",{"2":{"81":1}}],["返回不同的类型时",{"2":{"62":1}}],["返回",{"2":{"61":1}}],["返回被删除的元素",{"2":{"50":1}}],["返回此时的索引",{"2":{"37":1}}],["返回其索引的方法",{"2":{"37":1}}],["返回空\\t\\t\\t\\t\\t\\t\\t\\t\\t",{"2":{"35":1}}],["索引访问数组的元素",{"2":{"78":1}}],["索引越界",{"2":{"50":1}}],["索引",{"2":{"36":1,"37":1,"77":1}}],["索引从0开始",{"2":{"3":1,"78":1}}],["起始为头节点",{"2":{"36":1,"37":1}}],["起始节点称为头节点",{"2":{"31":1}}],["遍历列表元素",{"0":{"46":1}}],["遍历每个节点",{"2":{"36":1}}],["遍历数组可以使用索引index来获取元素本身",{"2":{"6":1}}],["遍历数组",{"0":{"6":1}}],["访问数组的元素",{"2":{"78":1}}],["访问数组元素",{"0":{"3":1}}],["访问",{"2":{"77":1}}],["访问元组",{"2":{"77":1}}],["访问元素",{"2":{"45":1}}],["访问索引",{"2":{"45":1}}],["访问列表元素",{"0":{"45":1},"2":{"50":1}}],["访问链表中的元素需要从头节点出发",{"2":{"36":1}}],["访问节点",{"0":{"36":1}}],["获取栈长度",{"2":{"55":1,"57":1}}],["获取栈顶元素",{"2":{"55":1,"57":1}}],["获取队首元素",{"2":{"53":1}}],["获取队列的长度",{"2":{"53":1}}],["获取队列的容量",{"2":{"53":1}}],["获取队列长度",{"2":{"52":1}}],["获取头节点的下一个节点",{"2":{"52":1}}],["获取头节点",{"2":{"52":1}}],["获取列表长度",{"2":{"50":1}}],["获取列表容量",{"2":{"50":1}}],["获取对应key的value",{"2":{"28":1}}],["获得要删除节点后面的节点",{"2":{"35":1}}],["获得要删除的节点",{"2":{"35":1}}],["我们直接调用即可",{"2":{"44":1}}],["我们需要快速找到最近最少使用的数据",{"2":{"41":1}}],["我们需要访问节点的父节点",{"2":{"41":1}}],["我们就认为这个节点从链表中删除了",{"2":{"35":1}}],["我们通常将头节点当作链表的代称",{"2":{"33":1}}],["需插入节点",{"2":{"34":1}}],["需要在堆上分配一块在编译时未知大小的内存来存放内容",{"2":{"93":1}}],["需要了解内存管理",{"2":{"92":1}}],["需要存储指针引用",{"2":{"38":1}}],["需要执行n",{"2":{"36":1}}],["需要将插入位置前一个节点的引用指向该节点",{"2":{"34":1}}],["需要注意的是",{"2":{"26":1,"61":1}}],["需要先计算出算法的操作数函数t",{"2":{"14":1}}],["需要遍历数组或者链表找到要删除目标的index",{"2":{"28":1}}],["需要遍历数组",{"2":{"7":1}}],["需要把插入位置后面的元素全部向后移一位",{"2":{"4":1}}],["建立节点间的引用关系",{"2":{"33":1}}],["\\tconst",{"2":{"86":2}}],["\\tcount",{"2":{"46":1}}],["\\tlet",{"2":{"55":3,"65":1,"86":1}}],["\\tstack",{"2":{"55":5}}],["\\tstruct",{"2":{"31":1}}],["\\timpl",{"2":{"50":1}}],["\\tvec2",{"2":{"47":4,"49":1}}],["\\tfor",{"2":{"46":2}}],["\\tfn",{"2":{"34":1,"35":1,"36":1,"37":1,"86":1}}],["\\t删除元素",{"2":{"38":1}}],["\\t添加元素",{"2":{"38":1}}],["\\t访问元素",{"2":{"38":1}}],["\\t内存效率",{"2":{"38":1}}],["\\t扩容",{"2":{"38":1}}],["\\t存储方式",{"2":{"38":1}}],["\\t\\tprintln",{"2":{"64":1}}],["\\t\\t\\t",{"2":{"50":1}}],["\\t\\t\\tlet",{"2":{"50":3}}],["\\t\\tif",{"2":{"50":1}}],["\\t\\t数组",{"2":{"38":1}}],["\\t\\t链表",{"2":{"38":1}}],["\\t\\t",{"2":{"34":1,"35":1,"87":1}}],["\\t\\tlet",{"2":{"33":1,"85":2}}],["\\t",{"2":{"31":2,"33":1,"34":3,"35":4,"36":3,"37":4,"38":3,"44":1,"46":2,"47":3,"50":3,"55":6,"61":1,"64":1,"85":2,"86":3,"87":1}}],["还允许在程序运行时进行动态扩容",{"2":{"42":1}}],["还要声明一个引用计数器",{"2":{"31":1}}],["还会缓存其周围的其他数据",{"2":{"10":1}}],["结束节点称为尾节点",{"2":{"31":1}}],["和数组",{"2":{"76":1}}],["和大多数语言一样",{"2":{"74":1}}],["和",{"2":{"37":1,"44":1,"56":1,"71":1,"81":1}}],["和值组成",{"2":{"31":1}}],["和o",{"2":{"20":1}}],["空间上对比二者的存储方式",{"2":{"38":1}}],["空间效率高",{"2":{"10":1}}],["空闲的内存空间并非都是连续的",{"2":{"31":1}}],["然而当需要的空间比较大时",{"2":{"31":1}}],["然后声明变量y的值等于x即同样是5",{"2":{"94":1}}],["然后通过重复使用",{"2":{"87":1}}],["然后赋值给x",{"2":{"84":1}}],["然后调用",{"2":{"79":1}}],["然后进入outer",{"2":{"67":1}}],["然后打印hello",{"2":{"65":1}}],["然后再回到开头重新执行",{"2":{"63":1}}],["然后将该节点的引用指向插入位置的下一个节点",{"2":{"34":1}}],["然后把原数组中的元素复制到新空间中",{"2":{"8":1}}],["然后根据数组元素的类型和数量来确定数组的大小",{"2":{"2":1}}],["理论上存在多个输入对应一个输出的情况",{"2":{"30":1}}],["理想状态下哈希表中进行增删查改的时间复杂度都是o",{"2":{"28":1}}],["哈希函数的本质就是把所有",{"2":{"30":1}}],["哈希冲突",{"0":{"30":1}}],["哈希表中多个输入对应同一输出的情况称为哈希冲突",{"2":{"30":1}}],["哈希表相当高效",{"2":{"28":1}}],["哈希表又称散列表",{"2":{"28":1}}],["哈希表",{"2":{"12":1,"24":1,"25":3,"26":2,"41":1}}],["测试四个方法",{"2":{"29":1}}],["发现x即为",{"2":{"29":1}}],["|",{"2":{"94":7}}],["|old",{"2":{"57":1}}],["|cur",{"2":{"52":1}}],["|x|",{"2":{"29":3}}],["|pair|",{"2":{"29":4}}],["keys",{"2":{"29":1}}],["key",{"2":{"29":13,"30":1}}],["keytype",{"2":{"28":1}}],["pointer",{"2":{"88":1}}],["pop",{"2":{"52":1,"53":1,"55":1,"57":1}}],["plus3",{"2":{"83":2}}],["plus2",{"2":{"83":2,"84":1}}],["plus1",{"2":{"83":2}}],["plus",{"2":{"80":2,"81":2,"84":1,"86":3}}],["peek|",{"2":{"52":1}}],["peek",{"2":{"52":9,"53":4,"57":9}}],["preek",{"2":{"52":2}}],["prev",{"2":{"35":5}}],["println",{"2":{"6":2,"14":2,"17":2,"50":4,"53":2,"61":6,"62":2,"65":2,"66":2,"67":4,"73":9,"77":2,"78":4,"79":2,"80":1,"81":1,"83":1,"85":4,"87":2,"94":3}}],["push",{"2":{"47":2,"52":1,"53":1,"55":4,"57":1}}],["put",{"2":{"29":3}}],["pub",{"2":{"29":9,"50":9,"52":9,"53":8,"57":6,"61":1}}],["panic",{"2":{"50":1,"66":1,"78":1,"83":1,"86":1}}],["pair类型",{"2":{"29":1}}],["pair>",{"2":{"29":2}}],["pair>>",{"2":{"29":1}}],["pair",{"2":{"29":8}}],["partialeq>",{"2":{"37":1}}],["partialeq",{"2":{"29":1}}],["实际上",{"2":{"55":1}}],["实际应用中存在更复杂的映射",{"2":{"29":1}}],["实现简单结构的队列",{"0":{"51":1}}],["实现哈希表数据结构",{"0":{"29":1}}],["实时标识列表内的元素的数量",{"2":{"50":1}}],["核心就是编写hash函数来实现由key",{"2":{"29":1}}],["每一个对象节点都存储两个方向的指针",{"2":{"40":1}}],["每一层循环依然可以分别套用第",{"2":{"14":1}}],["每个放进的球只能在顶部",{"2":{"55":1}}],["每个进程被赋予一个时间片",{"2":{"41":1}}],["每个节点散落分布在内存空间中",{"2":{"31":1}}],["每个桶里包含hash每个子项的键值对",{"2":{"29":1}}],["这回产生一个叫做",{"2":{"94":1}}],["这就需要一个方法",{"2":{"93":1}}],["这就是哈希冲突",{"2":{"30":1}}],["这意味着",{"2":{"93":1}}],["这意味着在编译期就需要知道所有值的类型",{"2":{"69":1}}],["这取决于两种类型在内存的处理上存在差异",{"2":{"92":1}}],["这些代码一般被称为",{"2":{"91":1}}],["这些数据都是以数组的形式构建的",{"2":{"12":1}}],["这对于代码中很多部分都需要知道一个值的情况特别有用",{"2":{"86":1}}],["这可以使得代码更容易理解",{"2":{"85":1}}],["这可以通过在节点中保存一个指向父节点的引用来实现",{"2":{"41":1}}],["这个方法就是drop",{"2":{"93":1}}],["这个程序首先将数值",{"2":{"87":1}}],["这个概念",{"2":{"86":1}}],["这个",{"2":{"85":1}}],["这个名字就叫做",{"2":{"67":1}}],["这点很重要",{"2":{"85":1}}],["这一特征让你充分利用",{"2":{"85":1}}],["这很好地避免了集合的边界问题",{"2":{"66":1}}],["这使程序更慢",{"2":{"66":1}}],["这时两个drop都会尝试释放堆上的数据",{"2":{"94":1}}],["这时对s进行move操作",{"2":{"94":1}}],["这时第二个",{"2":{"67":1}}],["这时x变为2",{"2":{"67":1}}],["这时x变成0",{"2":{"65":1}}],["这时候使用双向链表就非常合适",{"2":{"41":1}}],["这种循环操作可以通过环形链表来实现",{"2":{"41":1}}],["这里主要介绍两大类数据类型",{"2":{"69":1}}],["这里使用头插法来不断替换链表的头节点实现栈",{"2":{"57":1}}],["这里通过取余计算",{"2":{"53":1}}],["这里通过固定的倍率来创建更大的新数组",{"2":{"50":1}}],["这里着手实现一个简易列表",{"2":{"50":1}}],["这里是访问所有的元素",{"2":{"36":1}}],["这里用数组的每一个连续空间存储",{"2":{"29":1}}],["桶",{"2":{"29":2}}],["存在更加复杂的数据交互",{"2":{"93":1}}],["存在一个哈希函数处理输入的key来获取对应",{"2":{"29":1}}],["存储在堆上的是内容数据",{"2":{"94":1}}],["存储在栈上的数据由一个指向堆的指针",{"2":{"94":1}}],["存储队列元素的数组",{"2":{"53":1}}],["存储空间更多但也更为灵活",{"2":{"40":1}}],["存储数组的空间是连续的",{"2":{"31":1}}],["存储链表的指针和数据通常是分开的",{"2":{"26":1}}],["存储结构并且封装相应操作方法的数据集合",{"2":{"24":1}}],["存储的数据类型相同",{"2":{"0":1}}],["本质上就是对二者一些",{"2":{"56":1}}],["本质上就是",{"2":{"53":1}}],["本质",{"2":{"29":1}}],["添加元素",{"2":{"28":1}}],["variants",{"2":{"86":1}}],["variable",{"2":{"85":1,"92":1}}],["vaue",{"2":{"47":1}}],["value",{"2":{"31":1,"33":3,"50":6,"52":3,"77":1,"80":1,"81":1,"87":2,"94":3}}],["valuetype>",{"2":{"28":1}}],["vals",{"2":{"29":1}}],["val",{"2":{"29":8,"37":1,"57":2}}],["vec3",{"2":{"49":2}}],["vec2",{"2":{"44":1,"45":1,"46":3}}],["vec1",{"2":{"44":1}}],["vec",{"2":{"8":1,"29":6,"44":4,"49":1,"50":16,"53":2,"55":1}}],["vector",{"2":{"2":2,"78":3}}],["moved",{"2":{"94":2}}],["move",{"0":{"94":1},"2":{"94":2}}],["mod",{"2":{"29":1}}],["memory",{"2":{"88":1}}],["methods",{"2":{"29":1}}],["mian",{"2":{"65":1,"83":1,"84":1}}],["mylist",{"2":{"50":2}}],["match",{"2":{"52":2,"57":1,"59":1,"61":1}}],["map",{"2":{"28":7,"29":7,"52":1,"57":1}}],["main",{"2":{"28":1,"29":1,"44":1,"61":1,"62":1,"64":1,"66":2,"67":2,"72":1,"73":1,"75":1,"79":2,"80":1,"81":1,"85":2,"87":2,"93":1,"94":2}}],["mutable",{"2":{"92":1}}],["mut变量直接再赋值时不允许改变变量的类型",{"2":{"87":1}}],["mut",{"2":{"4":1,"5":1,"8":2,"14":1,"18":2,"19":1,"20":1,"21":1,"22":2,"23":1,"28":2,"29":3,"33":2,"34":3,"35":3,"36":1,"37":1,"46":1,"50":2,"52":4,"53":2,"55":1,"57":2,"65":1,"66":1,"67":3,"85":1,"87":3}}],["has",{"2":{"94":1}}],["hash",{"2":{"29":16,"30":1}}],["hashmap",{"2":{"28":5}}],["here",{"2":{"94":2}}],["heart",{"2":{"75":1}}],["head|",{"2":{"57":1}}],["head",{"2":{"34":4,"36":5,"37":4,"57":4}}],["hello算法",{"2":{"51":1,"52":1,"53":1}}],["hello",{"2":{"25":1,"26":1,"64":1,"65":1,"79":2,"83":1,"92":1,"93":1,"94":3}}],["删除头节点",{"2":{"52":1}}],["删除位置后的元素向前移一位",{"2":{"50":1}}],["删除指定索引处的元素",{"2":{"47":1}}],["删除操作在链表的另一端进行",{"2":{"41":1}}],["删除链表节点相较于插入操作更简单",{"2":{"35":1}}],["删除节点的前一节点",{"2":{"35":1}}],["删除节点",{"0":{"35":1}}],["删除",{"2":{"28":1}}],["删除元素需要将删除位置后面的元素都往前移动一位",{"2":{"5":1}}],["删除元素",{"0":{"5":1},"2":{"47":1,"50":1}}],["要想进一步探讨这个问题",{"2":{"92":1}}],["要想真正地理解数据",{"2":{"27":1}}],["要改为存储在堆上",{"2":{"88":1}}],["要显式处理溢出的可能性",{"2":{"71":1}}],["要考虑末端元素将失效",{"2":{"4":1}}],["小结",{"0":{"27":1}}],["等",{"2":{"26":1}}],["维度",{"2":{"26":1}}],["张量",{"2":{"26":1}}],["张量之间的线性代数运算",{"2":{"12":1}}],["所发生的事情便不完全相同了",{"2":{"94":1}}],["所有者",{"2":{"89":2}}],["所有权的规则",{"0":{"89":1}}],["所有权的目标",{"0":{"88":1}}],["所有权系统是管理处于堆内存上的数据",{"2":{"88":1}}],["所有冲突的元素都会被放到一个链表中",{"2":{"41":1}}],["所有的数据结构都可以基于数组或者链表",{"2":{"26":1}}],["所以x和y的大小都是已知的",{"2":{"94":1}}],["所以",{"2":{"87":1}}],["所以不必亲自跟踪这个值",{"2":{"85":1}}],["所以输出2",{"2":{"73":1}}],["所以可以在",{"2":{"62":1}}],["所以只会输出",{"2":{"61":1}}],["所以时间复杂度为o",{"2":{"36":1}}],["所以对时间复杂度不产生影响",{"2":{"14":1}}],["物理结构是指数据在内存中的存储方式是连续的还是非连续的",{"2":{"26":1}}],["物理结构",{"0":{"26":1}}],["非网状结构",{"2":{"25":1}}],["非线性数据结构又可以分为",{"2":{"25":1}}],["非线性数据结构",{"2":{"25":1}}],["网状结构",{"2":{"25":1}}],["网状结构和非网状结构",{"2":{"25":1}}],["逻辑结构主要是描述数据之间的逻辑关系",{"2":{"25":1}}],["逻辑结构",{"0":{"25":1}}],["逻辑结构和物理结构",{"2":{"24":1}}],["​理解数据机构可以从两个层面理解",{"2":{"24":1}}],["树中",{"2":{"41":1}}],["树",{"2":{"24":1,"25":2,"26":2}}],["栈只能在栈顶添加和删除元素",{"2":{"56":1}}],["栈的实现",{"0":{"56":1},"1":{"57":1,"58":1}}],["栈顶被清空",{"2":{"57":1}}],["栈顶",{"2":{"54":1}}],["栈与队列",{"2":{"41":1}}],["栈",{"0":{"54":1},"2":{"24":1,"25":1,"26":2,"54":1,"55":1}}],["个值",{"2":{"66":1}}],["个元素是",{"2":{"66":2}}],["个",{"2":{"23":1}}],["个分裂出",{"2":{"23":1}}],["从此处起",{"2":{"93":1}}],["从0开始",{"2":{"77":1}}],["从栈顶取出元素的操作",{"2":{"55":1}}],["从当前队列头节点开始遍历",{"2":{"52":1}}],["从头节点向后依次访问",{"2":{"37":1}}],["从头节点出发",{"2":{"36":1}}],["从hashmap中移除指定键的键值对",{"2":{"28":1}}],["从",{"2":{"23":1}}],["从而借助高速缓存来提升后续操作的执行速度",{"2":{"10":1}}],["递归实现",{"2":{"23":1}}],["∗1rust",{"2":{"23":1}}],["∗",{"2":{"23":2}}],["方向单一",{"2":{"40":1}}],["方案数量为",{"2":{"23":1}}],["方法使值达到最小值或最大值",{"2":{"71":1}}],["方法返回该值和一个指示是否存在溢出的布尔值",{"2":{"71":1}}],["方法时发生溢出",{"2":{"71":1}}],["方法在所有模式下进行包裹",{"2":{"71":1}}],["方法",{"2":{"2":1,"56":1}}],["求其所有可能的排列方案",{"2":{"23":1}}],["给定",{"2":{"23":1}}],["问题",{"2":{"23":1}}],["全排列",{"2":{"23":1}}],["阶乘阶",{"2":{"23":1}}],["阶乘阶对应数学上的",{"2":{"23":1}}],["阶乘",{"0":{"23":1}}],["8位",{"2":{"71":1}}],["8",{"2":{"22":2,"29":1,"49":1}}],["形成数列",{"2":{"22":1}}],["细胞每轮一分为二",{"2":{"22":1}}],["细胞分裂",{"2":{"22":1}}],["because",{"2":{"94":1}}],["be",{"2":{"92":1}}],["bug",{"2":{"85":2}}],["buckets",{"2":{"29":12}}],["byte",{"2":{"75":1}}],["break关键字",{"2":{"67":1}}],["break",{"0":{"67":1},"2":{"65":1,"67":3}}],["brr",{"2":{"2":1}}],["bob",{"2":{"78":2}}],["bool",{"2":{"53":1,"57":1,"61":3,"62":1,"74":1,"92":1}}],["borrowed",{"2":{"94":1}}],["borrow",{"2":{"33":2,"34":3,"35":4,"36":1,"37":2,"52":2,"57":2,"94":1}}],["b",{"2":{"41":1}}],["base",{"2":{"22":3}}],["生物学的",{"2":{"22":1}}],["指向下一节点的指针",{"2":{"57":1}}],["指向队尾索引",{"2":{"53":1}}],["指定值",{"2":{"81":1}}],["指定位置插入",{"2":{"47":1}}],["指定长度时",{"2":{"2":1}}],["指针",{"2":{"31":1}}],["指数阶",{"0":{"22":1},"2":{"22":1}}],["外层循环和内层循环的时间复杂度都为o",{"2":{"21":1}}],["平方阶通常出现在嵌套循环中",{"2":{"21":1}}],["平方阶的操作数量相对于输入数据大小n以平方级别增长",{"2":{"21":1}}],["平方阶",{"0":{"21":1}}],["线性数据结构",{"2":{"25":1}}],["线性和非线性",{"0":{"25":1}}],["线性对数阶常出现于嵌套循环中",{"2":{"20":1}}],["线性对数阶",{"0":{"20":1},"2":{"20":1}}],["线性阶o",{"0":{"19":1}}],["calls",{"2":{"86":1}}],["cannot",{"2":{"85":1}}],["carol",{"2":{"78":2}}],["cat",{"2":{"75":1}}],["capacity",{"2":{"50":14,"53":12}}],["char等",{"2":{"92":1}}],["char",{"2":{"75":2}}],["checked",{"2":{"71":1}}],["c来终止程序",{"2":{"64":1}}],["ctrl",{"2":{"64":1}}],["cur",{"2":{"52":2}}],["c",{"2":{"50":2,"75":1}}],["clear",{"2":{"47":1}}],["clone",{"2":{"29":1,"33":2,"36":1,"37":1,"52":3}}],["cpu",{"2":{"41":2}}],["cell",{"2":{"31":1,"52":1,"57":1}}],["cfg",{"2":{"29":1}}],["const声明只能使用常量表达式",{"2":{"86":1}}],["constants",{"2":{"86":1}}],["constant",{"2":{"86":2}}],["continue关键字",{"2":{"67":1}}],["continue",{"0":{"67":1},"2":{"67":2}}],["condition",{"2":{"62":3}}],["code",{"2":{"52":1,"85":1}}],["collision",{"2":{"30":1}}],["collect",{"2":{"29":3}}],["collections",{"2":{"28":1}}],["counting",{"2":{"31":1}}],["count",{"2":{"18":3,"19":2,"20":3,"21":2,"22":4,"23":3,"46":3,"67":11}}],["crr",{"2":{"2":1}}],["对于string类型的move",{"2":{"94":1}}],["对于第二步let",{"2":{"94":1}}],["对于运行时不确定其大小的数据",{"2":{"94":1}}],["对于已知固定大小的数据",{"2":{"94":1}}],["对于多个变量的复杂场景",{"2":{"93":1}}],["对于可变的string类型",{"2":{"93":1}}],["对于字面量值",{"2":{"93":1}}],["对于在rust中的任何值",{"2":{"89":1}}],["对应入栈",{"2":{"55":1}}],["对应出栈",{"2":{"55":1}}],["对应队列",{"2":{"41":1}}],["对应栈",{"2":{"41":1}}],["对应的元素存放在数组中的对应位置",{"2":{"12":1}}],["对比链表和数组从空间和时间上出发",{"2":{"38":1}}],["对数据结构的种类",{"2":{"27":1}}],["对数阶",{"2":{"18":1}}],["对数阶o",{"0":{"18":1}}],["算法中",{"2":{"41":1}}],["算法",{"2":{"25":1,"26":1,"41":1}}],["算法属于线性阶",{"2":{"19":1}}],["算法属于对数阶",{"2":{"18":1}}],["算法属于常数阶",{"2":{"17":1}}],["算法函数的时间增长趋势",{"2":{"13":1}}],["常量声明必须标注类型",{"2":{"86":1}}],["常量可以在任意作用域内声明",{"2":{"86":1}}],["常量用const声明",{"2":{"86":1}}],["常量一旦声明",{"2":{"86":1}}],["常量不存在",{"2":{"86":1}}],["常量",{"0":{"86":1}}],["常见的复合类型有元组",{"2":{"76":1}}],["常见的链表类型",{"0":{"40":1}}],["常见的数据类型有",{"2":{"24":1}}],["常见操作",{"2":{"28":1}}],["常见时间复杂度类型图",{"2":{"16":1}}],["常见时间复杂度类型",{"0":{"16":1},"1":{"17":1,"18":1,"19":1,"20":1,"21":1,"22":1,"23":1}}],["常数阶o",{"0":{"17":1}}],["趋势",{"2":{"16":1}}],["gc会自动记录和标记数据的状态",{"2":{"93":1}}],["gt",{"2":{"15":1,"29":1,"81":1}}],["gen",{"2":{"3":1}}],["get",{"2":{"3":1,"28":1,"29":3,"50":3}}],["操作数",{"2":{"15":1}}],["应选择合适的容量",{"2":{"50":1}}],["应该搞清楚以下概念",{"2":{"50":1}}],["应该深度的学习每一种数据结构类型",{"2":{"27":1}}],["应为当n趋于无穷大是",{"2":{"15":1}}],["应用",{"0":{"12":1}}],["判断条件必须为bool类型",{"2":{"61":1}}],["判断栈是否空",{"2":{"57":1}}],["判断栈是否为空",{"2":{"55":1}}],["判断队列长度是否为0",{"2":{"53":1}}],["判断队列是否为空",{"2":{"52":1}}],["判断渐进上界",{"0":{"15":1}}],["判断操作数函数的渐进上界",{"2":{"13":1}}],["j",{"2":{"14":1,"21":1}}],["技巧",{"2":{"14":4}}],["点的技巧",{"2":{"14":1}}],["点和第",{"2":{"14":1}}],["总操作数量等于外层循环和内层循环操作数量之积",{"2":{"14":1}}],["循环标签",{"0":{"67":1},"2":{"67":1}}],["循环遍历集合",{"0":{"66":1}}],["循环是指遍历执行循环体中的代码直至结尾",{"2":{"63":1}}],["循环",{"0":{"63":1},"1":{"64":1,"65":1,"66":1,"67":1},"2":{"59":1}}],["循环到栈尾实现出栈",{"2":{"57":1}}],["循环实现",{"2":{"18":1,"22":1}}],["循环嵌套时使用乘法",{"2":{"14":1}}],["循环2n次",{"2":{"14":1}}],["省略所有系数",{"2":{"14":1}}],["因为字符串字面量是不可变的",{"2":{"92":1}}],["因为这种情况很可能导致",{"2":{"85":1}}],["因为在第二行第一次声明该变量时",{"2":{"85":1}}],["因为编译器增加了运行时代码来对每次循环进行条件检查",{"2":{"66":1}}],["因为rust在",{"2":{"62":1}}],["因为rust不会隐式地转换数据地类型",{"2":{"61":1}}],["因为链表节点间指针引用的单向性",{"2":{"35":1}}],["因为它们都与n无关",{"2":{"14":1}}],["因链表节点除存储值外还存储引用",{"2":{"31":1}}],["因此收到上述报错信息",{"2":{"94":1}}],["因此move之后x仍旧有效",{"2":{"94":1}}],["因此他们都被压入了栈中",{"2":{"94":1}}],["因此它是高效且易用的",{"2":{"93":1}}],["因此它需要被分配到堆上",{"2":{"92":1}}],["因此其的存储位置在栈上",{"2":{"92":1}}],["因此语句不能赋值给变量",{"2":{"83":1}}],["因此声明数据时进行类型标注是有必要的",{"2":{"69":1}}],["因此当前迭代后续的",{"2":{"67":1}}],["因此想要通过二者实现栈",{"2":{"56":1}}],["因此想获得算法的时间复杂度",{"2":{"14":1}}],["因此引入",{"2":{"42":1}}],["因此引入链表这种相较于数组更灵活的数据结构",{"2":{"31":1}}],["因此在定义节点对象时",{"2":{"31":1}}],["因此在相同数据量下",{"2":{"31":1}}],["因此总体的时间复杂度为",{"2":{"21":1}}],["因此该算法的时间复杂度是常数阶",{"2":{"17":2}}],["因此该算法的的时间复杂度",{"2":{"15":1}}],["因此只能使用常量来指定长度",{"2":{"2":1}}],["🎉一些推算操作数的技巧",{"2":{"14":1}}],["渐进上界",{"2":{"14":1}}],["occurs",{"2":{"94":1}}],["of",{"2":{"87":2,"94":1}}],["or",{"2":{"81":1}}],["overflowing",{"2":{"71":1}}],["outer",{"2":{"67":2}}],["ok",{"2":{"52":1,"57":1}}],["old",{"2":{"52":2,"57":2}}],["one",{"2":{"28":1,"35":1}}],["o",{"2":{"14":1,"15":8,"20":1,"21":1,"38":6}}],["option",{"2":{"7":1,"29":2,"31":1,"52":3,"57":4}}],["通俗的讲就是一段代码在程序中的有效范围",{"2":{"91":1}}],["通常应用于文本常见",{"2":{"92":1}}],["通常适用于一些永远不会改变的值",{"2":{"86":1}}],["通常将线性时间复杂度记为",{"2":{"14":1}}],["通过重复使用let声明实现遮蔽变量",{"2":{"87":1}}],["通过运行上述代码",{"2":{"85":1}}],["通过",{"2":{"77":1,"78":1}}],["通过将判断条件设定问集合索引的边界实现循环访问",{"2":{"66":1}}],["通过链表实现栈要考虑使用链表的头节点还是尾节点作为栈顶",{"2":{"57":1}}],["通过取余操作实现",{"2":{"53":1}}],["通过pair",{"2":{"29":1}}],["通过一个数组简单实现hash数据结构",{"2":{"29":1}}],["通过构建键",{"2":{"28":1}}],["通过对数据结构在逻辑层面和物理层面上的不同理解",{"2":{"27":1}}],["通过索引访问",{"2":{"6":1}}],["通过索引index访问数组中的元素",{"2":{"3":1}}],["时间内完成操作",{"2":{"47":1}}],["时间内访问任意元素",{"2":{"36":1}}],["时间片轮转调度算法是一种常见的",{"2":{"41":1}}],["时间片轮转调度算法",{"2":{"41":1}}],["时间上对比它们的操作方法的时间复杂度",{"2":{"38":1}}],["时间增长趋势",{"0":{"14":1}}],["时间复杂度o",{"2":{"28":2}}],["时间复杂度为2^n",{"2":{"22":1}}],["时间复杂度为o",{"2":{"11":1,"37":1}}],["时间复杂度类型是根据输入数据n的大小与算法执行时间",{"2":{"16":1}}],["时间复杂度由t",{"2":{"15":1}}],["时间复杂度",{"0":{"13":1},"2":{"15":1}}],["或者循环执行某段代码",{"2":{"59":1}}],["或者链表",{"2":{"28":1}}],["或者二者组合而实现",{"2":{"26":1}}],["或者直接遍历元素本身",{"2":{"6":1}}],["或推断",{"2":{"13":1}}],["根据条件是否为true来决定是否执行某段代码",{"2":{"59":1}}],["根据传入的入队元素",{"2":{"52":1}}],["根据",{"2":{"13":1}}],["根据索引实现随机抽样",{"2":{"12":1}}],["计算并产生一个值",{"2":{"82":1}}],["计算队尾指针",{"2":{"53":1}}],["计算时间复杂度通常需要两个步骤",{"2":{"13":1}}],["计算机不仅会加载它",{"2":{"10":1}}],["图三",{"2":{"94":1}}],["图二",{"2":{"94":1}}],["图一",{"2":{"92":1}}],["图5",{"2":{"51":1}}],["图等",{"2":{"26":1}}],["图等数据结构",{"2":{"12":1}}],["图3",{"2":{"25":1,"26":1}}],["图选自",{"2":{"25":1,"26":1}}],["图",{"2":{"24":1,"25":2,"26":1,"41":1}}],["图的邻接矩阵表示实际上是一个二维数组",{"2":{"12":1}}],["例如",{"2":{"12":1,"14":1,"71":1}}],["堆",{"2":{"12":1,"24":1,"25":2,"26":2}}],["数字运算",{"0":{"73":1}}],["数量标记",{"2":{"50":1}}],["数据的交互方式二",{"0":{"95":1}}],["数据的交互方式一",{"0":{"94":1}}],["数据流可能会被分成多个缓冲块并放入一个环形链表",{"2":{"41":1}}],["数据缓冲区",{"2":{"41":1}}],["数据结构是在计算机中具有一定逻辑关系",{"2":{"24":1}}],["数据结构",{"0":{"24":1}}],["数据结构实现",{"2":{"12":1}}],["数组会更加高效",{"2":{"78":1}}],["数组中的元素数量和类型就不能改变",{"2":{"78":1}}],["数组中元素通过索引",{"2":{"0":1}}],["数组队列结构体",{"2":{"53":1}}],["数组实现队列",{"0":{"53":1},"2":{"53":2}}],["数组与链表的效率对比",{"2":{"38":1}}],["数组可以用于实现栈",{"2":{"12":1}}],["数组可通过索引在时间o",{"2":{"10":1}}],["数组是固定长度的",{"2":{"78":1}}],["数组是rust中一个重要的复合类型",{"2":{"78":1}}],["数组是神经网络编程中最常使用的数据结构",{"2":{"12":1}}],["数组是排序和搜索算法最常用的数据结构",{"2":{"12":1}}],["数组需要预先分配固定大小的内存空间",{"2":{"11":1}}],["数组为数据分配了连续的内存块",{"2":{"10":1}}],["数组的长度是固定的",{"2":{"11":1}}],["数组的插入和删除操作需要大量移动元素",{"2":{"11":1}}],["数组的优",{"0":{"9":1},"1":{"10":1,"11":1,"12":1}}],["数组的常见操作",{"0":{"1":1},"1":{"2":1,"3":1,"4":1,"5":1,"6":1,"7":1,"8":1}}],["数组将数据存储在计算机中一段连续的存储空间",{"2":{"0":1}}],["数组",{"0":{"0":1,"78":1},"2":{"24":1,"25":1,"92":1}}],["矩阵",{"2":{"12":1,"26":1}}],["神经网络中大量使用了向量",{"2":{"12":1}}],["机器学习",{"2":{"12":1}}],["码值作为索引",{"2":{"12":1}}],["码的映射",{"2":{"12":1}}],["则返回",{"2":{"71":1}}],["则会发生整型溢出",{"2":{"71":1}}],["则会造成很大的开销",{"2":{"11":1}}],["则会造成浪费",{"2":{"11":1}}],["则更新栈顶为下一个元素",{"2":{"57":1}}],["则令头",{"2":{"52":1}}],["则需要进行扩容",{"2":{"50":1}}],["则可以将字符的",{"2":{"12":1}}],["假如我们想实现字符到",{"2":{"12":1}}],["可增长的文本片段",{"2":{"93":1}}],["可变",{"2":{"86":1}}],["可选地以表达式结尾",{"2":{"82":1}}],["可从函数中提前返回",{"2":{"81":1}}],["可以以表达式结尾来返回值",{"2":{"84":1}}],["可以接收参数",{"2":{"79":1}}],["可以使用标准库针对原始数字类型提供的以下一系列方法",{"2":{"71":1}}],["可以使用该语言的数组或者链表",{"2":{"55":1}}],["可以使用数组作为查找表",{"2":{"12":1}}],["可以理为一种具有双向数据方向",{"2":{"54":1}}],["可以不断加入新的节点",{"2":{"52":1}}],["可以通过索引或者直接访问列表元素的方式来遍历列表",{"2":{"46":1}}],["可以像访问数组元素那样通过索引在o",{"2":{"45":1}}],["可以动态扩展长度",{"2":{"42":1}}],["可基于链表和数组实现",{"2":{"42":1}}],["可扩展",{"2":{"38":1}}],["可能造成内存浪费",{"2":{"11":1}}],["查找链表节点是一种线性查找",{"2":{"37":1}}],["查找节点",{"0":{"37":1}}],["查找",{"2":{"28":1}}],["查找表",{"2":{"12":1}}],["查找元素",{"0":{"7":1}}],["归并排序",{"2":{"12":1}}],["快速排序",{"2":{"12":1}}],["并返回一个表示该位置地址的指针",{"2":{"88":1}}],["并返回被移除的值",{"2":{"28":1}}],["并及时清理不再使用的数据",{"2":{"88":1}}],["并取原来的值加上",{"2":{"87":1}}],["并且它的大小还可能随着程序运行而改变",{"2":{"93":1}}],["并且必须标注常量类型",{"2":{"86":1}}],["并且按照一定的顺序排列",{"2":{"0":1}}],["并未标识其为可变",{"2":{"85":1}}],["并转到下一个迭代",{"2":{"67":1}}],["并将头节点的下一节点作为新的头节点",{"2":{"52":1}}],["并根据与初始容量的比较决定是否扩容",{"2":{"50":1}}],["并传递动态head",{"2":{"37":1}}],["并生成一个随机序列",{"2":{"12":1}}],["随机访问",{"2":{"12":1}}],["如下图所示",{"2":{"92":1}}],["如下所示",{"2":{"87":1}}],["如元组",{"2":{"92":1}}],["如函数本身就是语句",{"2":{"84":1}}],["如let",{"2":{"77":1}}],["如u8时为256",{"2":{"71":1}}],["如将一个u8赋值",{"2":{"71":1}}],["如i8的取值范围为",{"2":{"71":1}}],["如数组可以从任意位置删除",{"2":{"53":1}}],["如数组在内存中的空间一般是连续的",{"2":{"26":1}}],["如果代码的一部分假设某个值永远不会更改",{"2":{"85":1}}],["如果尝试改变会发生什么",{"2":{"85":1}}],["如果不确定是使用数组还是",{"2":{"78":1}}],["如果不为空",{"2":{"52":1}}],["如果表达式不返回任何其他值",{"2":{"77":1}}],["如果使用",{"2":{"71":1}}],["如果存在会导致程序panic",{"2":{"71":1}}],["如果索引值或测试条件不正确会导致程序",{"2":{"66":1}}],["如果有下一个元素",{"2":{"57":1}}],["如果队列为空",{"2":{"52":1}}],["如果队列不为空",{"2":{"52":1}}],["如果只有头节点",{"2":{"35":1}}],["如果我们想随机抽取一些样本",{"2":{"12":1}}],["如果分配的空间超过需要存储的数据",{"2":{"11":1}}],["如需要扩容",{"2":{"11":1}}],["无需用户关心",{"2":{"93":1}}],["无需全部解除头尾节点的引用",{"2":{"35":1}}],["无符号类型表示的取值范围是",{"2":{"71":1}}],["无符号类型以u开头即unsigned",{"2":{"71":1}}],["无符号型",{"2":{"71":1}}],["无限循环执行表达式里的代码块",{"2":{"64":1}}],["无初始值",{"2":{"44":2}}],["无法动态调整",{"2":{"11":1}}],["无须额外的结构开销",{"2":{"10":1}}],["插入和删除元素",{"0":{"47":1}}],["插入和删除操作效率低",{"2":{"11":1}}],["插入节点",{"0":{"34":1}}],["插入",{"2":{"28":1}}],["插入元素",{"0":{"4":1},"2":{"53":1}}],["缺点",{"0":{"11":1}}],["缺点和应用",{"0":{"9":1},"1":{"10":1,"11":1,"12":1}}],["缓存局部性",{"2":{"10":1}}],["支持随机访问",{"2":{"10":1}}],["优点",{"0":{"10":1}}],["src",{"2":{"94":1}}],["srtuct",{"2":{"57":1}}],["s分为两部分分别存储在栈和堆上",{"2":{"94":1}}],["s的存储方式是按照图一的方式",{"2":{"94":1}}],["sapces",{"2":{"87":1}}],["saturating",{"2":{"71":1}}],["spaces",{"2":{"87":5}}],["scope",{"2":{"87":1}}],["shadow更加的灵活",{"2":{"87":1}}],["shadow更加不容易更改变量的值",{"2":{"87":1}}],["shadow",{"0":{"87":1},"2":{"87":1}}],["shellerror",{"2":{"94":1}}],["shellcount",{"2":{"67":1}}],["shellx",{"2":{"67":1}}],["shell第1个元素是",{"2":{"66":1}}],["shell第0个元素是",{"2":{"66":1}}],["s",{"2":{"80":1,"81":1,"92":1,"93":4,"94":11}}],["six",{"2":{"62":1}}],["size",{"2":{"8":2,"50":14,"52":7,"53":10,"57":7}}],["second",{"2":{"61":1,"78":1}}],["self",{"2":{"29":17,"50":40,"52":20,"53":24,"57":17}}],["slef",{"2":{"50":1}}],["sort",{"2":{"48":1}}],["some",{"2":{"7":1,"29":4,"33":2,"34":1,"35":1,"36":1,"37":1,"52":4,"57":3}}],["super",{"2":{"29":1}}],["statement",{"2":{"82":1}}],["stacklist",{"2":{"57":2}}],["stack",{"2":{"54":1,"55":5,"57":11}}],["stk",{"2":{"57":1}}],["str表示每个元素的类型",{"2":{"78":1}}],["str`",{"2":{"62":1,"87":1}}],["str",{"2":{"29":1,"78":1}}],["structs",{"2":{"86":1}}],["struct",{"2":{"29":2,"52":2,"53":1,"57":1}}],["string是大小不固定且可变",{"2":{"92":1}}],["string类型的move更像是其他语言中的浅拷贝",{"2":{"94":1}}],["string类型move后再使用会发生什么",{"2":{"94":1}}],["string类型move",{"2":{"94":2}}],["string类型数据在内存的表现形式",{"2":{"92":1}}],["string类型基于字符串字面量实现",{"2":{"92":1}}],["string类型",{"0":{"92":1}}],["string",{"2":{"28":3,"29":5,"92":2,"93":2,"94":3}}],["string>",{"2":{"28":1,"29":2}}],["std",{"2":{"28":1,"31":2,"52":2,"57":2}}],["square",{"2":{"21":1}}],["7",{"0":{"8":1,"23":1},"2":{"67":1}}],["x的移动是在栈上进行的copy",{"2":{"94":1}}],["x恢复为6",{"2":{"87":1}}],["x=",{"2":{"73":1}}],["x+y",{"2":{"73":1}}],["x+y=",{"2":{"73":1}}],["x变为1",{"2":{"67":1}}],["x",{"2":{"29":2,"62":2,"65":5,"66":4,"67":7,"72":1,"73":10,"77":7,"81":3,"83":1,"84":1,"85":13,"86":2,"87":16,"94":7}}],["x3c",{"2":{"7":1,"20":1,"28":2,"29":7,"31":3,"34":7,"35":4,"36":7,"37":4,"44":2,"50":1,"52":15,"53":1,"57":13,"66":1,"67":1}}],["x26",{"2":{"2":2,"3":1,"4":1,"5":1,"6":1,"7":1,"8":1,"28":2,"29":17,"34":1,"35":1,"36":2,"37":2,"46":1,"50":8,"52":6,"53":6,"57":5,"62":1,"78":2,"87":1}}],["twice",{"2":{"85":1}}],["two",{"2":{"28":1}}],["third",{"2":{"78":1}}],["the",{"2":{"78":4,"87":3,"94":1}}],["three",{"2":{"28":1}}],["thread",{"2":{"3":1}}],["type声明",{"2":{"81":1}}],["type",{"2":{"77":1,"83":1,"94":1}}],["tupl",{"2":{"77":5}}],["tupl2",{"2":{"77":1}}],["tupl1",{"2":{"77":2}}],["tuple",{"2":{"76":1,"86":2}}],["trait",{"2":{"94":1}}],["true和false",{"2":{"74":1}}],["true",{"2":{"61":2,"62":1,"74":1}}],["try",{"2":{"52":1,"57":1}}],["t>>>>",{"2":{"57":2}}],["t>>>",{"2":{"35":1,"36":1,"37":1}}],["t>>",{"2":{"34":2,"36":1}}],["t>",{"2":{"34":1,"35":1,"36":1,"57":2}}],["test",{"2":{"29":6}}],["top",{"2":{"55":1}}],["to",{"2":{"28":3,"29":4,"85":1,"86":1,"92":1}}],["tagart元素对应索引",{"2":{"37":1}}],["take",{"2":{"34":1,"35":2,"52":4,"57":3}}],["table",{"0":{"28":1}}],["target",{"2":{"7":2,"37":4}}],["t",{"2":{"14":1,"37":2,"57":1,"74":1}}],["tip",{"2":{"14":1,"15":1}}],["的错误",{"2":{"94":1}}],["的值",{"2":{"94":1}}],["的值变成了",{"2":{"87":1}}],["的变量",{"2":{"89":1}}],["的变化来决定的",{"2":{"16":1}}],["的根源在实际开发中可能很难追踪",{"2":{"85":1}}],["的形式",{"2":{"79":1}}],["的编译期",{"2":{"71":1}}],["的主要应用场景是用作某些集合的索引",{"2":{"71":1}}],["的整型默认是",{"2":{"71":1}}],["的限制",{"2":{"56":1}}],["的数据结构",{"2":{"54":1}}],["的数组",{"2":{"26":1}}],["的数组访问函数",{"2":{"3":1}}],["的数组被设计为在编译期确定长度",{"2":{"2":1}}],["的",{"2":{"54":1,"75":1}}],["的索引",{"2":{"29":1}}],["的查找算法",{"2":{"7":1}}],["name",{"2":{"79":1}}],["names",{"2":{"78":6}}],["n代表该数据类型的位数",{"2":{"71":1}}],["n1",{"2":{"33":3,"34":2,"35":2}}],["n0",{"2":{"33":3}}],["need",{"2":{"92":1}}],["next",{"2":{"31":1,"33":5,"34":3,"35":6,"36":1,"37":1,"52":4,"57":3}}],["new",{"2":{"8":3,"28":2,"29":4,"33":6,"44":1,"50":5,"52":12,"53":1,"55":1,"57":4}}],["not",{"2":{"92":1,"94":1}}],["node",{"2":{"34":5,"35":10,"36":4,"37":4,"57":3}}],["no",{"2":{"28":2,"61":1,"73":1}}],["none=>",{"2":{"52":2}}],["none",{"2":{"7":1,"29":4,"33":3,"52":3,"57":3,"71":1}}],["n−2",{"2":{"23":1}}],["n−1",{"2":{"23":1}}],["n互不重复的元素",{"2":{"23":1}}],["n2",{"2":{"15":1,"33":2}}],["n^3",{"2":{"15":2}}],["n^2",{"2":{"15":2,"21":1}}],["n",{"0":{"18":1,"19":1},"2":{"7":1,"11":1,"14":10,"15":5,"17":2,"18":4,"19":2,"20":7,"21":4,"22":4,"23":6,"28":1,"36":1,"37":1,"38":3,"47":1}}],["number",{"2":{"62":5}}],["nums",{"2":{"4":5,"5":4,"45":1,"53":4}}],["num",{"2":{"4":4,"45":1,"52":4,"53":2,"57":2,"61":2,"80":3,"81":3,"83":4,"84":2,"86":2}}],["知道找到对应值",{"2":{"7":1}}],["64位",{"2":{"71":1}}],["6",{"0":{"7":1,"22":1,"49":1},"2":{"44":1,"47":1,"49":1,"61":3,"66":1,"77":3,"83":1,"87":2}}],["label",{"2":{"67":1}}],["labelname",{"2":{"67":1}}],["last",{"2":{"50":2,"55":1}}],["lru",{"2":{"41":2}}],["limited",{"2":{"86":1}}],["lisstnode>>>",{"2":{"52":1}}],["lisstnode",{"2":{"33":3}}],["list",{"0":{"42":1},"2":{"33":1,"38":1,"50":3}}],["listnode>>>",{"2":{"31":1,"52":4,"57":1}}],["listnode",{"2":{"31":1,"34":2,"35":1,"36":1,"37":1,"52":3,"57":4}}],["link",{"2":{"33":1,"38":1}}],["linear",{"2":{"19":1,"20":3}}],["lily",{"2":{"29":2}}],["lucy",{"2":{"29":2}}],["logarithmic",{"2":{"18":1}}],["log",{"0":{"18":1},"2":{"20":4}}],["loop`",{"2":{"67":1}}],["loop的下一个迭代",{"2":{"67":1}}],["loop的下一次迭代",{"2":{"67":1}}],["loop继续执行后续代码",{"2":{"67":1}}],["loop执行一次使",{"2":{"67":1}}],["loop循环",{"0":{"64":1}}],["loop",{"2":{"6":1,"63":1,"64":1,"67":5}}],["lt",{"2":{"15":1,"53":1}}],["len",{"2":{"3":1,"4":1,"5":1,"6":1,"7":1,"8":2,"46":1,"50":1,"55":2,"87":2}}],["let",{"0":{"62":1},"2":{"2":4,"3":2,"8":1,"14":1,"18":1,"19":1,"20":1,"21":1,"22":2,"23":1,"28":4,"29":6,"33":2,"34":1,"35":3,"36":1,"37":1,"44":2,"45":1,"50":1,"52":1,"53":2,"57":1,"62":4,"66":2,"67":3,"72":2,"73":4,"74":2,"75":3,"77":4,"78":3,"81":1,"83":5,"84":3,"87":9,"93":1,"94":7}}],["末端位置的元素将为none",{"2":{"5":1}}],["处的元素更新为",{"2":{"45":1}}],["处的元素",{"2":{"4":1,"45":1}}],["处插入元素",{"2":{"4":1}}],["赋给",{"2":{"4":1}}],["将会收到如下报错信息",{"2":{"94":1}}],["将会收到来自编译器的警告",{"2":{"92":1}}],["将获得第二个值",{"2":{"87":1}}],["将收到编译器的报错",{"2":{"85":1}}],["将多个值组合在一起可以组成复合类型",{"2":{"76":1}}],["将被转换后为0",{"2":{"71":1}}],["将链表的头节点看作队首",{"2":{"52":1}}],["将链表的尾节点看作队尾",{"2":{"52":1}}],["将索引",{"2":{"45":1}}],["将切换到下一个进程",{"2":{"41":1}}],["将头节点的指针修改指向至删除节点后面的节点",{"2":{"35":1}}],["将头节点指针指向插入节点",{"2":{"34":1}}],["将插入节点的指针指向原本第二节点",{"2":{"34":1}}],["将元素添加到数组",{"2":{"28":1}}],["将",{"2":{"4":1}}],["+=",{"2":{"18":1,"19":1,"20":1,"21":1,"22":1,"23":1,"46":2,"50":2,"52":1,"53":1,"57":1,"67":2}}],["+1",{"2":{"15":1}}],["+n",{"2":{"14":2}}],["+0",{"2":{"14":2}}],["+",{"2":{"4":1,"5":1,"8":1,"14":3,"15":5,"20":1,"22":5,"53":4,"64":1,"77":1,"78":1,"81":2,"83":1,"84":2,"86":1,"87":1}}],["free",{"2":{"94":1}}],["from已经完成向内存分配器申请内存",{"2":{"93":1}}],["from",{"2":{"92":1,"93":1,"94":3}}],["from函数赋予字符串字面量string的命名空间",{"2":{"92":1}}],["front",{"2":{"53":7}}],["f",{"2":{"74":1}}],["float",{"2":{"73":1}}],["f32",{"2":{"72":2}}],["f64",{"2":{"72":1,"77":2}}],["focus",{"2":{"85":1}}],["fourth",{"2":{"78":1}}],["found",{"2":{"62":1,"87":1}}],["for循环直接遍历集合的元素",{"2":{"66":1}}],["for等",{"2":{"63":1}}],["for",{"0":{"66":1},"2":{"4":1,"5":1,"6":2,"7":1,"8":1,"14":3,"17":1,"19":1,"20":1,"21":2,"22":2,"23":1,"50":2,"66":1,"73":1}}],["false",{"2":{"61":1,"74":1}}],["factorial",{"2":{"23":2}}],["first",{"2":{"78":1}}],["fisrt",{"2":{"61":2}}],["filter",{"2":{"29":3}}],["find",{"2":{"7":1,"37":2}}],["functions",{"2":{"86":1}}],["function",{"2":{"79":5}}],["func",{"2":{"29":6}}],["fn关键字用来声明函数",{"2":{"79":1}}],["fn",{"2":{"3":1,"4":1,"5":1,"6":1,"7":1,"8":1,"14":1,"17":2,"18":1,"19":1,"20":1,"21":1,"22":1,"23":1,"28":1,"29":11,"33":1,"50":9,"52":7,"53":7,"57":6,"61":1,"72":1,"73":1,"79":1,"80":1,"81":1,"83":3,"84":1,"87":1}}],["以确定在循环的每次迭代中索引是否在数组的边界内",{"2":{"66":1}}],["以便实现无缝播放",{"2":{"41":1}}],["以上述结构体为例",{"2":{"33":1}}],["以及支持快速添加和删除节点",{"2":{"41":1}}],["以及不同数据结构之间的关系有了一定的了解",{"2":{"27":1}}],["以及之后的所有元素向后移动一位",{"2":{"4":1}}],["以此类推",{"2":{"22":1}}],["以下将",{"2":{"2":1}}],["当s和z都离开作用域时",{"2":{"94":1}}],["当变量离开作用域时它被自动调用",{"2":{"94":1}}],["当尝试将字符串字面量设置为可变",{"2":{"92":1}}],["当尝试改变一个前面指定为不可变的值时我们会得到编译期错误",{"2":{"85":1}}],["当向堆放入数据时",{"2":{"88":1}}],["当该作用域结束时",{"2":{"87":1}}],["当函数没有返回值时",{"2":{"83":1}}],["当plus函数有返回值时可行",{"2":{"83":1}}],["当超出索引来访问时",{"2":{"78":1}}],["当数组中的所有元素都相等时",{"2":{"78":1}}],["当使用",{"2":{"71":1}}],["当条件不再为真",{"2":{"65":1}}],["当某一个分支的条件满足后",{"2":{"61":1}}],["当栈顶元素没有下一个元素时",{"2":{"57":1}}],["当把球放进筒时",{"2":{"55":1}}],["当front到数组尾端时",{"2":{"53":1}}],["当进行增删等操作时",{"2":{"50":1}}],["当然也可实现自己构造函数",{"2":{"44":1}}],["当然这些都还是很浅显的认知",{"2":{"27":1}}],["当时间片用完时",{"2":{"41":1}}],["当用户点击前进或后退按钮时",{"2":{"41":1}}],["当插入操作在链表的一端进行",{"2":{"41":1}}],["当插入和删除操作都在链表的一端进行时",{"2":{"41":1}}],["当前节点值等于target时",{"2":{"37":1}}],["当算法的运行时间跟输入数据n成正比时",{"2":{"19":1}}],["当算法的运行时间跟输入数据n的log成正比时",{"2":{"18":1}}],["当算法的运行时间跟输入数据n无关时",{"2":{"17":1}}],["当需要快速查找一个元素或其对应关系时",{"2":{"12":1}}],["当访问数组元素时",{"2":{"10":1}}],["当元素超出数组长度的时候",{"2":{"4":1}}],["当索引超出数组长度时会产生无效的访问",{"2":{"3":1}}],["rs",{"2":{"94":1}}],["rate",{"2":{"50":3}}],["range",{"2":{"3":1}}],["rand",{"2":{"3":5}}],["rc",{"2":{"31":3,"33":3,"34":2,"35":1,"36":2,"37":1,"52":9,"57":6}}],["rc即引用计数",{"2":{"31":1}}],["release时",{"2":{"71":1}}],["rear",{"2":{"53":1}}],["resize",{"2":{"50":2}}],["refcell",{"2":{"31":2,"33":3,"34":2,"35":1,"36":2,"37":1,"52":7,"57":4}}],["reference",{"2":{"31":1}}],["ref",{"2":{"29":5,"52":1,"57":1}}],["remove",{"2":{"28":1,"29":3,"47":2}}],["removed",{"2":{"28":1}}],["return",{"2":{"20":2,"23":1,"35":1,"36":3,"37":3,"50":1,"53":1,"81":2}}],["recur",{"2":{"20":3,"23":2}}],["rev",{"2":{"4":1}}],["rng",{"2":{"3":1}}],["rust的策略是在变量离开作用域时",{"2":{"93":1}}],["rust的所有的数字类型都支持基本的数学运算",{"2":{"73":1}}],["rustlet",{"2":{"92":1,"94":3}}],["rust函数采用",{"2":{"79":1}}],["rust标准库存在一种动态数组",{"2":{"78":1}}],["rust标量类型包括",{"2":{"70":1}}],["rust默认的浮点类型是f64",{"2":{"72":1}}],["rust是一门静态类型语言",{"2":{"69":1}}],["rust提供了多种循环",{"2":{"63":1}}],["rustfn",{"2":{"61":1,"62":1,"64":1,"65":1,"66":2,"67":2,"75":1,"79":1,"80":1,"81":1,"83":1,"84":1,"93":1,"94":1}}],["rust中的函数诸如fn",{"2":{"79":1}}],["rust中的整型",{"2":{"71":1}}],["rust中常见的控制流有",{"2":{"59":1}}],["rust中哈希表的基本操作",{"2":{"28":1}}],["rust\\tstruct",{"2":{"50":1}}],["rust\\tvec2",{"2":{"47":1,"48":1}}],["rust\\tlet",{"2":{"46":1,"49":1,"55":1}}],["rust\\tfn",{"2":{"44":1,"85":2,"87":1}}],["rust\\t",{"2":{"34":1,"35":1,"36":1,"37":1,"86":1}}],["rust\\tuse",{"2":{"31":1}}],["rustuse",{"2":{"28":1,"52":1}}],["rust",{"2":{"2":4,"3":1,"4":1,"5":1,"6":1,"7":1,"8":1,"14":1,"17":1,"18":1,"19":1,"20":1,"21":1,"22":1,"29":1,"33":1,"45":1,"53":1,"57":1,"61":1,"71":1,"72":1,"73":1,"74":1,"75":1,"77":2,"78":2,"85":2,"87":1}}],[">i32",{"2":{"86":1}}],[">bool",{"2":{"52":1}}],[">usize",{"2":{"52":1}}],[">option",{"2":{"52":1}}],[">self",{"2":{"52":1}}],[">=",{"2":{"50":5}}],[">",{"2":{"3":1,"7":1,"17":2,"18":2,"19":1,"20":1,"21":1,"22":1,"23":1,"29":6,"36":1,"37":1,"50":4,"52":1,"53":6,"57":5,"61":3,"81":1,"94":1}}],["e0382",{"2":{"94":1}}],["eyed",{"2":{"75":1}}],["else的每个分支的可能的返回值都必须是相同类型",{"2":{"62":1}}],["else",{"2":{"61":4,"62":2}}],["element",{"2":{"3":3,"5":1,"7":1,"50":3,"78":4}}],["empty",{"2":{"52":1,"53":2,"55":2,"57":1}}],["eq",{"2":{"29":5}}],["end",{"2":{"52":13,"53":2}}],["entry",{"2":{"29":1}}],["enlarge",{"2":{"8":3}}],["expression",{"2":{"82":1}}],["expected",{"2":{"62":1,"87":1}}],["exponential",{"2":{"22":1}}],["extend",{"2":{"2":1,"49":1,"50":3}}],["按照元素排列递增",{"2":{"3":1}}],["看作数组",{"2":{"2":1}}],["一个值在任一时刻都只能有且仅有一个所有者",{"2":{"89":1}}],["一个常量声明的例子",{"2":{"86":1}}],["一个具有返回值的函数声明的示例",{"2":{"81":1}}],["一个具有参数的函数声明的示例",{"2":{"80":1}}],["一个函数声明的示例",{"2":{"79":1}}],["一下以头插法实现栈的基本代码如下",{"2":{"57":1}}],["一下代码实现在头节点后插入节点",{"2":{"34":1}}],["一些数组的特性",{"2":{"53":1}}],["一些操作数对应的时间复杂度",{"2":{"15":1}}],["一直访问下一个节点",{"2":{"36":1}}],["一般情况下用作动态数组的类型",{"2":{"2":1}}],["一旦创建",{"2":{"0":1,"77":1,"78":1}}],["是因为栈中的所有数据都必须占用已知且固定的大小",{"2":{"88":1}}],["是执行一些操作但不返回值的指令",{"2":{"82":1}}],["是一个表达式",{"2":{"62":1}}],["是指数阶增长的典型例子",{"2":{"22":1}}],["是",{"2":{"2":1}}],["为什么字符串字面量不可变",{"2":{"92":1}}],["为了维持一段可变",{"2":{"93":1}}],["为了更深刻地理解栈是如何通过这两种数据结构实现的",{"2":{"56":1}}],["为了方便实现扩容",{"2":{"2":1}}],["为切片",{"2":{"2":1}}],["为数组",{"2":{"2":1}}],["不再有效",{"2":{"93":1}}],["不能为了每一个在编译时大小未知的文本而将一块内存放入二进制文件中",{"2":{"93":1}}],["不能对不可变变量二次赋值",{"2":{"85":1}}],["不确定大小的数据量",{"2":{"92":1}}],["不同于rust中其他已知固定大小的数据类型",{"2":{"92":1}}],["不同于变量使用let声明",{"2":{"86":1}}],["不同于数组访问可以在o",{"2":{"36":1}}],["不可变变量意味着一旦声明后值就不能改变",{"2":{"85":1}}],["不过你也可以选择让变量是可变的mutable",{"2":{"85":1}}],["不过循环在其尝试从数组获取第",{"2":{"66":1}}],["不应该依赖补码处理整型溢出",{"2":{"71":1}}],["不断将新元素放入栈顶",{"2":{"55":1}}],["不指定长度时",{"2":{"2":1}}],["不初始化值",{"2":{"2":1}}],["中最高阶的项来决定",{"2":{"15":1}}],["中的常数项",{"2":{"14":1}}],["中",{"2":{"2":1}}],["在讨论这个报错信息之前",{"2":{"94":1}}],["在上述的示例中",{"2":{"94":1}}],["在数据不在使用时",{"2":{"93":1}}],["在数据不再使用时",{"2":{"93":1}}],["在数组有效索引范围内查找元素",{"2":{"7":1}}],["在数组的索引",{"2":{"4":1}}],["在数组中插入元素",{"2":{"4":1}}],["在栈上存储一个指向堆上内容的指针",{"2":{"92":1}}],["在堆的某处找到一块足够大的空位",{"2":{"88":1}}],["在编译时大小未知或大小可能变化的数据",{"2":{"88":1}}],["在内部作用域内",{"2":{"87":1}}],["在函数中",{"2":{"81":1}}],["在很多语言中函数都是非常常见的存在",{"2":{"79":1}}],["在很多编程语言中并没有预先设定的栈数据结构",{"2":{"55":1}}],["在现代计算机中",{"2":{"72":1}}],["在调试模式",{"2":{"71":1}}],["在某一时刻会到达值",{"2":{"66":1}}],["在某些数据缓冲区的实现中",{"2":{"41":1}}],["在生活中有许多类似栈数据结构的例子",{"2":{"55":1}}],["在rust中mian函数是很多程序的入口",{"2":{"79":1}}],["在rust中",{"2":{"76":1,"85":1}}],["在rust中浮点类型分为单精度和双精度两种",{"2":{"72":1}}],["在rust中数组存在size和capacity两个概念",{"2":{"53":1}}],["在rust中使用智能指针rc来定义链表引用",{"2":{"31":1}}],["在中间插入元素",{"2":{"50":1}}],["在尾部插入元素",{"2":{"50":1}}],["在动手编写代码前",{"2":{"50":1}}],["在索引index处插入value",{"2":{"47":1}}],["在列表的末尾可以在o",{"2":{"47":1}}],["在许多高级编程语言的标准库中都初始了动态数组的构造方法",{"2":{"44":1}}],["在操作系统中",{"2":{"41":1}}],["在缓存淘汰",{"2":{"41":1}}],["在网页浏览器中",{"2":{"41":1}}],["在该方案中",{"2":{"41":1}}],["在环形链表中任一节点都可以作为头节点",{"2":{"40":1}}],["在这里我们删除头节点后的节点",{"2":{"35":1}}],["在",{"0":{"62":1},"2":{"2":1,"81":1}}],["008",{"2":{"29":2}}],["007",{"2":{"29":1}}],["0",{"2":{"2":7,"3":1,"6":1,"7":1,"8":2,"14":5,"17":2,"18":1,"19":2,"20":1,"21":3,"22":3,"23":3,"33":1,"36":1,"45":2,"46":3,"50":3,"52":2,"53":5,"55":1,"57":1,"61":1,"65":1,"66":1,"67":4,"71":2,"72":2,"73":1,"77":2,"78":1,"85":3}}],["4",{"0":{"5":1,"20":1,"36":1,"39":1,"40":1,"41":1,"47":1,"67":1,"74":1},"1":{"40":1,"41":1},"2":{"2":2,"22":2,"28":1,"49":1,"51":1,"62":1,"66":3,"77":2,"94":2}}],["30",{"2":{"86":2}}],["3表示每个元素的值",{"2":{"78":1}}],["3表示数组的长度",{"2":{"78":1}}],["32位",{"2":{"71":1}}],["3n+2",{"2":{"15":1}}],["3n+1次等",{"2":{"14":1}}],["3",{"0":{"4":1,"16":1,"17":1,"18":1,"19":2,"20":1,"21":1,"22":1,"23":1,"35":1,"38":1,"46":1,"66":1,"73":1},"1":{"17":1,"18":1,"19":1,"20":1,"21":1,"22":1,"23":1},"2":{"2":2,"14":1,"28":3,"44":1,"47":2,"55":1,"65":1,"66":3,"67":1,"72":1,"78":9,"94":1}}],["24",{"2":{"94":1}}],["20",{"2":{"73":1}}],["256",{"2":{"71":1}}],["255",{"2":{"71":1}}],["2^",{"2":{"22":2}}],["2^n^",{"2":{"71":2}}],["2^n个细胞",{"2":{"22":1}}],["2^n",{"2":{"15":2,"22":1,"71":1}}],["2n^2",{"2":{"15":1}}],["2n",{"2":{"15":2}}],["2",{"0":{"3":1,"15":1,"18":1,"26":1,"32":1,"33":1,"34":2,"35":1,"36":1,"37":1,"41":1,"45":1,"50":1,"53":1,"56":1,"57":1,"58":2,"62":1,"65":1,"72":1,"78":1,"84":1,"92":1,"95":1},"1":{"33":1,"34":1,"35":1,"36":1,"37":1,"57":1,"58":1},"2":{"2":2,"13":1,"14":3,"18":1,"20":2,"22":3,"26":1,"28":3,"29":1,"33":1,"44":1,"50":1,"55":1,"66":3,"67":3,"72":1,"73":4,"77":1,"78":2,"87":2,"94":1}}],["=>",{"2":{"52":2,"57":2}}],["=n∗",{"2":{"23":1}}],["=n2+n",{"2":{"14":1}}],["==",{"2":{"7":1,"15":1,"23":1,"37":1,"50":1,"52":1,"53":2,"57":1,"67":3}}],["=",{"2":{"2":3,"3":2,"4":2,"5":1,"8":2,"14":2,"18":2,"19":1,"20":2,"21":1,"22":5,"23":1,"28":4,"29":9,"33":5,"34":3,"35":4,"36":2,"37":1,"44":2,"45":2,"46":2,"49":1,"50":11,"52":7,"53":7,"55":4,"57":6,"62":3,"65":3,"66":2,"67":5,"72":2,"73":4,"74":2,"75":3,"77":11,"78":3,"81":1,"83":5,"84":3,"85":4,"86":3,"87":8,"92":1,"93":1,"94":14}}],["5表示数组的长度",{"2":{"78":1}}],["500",{"2":{"77":2}}],["5向下取整",{"2":{"73":1}}],["5",{"0":{"6":1,"21":1,"37":1,"48":1,"75":1},"2":{"2":8,"14":1,"44":1,"61":1,"62":2,"66":6,"67":1,"73":1,"78":1,"80":2,"81":1,"83":3,"84":1,"86":2,"87":2,"94":3}}],["immutable",{"2":{"85":1}}],["implement",{"2":{"94":1}}],["implementation",{"2":{"73":1}}],["impl",{"2":{"29":1,"52":2,"53":1,"57":1}}],["i128",{"2":{"71":1}}],["i16",{"2":{"71":1}}],["i64",{"2":{"71":1}}],["i8",{"2":{"71":1}}],["i+1",{"2":{"50":1}}],["item",{"2":{"46":2}}],["iter",{"2":{"29":3}}],["isize",{"2":{"71":2}}],["is",{"2":{"35":1,"52":1,"53":2,"55":2,"57":1,"61":4,"62":2,"65":1,"67":16,"78":4,"80":1,"81":1,"87":2}}],["if的每个分支都必须返回相同的类型",{"2":{"62":1}}],["if可用于多重条件判",{"2":{"61":1}}],["if表达式",{"2":{"59":1}}],["if",{"0":{"60":1,"61":1,"62":1},"1":{"61":1,"62":1},"2":{"7":1,"20":1,"23":1,"35":2,"36":2,"37":2,"50":5,"53":2,"61":9,"62":4,"67":5}}],["i",{"2":{"4":3,"5":3,"6":4,"7":3,"8":3,"14":2,"17":2,"19":1,"21":1,"46":2,"50":5,"66":3}}],["integer",{"2":{"62":1,"73":1}}],["into",{"2":{"52":1,"57":1}}],["inner",{"2":{"52":1,"57":1,"67":3,"87":1}}],["inite",{"2":{"33":1}}],["in",{"2":{"4":1,"5":1,"6":2,"7":1,"8":1,"14":3,"17":1,"19":1,"20":1,"21":2,"22":2,"23":1,"46":2,"50":2,"66":1,"86":1,"87":1}}],["insert",{"2":{"4":1,"28":3,"34":1,"47":1}}],["index+1",{"2":{"37":1,"50":1}}],["index的映射",{"2":{"29":1}}],["index",{"2":{"0":1,"3":2,"4":6,"5":2,"29":10,"36":4,"37":4,"47":2,"50":15,"66":5}}],["i32>",{"2":{"29":1,"44":2,"50":1,"53":1}}],["i32",{"2":{"2":6,"3":2,"4":2,"5":1,"6":1,"7":2,"8":1,"14":1,"17":4,"18":2,"19":2,"20":3,"21":2,"22":2,"23":2,"28":1,"29":5,"31":1,"36":1,"37":2,"45":1,"50":5,"52":3,"53":9,"57":1,"61":1,"71":2,"77":4,"80":1,"81":2,"83":3,"84":1,"86":3}}],["after",{"2":{"94":1}}],["and",{"2":{"86":1}}],["another",{"2":{"79":4}}],["a=",{"2":{"73":2}}],["are",{"2":{"86":1}}],["arch",{"2":{"71":1}}],["arm",{"2":{"61":4}}],["arrayqueue",{"2":{"53":4}}],["array这个概念来实现列表",{"2":{"42":1}}],["arrayhash",{"2":{"29":5}}],["array",{"2":{"2":1,"38":1,"76":1}}],["arr",{"2":{"2":1,"3":3,"6":4,"7":3,"8":7}}],["add",{"2":{"50":2,"71":1}}],["acess",{"2":{"36":1}}],["access",{"2":{"36":1}}],["assign",{"2":{"85":1}}],["assert",{"2":{"29":5}}],["as",{"2":{"20":1,"29":6,"52":1,"53":3,"57":1}}],["ascii",{"2":{"12":2}}],["allocator",{"2":{"88":1}}],["alice",{"2":{"78":2}}],["alter",{"2":{"61":4}}],["alog",{"2":{"17":2}}],["algorithm",{"2":{"14":1}}],["a",{"2":{"2":1,"14":3,"73":4,"78":1,"83":1,"84":2}}],["15",{"2":{"81":1}}],["12",{"2":{"87":2}}],["127",{"2":{"71":1}}],["128",{"2":{"71":1}}],["128位",{"2":{"71":1}}],["1^",{"2":{"71":1}}],["16位",{"2":{"71":1}}],["11",{"2":{"47":1}}],["1次",{"2":{"36":1}}],["102",{"2":{"29":3}}],["100",{"2":{"29":3}}],["1000",{"2":{"17":1}}],["10000n^2",{"2":{"15":1}}],["1000000",{"2":{"15":1}}],["10",{"2":{"15":1,"61":1,"67":5,"73":1,"81":2,"84":1,"85":3}}],["1",{"0":{"1":1,"2":2,"3":1,"4":1,"5":1,"6":1,"7":1,"8":1,"14":1,"17":2,"25":1,"31":1,"33":1,"40":1,"43":1,"44":2,"45":1,"46":1,"47":1,"48":1,"49":1,"52":1,"55":1,"57":1,"61":1,"64":1,"71":1,"77":1,"83":1,"91":1,"94":1},"1":{"2":1,"3":1,"4":1,"5":1,"6":1,"7":1,"8":1,"44":1,"45":1,"46":1,"47":1,"48":1,"49":1},"2":{"2":2,"3":1,"4":2,"5":2,"10":1,"13":1,"14":6,"15":1,"18":2,"19":1,"20":3,"21":1,"22":7,"23":3,"25":1,"28":4,"33":1,"36":2,"37":1,"38":3,"44":1,"45":5,"47":1,"50":6,"52":2,"53":4,"55":1,"57":2,"65":1,"66":3,"67":5,"71":3,"77":4,"78":2,"83":1,"84":2,"86":1,"87":2}}]],"serializationVersion":2}';export{t as default};
