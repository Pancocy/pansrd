const t='{"documentCount":75,"nextId":75,"documentIds":{"0":"/datastru/ds-array.html#数组","1":"/datastru/ds-array.html#_1-数组的常见操作","2":"/datastru/ds-array.html#_1-1-初始化数组","3":"/datastru/ds-array.html#_1-2-访问数组元素","4":"/datastru/ds-array.html#_1-3-插入元素","5":"/datastru/ds-array.html#_1-4-删除元素","6":"/datastru/ds-array.html#_1-5-遍历数组","7":"/datastru/ds-array.html#_1-6-查找元素","8":"/datastru/ds-array.html#_1-7-扩容数组","9":"/datastru/ds-array.html#数组的优、缺点和应用","10":"/datastru/ds-array.html#优点","11":"/datastru/ds-array.html#缺点","12":"/datastru/ds-array.html#应用","13":"/datastru/ds-datastructure.html#数据结构","14":"/datastru/ds-datastructure.html#_1-逻辑结构-线性和非线性","15":"/datastru/ds-datastructure.html#_2-物理结构-连续和非连续","16":"/datastru/ds-datastructure.html#小结","17":"/datastru/ds-complexity.html#时间复杂度","18":"/datastru/ds-complexity.html#_1-时间增长趋势","19":"/datastru/ds-complexity.html#_2-判断渐进上界","20":"/datastru/ds-complexity.html#_3-常见时间复杂度类型","21":"/datastru/ds-complexity.html#_3-1-常数阶o-1","22":"/datastru/ds-complexity.html#_3-2-对数阶o-log-n","23":"/datastru/ds-complexity.html#_3-3-线性阶o-n","24":"/datastru/ds-complexity.html#_3-4-线性对数阶","25":"/datastru/ds-complexity.html#_3-5-平方阶","26":"/datastru/ds-complexity.html#_3-6-指数阶","27":"/datastru/ds-complexity.html#_3-7-阶乘","28":"/datastru/ds-linkedlist.html#_1-链表简介","29":"/datastru/ds-linkedlist.html#_2-链表相关操作","30":"/datastru/ds-linkedlist.html#_2-1-初始化链表","31":"/datastru/ds-linkedlist.html#_2-2-插入节点","32":"/datastru/ds-linkedlist.html#_2-3-删除节点","33":"/datastru/ds-linkedlist.html#_2-4-访问节点","34":"/datastru/ds-linkedlist.html#_2-5-查找节点","35":"/datastru/ds-linkedlist.html#_3-链表vs数组","36":"/datastru/ds-linkedlist.html#_4-链表的类型及应用","37":"/datastru/ds-linkedlist.html#_4-1-常见的链表类型","38":"/datastru/ds-linkedlist.html#_4-2-各类链表的应用","39":"/datastru/ds-list.html#列表-list","40":"/datastru/ds-list.html#_1-列表的常用操作","41":"/datastru/ds-list.html#_1-1-初始化列表","42":"/datastru/ds-list.html#_1-2-访问列表元素","43":"/datastru/ds-list.html#_1-3-遍历列表元素","44":"/datastru/ds-list.html#_1-4-插入和删除元素","45":"/datastru/ds-list.html#_1-5-排序列表","46":"/datastru/ds-list.html#_1-6-组合列表","47":"/datastru/ds-list.html#_2-列表的实现原理","48":"/datastru/ds-queue.html#实现简单结构的队列","49":"/datastru/ds-queue.html#_1-链表实现队列","50":"/datastru/ds-queue.html#_2-数组实现队列","51":"/datastru/ds-stack.html#栈","52":"/datastru/ds-stack.html#_1-认识栈","53":"/datastru/ds-stack.html#_2-栈的实现","54":"/datastru/ds-stack.html#_2-1-基于链表实现栈","55":"/datastru/ds-stack.html#_2-2-基于数组实现栈","56":"/rust/var-loop-func/datatype.html#基本数据类型","57":"/rust/var-loop-func/datatype.html#_1-标量类型","58":"/rust/var-loop-func/datatype.html#_1-1-整数类型","59":"/rust/var-loop-func/datatype.html#_1-3-浮点型","60":"/rust/var-loop-func/datatype.html#_1-3-数字运算","61":"/rust/var-loop-func/datatype.html#_1-4-布尔类型","62":"/rust/var-loop-func/datatype.html#_1-5-字符类型","63":"/rust/var-loop-func/datatype.html#_2-复合类型","64":"/rust/var-loop-func/datatype.html#_2-1-元组","65":"/rust/var-loop-func/datatype.html#_2-2-数组","66":"/rust/var-loop-func/func-loop.html#函数","67":"/rust/var-loop-func/func-loop.html#具有参数的函数","68":"/rust/var-loop-func/func-loop.html#具有返回值的函数","69":"/rust/var-loop-func/func-loop.html#语句和表达式","70":"/rust/var-loop-func/func-loop.html#_1-语句","71":"/rust/var-loop-func/func-loop.html#_2-表达式","72":"/rust/var-loop-func/variable.html#变量与可变性","73":"/rust/var-loop-func/variable.html#常量","74":"/rust/var-loop-func/variable.html#遮蔽-shadow"},"fieldIds":{"title":0,"titles":1,"text":2},"fieldLength":{"0":[1,1,9],"1":[2,1,1],"2":[2,2,42],"3":[3,2,26],"4":[3,2,30],"5":[3,2,20],"6":[3,2,17],"7":[3,2,28],"8":[3,2,24],"9":[2,1,1],"10":[1,2,13],"11":[1,2,15],"12":[1,2,34],"13":[1,1,14],"14":[3,1,22],"15":[3,1,27],"16":[1,1,7],"17":[1,1,9],"18":[2,1,48],"19":[2,1,29],"20":[2,1,5],"21":[4,2,20],"22":[6,2,20],"23":[4,2,19],"24":[3,2,30],"25":[3,2,24],"26":[3,2,37],"27":[3,2,36],"28":[2,1,45],"29":[2,1,1],"30":[3,2,33],"31":[2,2,34],"32":[3,2,41],"33":[3,2,47],"34":[3,2,49],"35":[2,1,31],"36":[2,1,1],"37":[3,2,16],"38":[3,2,57],"39":[3,1,15],"40":[2,1,1],"41":[2,2,25],"42":[3,2,19],"43":[3,2,18],"44":[3,2,25],"45":[3,2,4],"46":[3,2,13],"47":[2,1,93],"48":[1,1,14],"49":[2,1,108],"50":[2,1,83],"51":[1,1,10],"52":[2,1,43],"53":[2,1,12],"54":[3,2,88],"55":[2,2,1],"56":[1,1,10],"57":[2,1,7],"58":[2,2,83],"59":[3,2,22],"60":[3,2,45],"61":[3,2,14],"62":[3,2,21],"63":[2,1,7],"64":[3,2,47],"65":[2,2,54],"66":[1,1,29],"67":[1,1,19],"68":[1,1,35],"69":[1,1,9],"70":[2,1,25],"71":[2,1,25],"72":[1,1,51],"73":[1,1,54],"74":[3,1,71]},"averageFieldLength":[2.3066666666666666,1.52,28.826666666666668],"storedFields":{"0":{"title":"数组","titles":[]},"1":{"title":"1. 数组的常见操作","titles":[]},"2":{"title":"1.1 初始化数组","titles":["1. 数组的常见操作"]},"3":{"title":"1.2 访问数组元素","titles":["1. 数组的常见操作"]},"4":{"title":"1.3  插入元素","titles":["1. 数组的常见操作"]},"5":{"title":"1.4 删除元素","titles":["1. 数组的常见操作"]},"6":{"title":"1.5 遍历数组","titles":["1. 数组的常见操作"]},"7":{"title":"1.6 查找元素","titles":["1. 数组的常见操作"]},"8":{"title":"1.7 扩容数组","titles":["1. 数组的常见操作"]},"9":{"title":"数组的优、缺点和应用","titles":[]},"10":{"title":"优点","titles":["数组的优、缺点和应用"]},"11":{"title":"缺点","titles":["数组的优、缺点和应用"]},"12":{"title":"应用","titles":["数组的优、缺点和应用"]},"13":{"title":"数据结构","titles":[]},"14":{"title":"1 逻辑结构：线性和非线性","titles":[]},"15":{"title":"2 物理结构：连续和非连续","titles":[]},"16":{"title":"小结","titles":[]},"17":{"title":"时间复杂度","titles":[]},"18":{"title":"1. 时间增长趋势","titles":[]},"19":{"title":"2. 判断渐进上界","titles":[]},"20":{"title":"3. 常见时间复杂度类型","titles":[]},"21":{"title":"3.1 常数阶O(1)","titles":["3. 常见时间复杂度类型"]},"22":{"title":"3.2 对数阶O(log n)","titles":["3. 常见时间复杂度类型"]},"23":{"title":"3.3 线性阶O(n)","titles":["3. 常见时间复杂度类型"]},"24":{"title":"3.4 线性对数阶","titles":["3. 常见时间复杂度类型"]},"25":{"title":"3.5 平方阶","titles":["3. 常见时间复杂度类型"]},"26":{"title":"3.6 指数阶","titles":["3. 常见时间复杂度类型"]},"27":{"title":"3.7 阶乘","titles":["3. 常见时间复杂度类型"]},"28":{"title":"1. 链表简介","titles":[]},"29":{"title":"2. 链表相关操作","titles":[]},"30":{"title":"2.1 初始化链表","titles":["2. 链表相关操作"]},"31":{"title":"2.2 插入节点","titles":["2. 链表相关操作"]},"32":{"title":"2.3 删除节点","titles":["2. 链表相关操作"]},"33":{"title":"2.4 访问节点","titles":["2. 链表相关操作"]},"34":{"title":"2.5 查找节点","titles":["2. 链表相关操作"]},"35":{"title":"3. 链表VS数组","titles":[]},"36":{"title":"4. 链表的类型及应用","titles":[]},"37":{"title":"4.1 常见的链表类型","titles":["4. 链表的类型及应用"]},"38":{"title":"4.2 各类链表的应用","titles":["4. 链表的类型及应用"]},"39":{"title":"列表（List）","titles":[]},"40":{"title":"1. 列表的常用操作","titles":[]},"41":{"title":"1.1 初始化列表","titles":["1. 列表的常用操作"]},"42":{"title":"1.2 访问列表元素","titles":["1. 列表的常用操作"]},"43":{"title":"1.3 遍历列表元素","titles":["1. 列表的常用操作"]},"44":{"title":"1.4 插入和删除元素","titles":["1. 列表的常用操作"]},"45":{"title":"1.5 排序列表","titles":["1. 列表的常用操作"]},"46":{"title":"1.6 组合列表","titles":["1. 列表的常用操作"]},"47":{"title":"2. 列表的实现原理","titles":[]},"48":{"title":"实现简单结构的队列","titles":[]},"49":{"title":"1. 链表实现队列","titles":[]},"50":{"title":"2. 数组实现队列","titles":[]},"51":{"title":"栈","titles":[]},"52":{"title":"1. 认识栈","titles":[]},"53":{"title":"2. 栈的实现","titles":[]},"54":{"title":"2.1. 基于链表实现栈","titles":["2. 栈的实现"]},"55":{"title":"2.2. 基于数组实现栈","titles":["2. 栈的实现"]},"56":{"title":"基本数据类型","titles":[]},"57":{"title":"1.标量类型","titles":[]},"58":{"title":"1.1 整数类型","titles":["1.标量类型"]},"59":{"title":"1.3 浮点型","titles":["1.标量类型"]},"60":{"title":"1.3 数字运算","titles":["1.标量类型"]},"61":{"title":"1.4 布尔类型","titles":["1.标量类型"]},"62":{"title":"1.5 字符类型","titles":["1.标量类型"]},"63":{"title":"2. 复合类型","titles":[]},"64":{"title":"2.1 元组","titles":["2. 复合类型"]},"65":{"title":"2.2 数组","titles":["2. 复合类型"]},"66":{"title":"函数","titles":[]},"67":{"title":"具有参数的函数","titles":[]},"68":{"title":"具有返回值的函数","titles":[]},"69":{"title":"语句和表达式","titles":[]},"70":{"title":"1. 语句","titles":["语句和表达式"]},"71":{"title":"2. 表达式","titles":["语句和表达式"]},"72":{"title":"变量与可变性","titles":[]},"73":{"title":"常量","titles":[]},"74":{"title":"遮蔽（Shadow）","titles":[]}},"dirtCount":0,"index":[["恢复成",{"2":{"74":1}}],["内部遮蔽结束并且",{"2":{"74":1}}],["内访问任何元素",{"2":{"10":1,"42":1}}],["得到的",{"2":{"74":1}}],["得出其操作数函数",{"2":{"17":1}}],["第三个",{"2":{"74":1}}],["第二个变量遮蔽了第一个变量",{"2":{"74":1}}],["来遮蔽之前的",{"2":{"74":1}}],["来自",{"2":{"48":1,"49":1,"50":1}}],["绑定到",{"2":{"74":1}}],["作用域结束",{"2":{"74":1}}],["再次使用这个变量时",{"2":{"74":1}}],["再将当前数组的所有元素依次移动至新数组",{"2":{"47":1}}],["遮蔽相较于",{"2":{"74":1}}],["遮蔽失效",{"2":{"74":1}}],["遮蔽是当以相同的名字再次声明变量时",{"2":{"74":1}}],["遮蔽",{"0":{"74":1}}],["html",{"2":{"73":1}}],["heart",{"2":{"62":1}}],["head|",{"2":{"54":1}}],["head",{"2":{"31":4,"33":5,"34":4,"54":4}}],["hello算法",{"2":{"48":1,"49":1,"50":1}}],["hello",{"2":{"14":1,"15":1,"66":2}}],["包括全局作用域",{"2":{"73":1}}],["编译器保证了当我们声明了一个值不会改变时",{"2":{"72":1}}],["编译器会忽略整型溢出",{"2":{"58":1}}],["编译器会检查整型溢出",{"2":{"58":1}}],["特别是第二部分代码只是偶尔变更了原来的值",{"2":{"72":1}}],["特殊的元组",{"2":{"64":1}}],["上述操作就可行了",{"2":{"72":1}}],["上一个节点通过将引用指向下一个节点来访问节点内存地址",{"2":{"28":1}}],["接下来尝试用下面的代码来分析",{"2":{"72":1}}],["提供的安全性和简单并发性的方式来编写代码",{"2":{"72":1}}],["默认情况下的变量是不可变的immutable",{"2":{"72":1}}],["初特殊声明外",{"2":{"72":1}}],["初始容量",{"2":{"47":1}}],["初始值应为0",{"2":{"34":1}}],["初始状态为1个细胞",{"2":{"26":1}}],["初始化栈",{"2":{"54":1}}],["初始化该入列节点为option",{"2":{"49":1}}],["初始化队列",{"2":{"49":1}}],["初始化列表的容量",{"2":{"47":1}}],["初始化列表通常分为",{"2":{"41":1}}],["初始化列表",{"0":{"41":1}}],["初始化各个节点",{"2":{"30":1}}],["初始化链表",{"0":{"30":1}}],["初始化值",{"2":{"2":1}}],["初始化值和不初始化值",{"2":{"2":1}}],["初始化数组有两种方式",{"2":{"2":1}}],["初始化数组时计算机会在内存中分配一块连续的空间",{"2":{"2":1}}],["初始化数组",{"0":{"2":1}}],["变量与可变性",{"0":{"72":1}}],["变量的类型不确定性也就更高了",{"2":{"56":1}}],["该语句计算并返回值",{"2":{"71":1}}],["该表达式以语句结尾",{"2":{"71":1}}],["该值被称为单元值",{"2":{"64":1}}],["否则panic",{"2":{"70":1}}],["表达式可以同样可以作为语句的结束",{"2":{"71":1}}],["表达式计算并返回一个值",{"2":{"71":1}}],["表达式",{"0":{"71":1},"2":{"69":1}}],["表示为",{"2":{"64":1}}],["表示这个整数只表示正整数",{"2":{"58":1}}],["表示这个整数是否可以取负数",{"2":{"58":1}}],["表示标识算法操作次数的函数的",{"2":{"18":1}}],["语句同样遮蔽前面的",{"2":{"74":1}}],["语句计算并返回值",{"2":{"71":1}}],["语句不返回值",{"2":{"70":1}}],["语句",{"0":{"70":1},"2":{"69":1}}],["语句和表达式",{"0":{"69":1},"1":{"70":1,"71":1}}],["关键字+",{"2":{"68":1}}],["之间使用",{"2":{"68":1}}],["此外每个参数都必须标注类型",{"2":{"67":1}}],["此外浮点数和整数之间可以进行运算",{"2":{"60":1}}],["参数的数量可以是多个",{"2":{"67":1}}],["参数说明",{"2":{"31":1,"32":1,"33":1,"34":1}}],["信息",{"2":{"66":1}}],["打印",{"2":{"66":1}}],["打印函数的执行时间固定",{"2":{"21":1}}],["首先",{"2":{"66":1}}],["连接",{"2":{"66":1}}],["连续存储",{"2":{"35":1}}],["连续和非连续",{"0":{"15":1}}],["单词之间使用英文下划线",{"2":{"66":1}}],["单向链表",{"2":{"37":1,"38":1}}],["蛇形命名法",{"2":{"66":1}}],["告诉编译器函数从哪里开始和结束",{"2":{"66":1}}],["函数本身也是一种语句",{"2":{"70":1}}],["函数体由一系列语句构成",{"2":{"69":1}}],["函数可以向调用它的表达式返回值",{"2":{"68":1}}],["函数在声明时可以指定参数",{"2":{"67":1}}],["函数并打印它的信息",{"2":{"66":1}}],["函数中的代码会按顺序执行",{"2":{"66":1}}],["函数",{"0":{"66":1}}],["会引起程序panic",{"2":{"65":1}}],["创建数组有很多方式",{"2":{"65":1}}],["创建元组",{"2":{"64":1}}],["那它就真的不可改变",{"2":{"72":1}}],["那很可能第一部分代码以不可意料的方式运行",{"2":{"72":1}}],["那就应该使用一个",{"2":{"65":1}}],["那么要向队尾插入的的下标应为",{"2":{"50":1}}],["那么就无法在内存中访问到该节点了",{"2":{"32":1}}],["那么可以用数组存储",{"2":{"12":1}}],["称之为向量",{"2":{"65":1}}],["多个参数之间使用",{"2":{"67":1}}],["多个相同类型",{"2":{"65":1}}],["多个不同类型",{"2":{"64":1}}],["没有值或者只有一个值的元组称为单元类型",{"2":{"64":1}}],["模式匹配来解构",{"2":{"64":1}}],["元组中的元素数量和类型就不能改变",{"2":{"64":1}}],["元组是固定长度的",{"2":{"64":1}}],["元组是rust中一个非常特殊的复合类型",{"2":{"64":1}}],["元组",{"0":{"64":1}}],["元素数量+1",{"2":{"47":1}}],["😻",{"2":{"62":1}}],["ℤ",{"2":{"62":1}}],["字面量采用单引号括起来",{"2":{"62":1}}],["字符大小为4字节",{"2":{"62":1}}],["字符串字面量是用双引号括起来",{"2":{"62":1}}],["字符",{"2":{"62":1}}],["字符类型",{"0":{"62":1}}],["字符型",{"2":{"57":1}}],["类型是该语言最基本的字母类型",{"2":{"62":1}}],["类似于双向链表",{"2":{"38":1}}],["显式声明",{"2":{"61":1}}],["布尔类型只有两个值",{"2":{"61":1}}],["布尔类型",{"0":{"61":1}}],["布尔型",{"2":{"57":1}}],["z可为其他不重复名称",{"2":{"64":1}}],["z=",{"2":{"60":1}}],["z",{"2":{"60":6,"62":2,"64":4,"70":1,"71":1}}],["示例如下",{"2":{"60":1}}],["运算结果为浮点数",{"2":{"60":1}}],["运算符包括加",{"2":{"60":1}}],["除",{"2":{"60":1}}],["除声明值外",{"2":{"28":1}}],["乘",{"2":{"60":1}}],["减",{"2":{"60":1}}],["y=",{"2":{"60":4}}],["y",{"2":{"59":1,"60":8,"64":6,"70":2}}],["速度与f32基本相同",{"2":{"59":1}}],["双精度浮点数精度更高",{"2":{"59":1}}],["双向链表的特性使得这种操作变得简单",{"2":{"38":1}}],["双向链表常用于需要快速查找前一个和后一个元素的场景",{"2":{"38":1}}],["双向链表",{"2":{"37":1}}],["区别在于位数不同",{"2":{"59":1}}],["浮点数与整数运算结果取整数",{"2":{"60":1}}],["浮点类型声明的示例",{"2":{"59":1}}],["浮点类型就是含有小数部分的整数",{"2":{"59":1}}],["浮点型",{"0":{"59":1},"2":{"57":1}}],["值为",{"2":{"74":1}}],["值得注意的是",{"2":{"73":1}}],["值",{"2":{"58":1}}],["程序并不会panic",{"2":{"58":1}}],["~",{"2":{"58":4}}],["有两种方式访问元组中的元素",{"2":{"64":1}}],["有符号类型表示的取值范围是",{"2":{"58":1}}],["有符号类型以i开头即integer",{"2":{"58":1}}],["有符号型",{"2":{"58":1}}],["有初始值",{"2":{"41":2}}],["整数和浮点数之间不能进行取模运算",{"2":{"60":1}}],["整数相除向下取整",{"2":{"60":1}}],["整数除法会向下取整",{"2":{"60":1}}],["整数类型",{"0":{"58":1}}],["整型溢出可能导致发生以下两种行为之一",{"2":{"58":1}}],["整型溢出是指给整型变量赋的值超出了变量的取值范围",{"2":{"58":1}}],["整型溢出",{"2":{"58":1}}],["整型还分为有符号和无符号类型",{"2":{"58":1}}],["整型是不包含小数部分的数字",{"2":{"58":1}}],["整型",{"2":{"57":1}}],["复合类型",{"0":{"63":1},"1":{"64":1,"65":1},"2":{"56":1}}],["标明类型",{"2":{"65":1}}],["标量类型标识单个值",{"2":{"57":1}}],["标量类型",{"0":{"57":1},"1":{"58":1,"59":1,"60":1,"61":1,"62":1},"2":{"56":1}}],["标识其在数组中的位置",{"2":{"0":1}}],["基本加减乘除",{"2":{"60":1}}],["基本数据类型",{"0":{"56":1}}],["基于数组实现栈",{"0":{"55":1}}],["基于数组实现队列的入队出队操作",{"2":{"50":1}}],["基于数组可实现",{"2":{"15":1}}],["基于链表实现栈",{"0":{"54":1}}],["基于链表实现队列的入队出队操作",{"2":{"49":1}}],["基于链表可实现",{"2":{"15":1}}],["|old",{"2":{"54":1}}],["|cur",{"2":{"49":1}}],["节点值",{"2":{"54":1}}],["节点间通过引用连接",{"2":{"28":1}}],["属性",{"2":{"53":1}}],["入栈",{"2":{"52":1,"54":1}}],["入队",{"2":{"49":1,"50":1}}],["下面来着手实现简单的栈结构",{"2":{"53":1}}],["下面是一些栈的常用操作",{"2":{"52":1}}],["下面实现查找target节点",{"2":{"34":1}}],["下面实现一个时间复杂度为o",{"2":{"3":1,"7":1}}],["忽略其一些属性和方法来达到栈的状态",{"2":{"52":1}}],["忽略t",{"2":{"18":1}}],["出栈",{"2":{"52":1,"54":1}}],["出入栈示意图",{"2":{"52":1}}],["出队",{"2":{"49":1,"50":1}}],["出队的时候",{"2":{"49":1}}],["取之前的值并乘上",{"2":{"74":1}}],["取模操作除外",{"2":{"60":1}}],["取模等",{"2":{"60":1}}],["取球只能从顶部一个一个拿出来",{"2":{"52":1}}],["取得原本链表头节点后面的节点",{"2":{"31":1}}],["认识栈",{"0":{"52":1}}],["容器式",{"2":{"51":1}}],["容量已满",{"2":{"47":1}}],["进栈和出栈",{"2":{"51":1}}],["越过数组尾部后回到头部",{"2":{"50":1}}],["使实现的栈对外仅保持栈的特性",{"2":{"53":1}}],["使其重新回到数组头部",{"2":{"50":1}}],["使用",{"2":{"58":3,"68":1}}],["使用extend方法将两个列表组合成一个列表",{"2":{"46":1}}],["使用insert",{"2":{"44":1}}],["使用next建立引用关系",{"2":{"30":1}}],["使用rust定义的链表结构体",{"2":{"28":1}}],["同时也代表队列的",{"2":{"50":1}}],["同时队尾又可以不断加入需要结账的人",{"2":{"48":1}}],["代表数组的第一个元素下标",{"2":{"50":1}}],["代码实现",{"2":{"49":1,"50":1}}],["定义一个front",{"2":{"50":1}}],["始终满足size",{"2":{"50":1}}],["换句话说我们不实现数组的所有特性来实现队列",{"2":{"50":1}}],["屏蔽",{"2":{"50":1}}],["本质上就是对二者一些",{"2":{"53":1}}],["本质上就是",{"2":{"50":1}}],["就再也不会改变",{"2":{"73":1}}],["就隐式地返回单元值",{"2":{"64":1}}],["就让头节点的下一个节点作为新的节点",{"2":{"49":1}}],["就把老节点的指针指向传入的节点",{"2":{"49":1}}],["匹配当前队列的尾节点",{"2":{"49":1}}],["q",{"2":{"49":5,"50":12}}],["queue",{"2":{"49":2}}],["world",{"2":{"66":2}}],["wrapping",{"2":{"58":2}}],["warn",{"2":{"49":1}}],["while",{"2":{"22":1}}],["dead",{"2":{"49":1}}],["debug",{"2":{"49":2,"54":1}}],["derive",{"2":{"49":2,"54":1}}],["del",{"2":{"47":2}}],["delete",{"2":{"5":1,"32":1,"47":1}}],["二者都可以通过链表和数组来实现",{"2":{"48":1}}],["二分查找等都主要在数组上进行",{"2":{"12":1}}],["队首指针向后移动1",{"2":{"50":1}}],["队首指针",{"2":{"50":1}}],["队首",{"2":{"50":1}}],["队首完成结账后离开队列",{"2":{"48":1}}],["队列已满",{"2":{"50":1}}],["队列为空",{"2":{"50":1}}],["队列容量",{"2":{"50":1}}],["队列长度减一",{"2":{"49":1}}],["队列长度加一",{"2":{"49":1}}],["队列长度",{"2":{"49":1,"50":1}}],["队列示意图",{"2":{"48":1}}],["队列与栈的差异在于栈遵循",{"2":{"48":1}}],["队列",{"2":{"12":1,"13":1,"14":1,"15":2}}],["即可完成更改",{"2":{"74":1}}],["即全部小写单词",{"2":{"66":1}}],["即只有单向出口",{"2":{"48":1}}],["即第二节点",{"2":{"31":1}}],["原则",{"2":{"48":1}}],["先进后出",{"2":{"48":1}}],["先根据扩容倍数创建一个更大的数组",{"2":{"47":1}}],["实际上",{"2":{"52":1}}],["实现简单结构的队列",{"0":{"48":1}}],["实时标识列表内的元素的数量",{"2":{"47":1}}],["超出索引",{"2":{"47":3}}],["unit",{"2":{"64":2}}],["unwrap",{"2":{"49":2,"52":2,"54":2}}],["u128",{"2":{"58":1}}],["u16",{"2":{"58":1}}],["u64",{"2":{"58":1}}],["u32",{"2":{"58":1}}],["u8的取值范围则是",{"2":{"58":1}}],["u8",{"2":{"58":1,"64":3}}],["update",{"2":{"47":1}}],["use",{"2":{"28":1,"49":1,"54":2}}],["usize>",{"2":{"7":1}}],["usize",{"2":{"4":1,"5":1,"8":1,"47":10,"49":1,"50":3,"54":3,"58":2}}],["获取栈长度",{"2":{"52":1,"54":1}}],["获取栈顶元素",{"2":{"52":1,"54":1}}],["获取队首元素",{"2":{"50":1}}],["获取队列的长度",{"2":{"50":1}}],["获取队列的容量",{"2":{"50":1}}],["获取队列长度",{"2":{"49":1}}],["获取头节点的下一个节点",{"2":{"49":1}}],["获取头节点",{"2":{"49":1}}],["获取列表长度",{"2":{"47":1}}],["获取列表容量",{"2":{"47":1}}],["获得要删除节点后面的节点",{"2":{"32":1}}],["获得要删除的节点",{"2":{"32":1}}],["构造函数",{"2":{"47":1}}],["若插入元素时列表容量已满",{"2":{"47":1}}],["扩容列表",{"2":{"47":1}}],["扩容",{"2":{"47":1}}],["扩容机制",{"2":{"47":1}}],["扩容数组需要重新分配一块更大的内存空间",{"2":{"8":1}}],["扩容数组",{"0":{"8":1}}],["相较于mut声明的变量x",{"2":{"74":1}}],["相较于let声明可以使用函数调用结果",{"2":{"73":1}}],["相较于变量而言",{"2":{"73":1}}],["相应修改该标记",{"2":{"47":1}}],["相关代码如下",{"2":{"24":1}}],["虽然在多数情况下编译器能够推测出我们想要使用的类型",{"2":{"56":1}}],["虽然许多的高级语言都已经封装了列表的实现以及一系列的方法",{"2":{"47":1}}],["虽然打印程序需要循环1000次",{"2":{"21":1}}],["拼接在尾部",{"2":{"46":1}}],["注意",{"2":{"46":1}}],["组合列表",{"0":{"46":1}}],["直接使用x=",{"2":{"74":1}}],["直接使用封装的api操作",{"2":{"45":1}}],["直接创建",{"2":{"65":1}}],["直接访问",{"2":{"6":1}}],["排序列表",{"0":{"45":1}}],["排序和搜索",{"2":{"12":1}}],["清空列表",{"2":{"44":1}}],["9",{"2":{"44":1}}],["跟数组一样",{"2":{"43":1}}],["更新元素",{"2":{"42":1,"47":1}}],["mian",{"2":{"70":1,"71":1}}],["map",{"2":{"49":1,"54":1}}],["match",{"2":{"49":2,"54":1}}],["main",{"2":{"41":1,"59":1,"60":1,"62":1,"66":2,"67":1,"68":1,"72":2,"74":2}}],["mylist",{"2":{"47":2}}],["mut变量直接再赋值时不允许改变变量的类型",{"2":{"74":1}}],["mut",{"2":{"4":1,"5":1,"8":2,"18":1,"22":2,"23":1,"24":1,"25":1,"26":2,"27":1,"30":2,"31":3,"32":3,"33":1,"34":1,"43":1,"47":2,"49":4,"50":2,"52":1,"54":2,"72":1,"74":3}}],["后续会有",{"2":{"41":1}}],["动态数组在完美继承数组的所有特点的同时",{"2":{"39":1}}],["动态数组dynamic",{"2":{"39":1}}],["动态参数",{"2":{"33":1,"34":1}}],["长度",{"2":{"58":1}}],["长度和扩容问题显然使得实现后得列表具有较大缺陷",{"2":{"39":1}}],["长度不可表",{"2":{"35":1}}],["长度不可变",{"2":{"11":1}}],["倘若使用数组来实现列表",{"2":{"39":1}}],["而使用shadow通过let再次声明则不限制数据类型",{"2":{"74":1}}],["而shadow需要使用let再次声明才能更改x的值",{"2":{"74":1}}],["而不能是函数调用的结果或是只能在运行时计算得到的值",{"2":{"73":1}}],["而代码的另一部分更改了该值",{"2":{"72":1}}],["而声明可变时",{"2":{"72":1}}],["而采取一种二进制补码的方式将该数值转换为该类型取值范围内的最小值",{"2":{"58":1}}],["而数组或者链表可以在任何位置添加和删除数据",{"2":{"53":1}}],["而数组可以看作一个长度固定的列表",{"2":{"39":1}}],["而队列更像生活中的排队结账",{"2":{"48":1}}],["而链表则是分散的",{"2":{"15":1}}],["灵活程度远高于链表和数组",{"2":{"39":1}}],["列表长度",{"2":{"47":1}}],["列表的实现原理",{"0":{"47":1}}],["列表的常用操作",{"0":{"40":1},"1":{"41":1,"42":1,"43":1,"44":1,"45":1,"46":1}}],["列表是一种抽象的数据结构概念",{"2":{"39":1}}],["列表",{"0":{"39":1}}],["视频播放器中",{"2":{"38":1}}],["也可能会使用环形链表",{"2":{"38":1}}],["也就意味着分配的内存空间大是固定的",{"2":{"8":1}}],["它允许我们将",{"2":{"64":1,"65":1}}],["它需要对一组进程进行循环",{"2":{"38":1}}],["它表现的特性为先进先出",{"2":{"38":1}}],["它表现的特性为先进后出",{"2":{"38":1}}],["调度算法",{"2":{"38":1}}],["浏览器需要知道用户访问过的前一个和后一个网页",{"2":{"38":1}}],["浏览器历史",{"2":{"38":1}}],["比如一筒羽毛球",{"2":{"52":1}}],["比如在音频",{"2":{"38":1}}],["比如在红黑树",{"2":{"38":1}}],["比如操作系统的资源调度",{"2":{"38":1}}],["比如以上代码中的链表可记作链表",{"2":{"30":1}}],["高级数据结构",{"2":{"38":1}}],["其他位置插入的时间复杂度为o",{"2":{"44":1}}],["其中图的每个顶点都与一个链表相关联",{"2":{"38":1}}],["其长度就固定了",{"2":{"0":1}}],["邻接表是表示图的一种常用方式",{"2":{"38":1}}],["链式地址是解决哈希冲突的主流方案之一",{"2":{"38":1}}],["链表节点类",{"2":{"54":1}}],["链表节点由值和指针两部分组成",{"2":{"28":1}}],["链表实现队列",{"0":{"49":1}}],["链表本身就一个列表",{"2":{"39":1}}],["链表中的每个元素都代表与该顶点相连的其他顶点",{"2":{"38":1}}],["链表中插入节点",{"2":{"31":1}}],["链表vs数组",{"0":{"35":1}}],["链表访问元素则相对复杂",{"2":{"33":1}}],["链表的类型及应用",{"0":{"36":1},"1":{"37":1,"38":1}}],["链表的头节点",{"2":{"31":1}}],["链表的每个节点对象由引用",{"2":{"28":1}}],["链表相关操作",{"0":{"29":1},"1":{"30":1,"31":1,"32":1,"33":1,"34":1}}],["链表结构体",{"2":{"28":1,"49":1,"54":1}}],["链表结构体说明",{"2":{"28":1}}],["链表示意图",{"2":{"28":1}}],["链表需要的空间比数组更多",{"2":{"28":1}}],["链表是一种线性数据结构",{"2":{"28":1}}],["链表简介",{"0":{"28":1}}],["链表",{"2":{"13":1,"14":1}}],["各类链表的应用",{"0":{"38":1}}],["尾插法添加新元素的时候需要遍历链表至尾节点来实现",{"2":{"54":1}}],["尾既是头",{"2":{"37":1}}],["尾节点都指向该节点",{"2":{"49":1}}],["尾节点",{"2":{"49":1}}],["尾节点指向空none",{"2":{"37":1}}],["尾节点结束",{"2":{"37":1}}],["头节点",{"2":{"49":1}}],["头节点和尾节点相连接形成闭环的链表",{"2":{"37":1}}],["头既是尾",{"2":{"37":1}}],["头尾的概念也就消失了",{"2":{"37":1}}],["环形链表常用于需要周期性操作的场景",{"2":{"38":1}}],["环形链表",{"2":{"37":1}}],["由头节点开始",{"2":{"37":1}}],["由于列表继承数组特性",{"2":{"42":1}}],["由于其动态扩容性",{"2":{"39":1}}],["由于数组在创建时的长度固定",{"2":{"8":1}}],["由于",{"2":{"2":1}}],["最后一个不同点是常量只能设置为常量表达式",{"2":{"73":1}}],["最普遍的链表类型",{"2":{"37":1}}],["最高阶对时间增长的趋势的影响是其他项所不能相比的",{"2":{"19":1}}],["占用空间大",{"2":{"35":1}}],["占用空间小",{"2":{"35":1}}],["但函数可以通过返回值赋值给变量",{"2":{"70":1}}],["但大部分函数隐式的返回最后的表达式所计算的值",{"2":{"68":1}}],["但当你明确元素数量不需要改变时",{"2":{"65":1}}],["但将会得到非期望的值",{"2":{"58":1}}],["但随着程序的庞大和复杂",{"2":{"56":1}}],["但只有单向出口",{"2":{"51":1}}],["但是为了更好的理解深层原理",{"2":{"47":1}}],["但分配较大时会造成浪费",{"2":{"35":1}}],["但打印函数的执行时间固定",{"2":{"21":1}}],["分隔",{"2":{"67":1}}],["分别对应f32和f64",{"2":{"59":1}}],["分别对应头插法和尾插法",{"2":{"54":1}}],["分散存储",{"2":{"35":1}}],["分裂n轮后有",{"2":{"26":1}}],["分裂两轮后变为4个",{"2":{"26":1}}],["分裂一轮后变为2个",{"2":{"26":1}}],["`usize`",{"2":{"74":1}}],["`",{"2":{"35":2,"60":2,"74":1}}],["具体原因为",{"2":{"72":1}}],["具体因为这样可以告诉编译器你的意图而不需编译器在其他代码部分使用到参数时不明确",{"2":{"67":1}}],["具体如下图所示",{"2":{"35":1}}],["具有更高的灵活性",{"2":{"74":1}}],["具有返回值的函数",{"0":{"68":1}}],["具有参数的函数",{"0":{"67":1}}],["具有显示声明的bool类型",{"2":{"61":1}}],["具有线性关系还是非线性关系",{"2":{"14":1}}],["效率",{"2":{"35":1}}],["效率较低",{"2":{"11":1}}],["plus2",{"2":{"70":2,"71":1}}],["plus1",{"2":{"70":2}}],["plus",{"2":{"67":2,"68":2,"71":1,"73":3}}],["pop",{"2":{"49":1,"50":1,"52":1,"54":1}}],["peek|",{"2":{"49":1}}],["peek",{"2":{"49":9,"50":4,"54":9}}],["panic",{"2":{"47":1,"65":1,"70":1,"73":1}}],["partialeq>",{"2":{"34":1}}],["pub",{"2":{"47":9,"49":9,"50":8,"54":6}}],["push",{"2":{"44":2,"49":1,"50":1,"52":4,"54":1}}],["preek",{"2":{"49":2}}],["prev",{"2":{"32":5}}],["println",{"2":{"6":2,"18":2,"21":2,"47":4,"50":2,"60":9,"64":2,"65":4,"66":2,"67":1,"68":1,"72":4,"74":2}}],["目标链表元素",{"2":{"34":1}}],["返回值的类型需要在声明函数时就进行标志",{"2":{"68":1}}],["返回被删除的元素",{"2":{"47":1}}],["返回此时的索引",{"2":{"34":1}}],["返回其索引的方法",{"2":{"34":1}}],["返回空\\t\\t\\t\\t\\t\\t\\t\\t\\t",{"2":{"32":1}}],["这对于代码中很多部分都需要知道一个值的情况特别有用",{"2":{"73":1}}],["这可以使得代码更容易理解",{"2":{"72":1}}],["这可以通过在节点中保存一个指向父节点的引用来实现",{"2":{"38":1}}],["这个程序首先将数值",{"2":{"74":1}}],["这个概念",{"2":{"73":1}}],["这个",{"2":{"72":1}}],["这点很重要",{"2":{"72":1}}],["这一特征让你充分利用",{"2":{"72":1}}],["这意味着在编译期就需要知道所有值的类型",{"2":{"56":1}}],["这里主要介绍两大类数据类型",{"2":{"56":1}}],["这里使用头插法来不断替换链表的头节点实现栈",{"2":{"54":1}}],["这里通过取余计算",{"2":{"50":1}}],["这里通过固定的倍率来创建更大的新数组",{"2":{"47":1}}],["这里着手实现一个简易列表",{"2":{"47":1}}],["这里是访问所有的元素",{"2":{"33":1}}],["这种循环操作可以通过环形链表来实现",{"2":{"38":1}}],["这时候使用双向链表就非常合适",{"2":{"38":1}}],["这些数据都是以数组的形式构建的",{"2":{"12":1}}],["控制访问范围",{"2":{"33":1}}],["索引访问数组的元素",{"2":{"65":1}}],["索引越界",{"2":{"47":1}}],["索引",{"2":{"33":1,"34":1,"64":1}}],["索引从0开始",{"2":{"3":1,"65":1}}],["起始为头节点",{"2":{"33":1,"34":1}}],["起始节点称为头节点",{"2":{"28":1}}],["遍历列表元素",{"0":{"43":1}}],["遍历每个节点",{"2":{"33":1}}],["遍历数组可以使用索引index来获取元素本身",{"2":{"6":1}}],["遍历数组",{"0":{"6":1}}],["访问数组的元素",{"2":{"65":1}}],["访问数组元素",{"0":{"3":1}}],["访问",{"2":{"64":1}}],["访问元组",{"2":{"64":1}}],["访问元素",{"2":{"42":1}}],["访问索引",{"2":{"42":1}}],["访问列表元素",{"0":{"42":1},"2":{"47":1}}],["访问链表中的元素需要从头节点出发",{"2":{"33":1}}],["访问节点",{"0":{"33":1}}],["我们直接调用即可",{"2":{"41":1}}],["我们需要快速找到最近最少使用的数据",{"2":{"38":1}}],["我们需要访问节点的父节点",{"2":{"38":1}}],["我们就认为这个节点从链表中删除了",{"2":{"32":1}}],["我们通常将头节点当作链表的代称",{"2":{"30":1}}],["只需要取消删除节点上一个节点对其的引用",{"2":{"32":1}}],["删除头节点",{"2":{"49":1}}],["删除位置后的元素向前移一位",{"2":{"47":1}}],["删除指定索引处的元素",{"2":{"44":1}}],["删除操作在链表的另一端进行",{"2":{"38":1}}],["删除链表节点相较于插入操作更简单",{"2":{"32":1}}],["删除节点的前一节点",{"2":{"32":1}}],["删除节点",{"0":{"32":1}}],["删除元素需要将删除位置后面的元素都往前移动一位",{"2":{"5":1}}],["删除元素",{"0":{"5":1},"2":{"44":1,"47":1}}],["需插入节点",{"2":{"31":1}}],["需要存储指针引用",{"2":{"35":1}}],["需要执行n",{"2":{"33":1}}],["需要将插入位置前一个节点的引用指向该节点",{"2":{"31":1}}],["需要先计算出算法的操作数函数t",{"2":{"18":1}}],["需要注意的是",{"2":{"15":1}}],["需要遍历数组",{"2":{"7":1}}],["需要把插入位置后面的元素全部向后移一位",{"2":{"4":1}}],["建立节点间的引用关系",{"2":{"30":1}}],["variants",{"2":{"73":1}}],["variable",{"2":{"72":1}}],["vaue",{"2":{"44":1}}],["val",{"2":{"34":1,"54":2}}],["value",{"2":{"28":1,"30":3,"47":6,"49":3,"64":1,"67":1,"68":1,"74":2}}],["vec3",{"2":{"46":2}}],["vec2",{"2":{"41":1,"42":1,"43":3}}],["vec1",{"2":{"41":1}}],["vec",{"2":{"8":1,"41":4,"46":1,"47":16,"50":2,"52":1}}],["vector",{"2":{"2":2,"65":3}}],["\\tconst",{"2":{"73":2}}],["\\tcount",{"2":{"43":1}}],["\\tlet",{"2":{"52":3,"73":1}}],["\\tstack",{"2":{"52":5}}],["\\tstruct",{"2":{"28":1}}],["\\timpl",{"2":{"47":1}}],["\\tvec2",{"2":{"44":4,"46":1}}],["\\tfor",{"2":{"43":2}}],["\\tfn",{"2":{"31":1,"32":1,"33":1,"34":1,"73":1}}],["\\t删除元素",{"2":{"35":1}}],["\\t添加元素",{"2":{"35":1}}],["\\t访问元素",{"2":{"35":1}}],["\\t内存效率",{"2":{"35":1}}],["\\t扩容",{"2":{"35":1}}],["\\t存储方式",{"2":{"35":1}}],["\\t\\t\\t",{"2":{"47":1}}],["\\t\\t\\tlet",{"2":{"47":3}}],["\\t\\tif",{"2":{"47":1}}],["\\t\\t数组",{"2":{"35":1}}],["\\t\\t链表",{"2":{"35":1}}],["\\t\\t",{"2":{"31":1,"32":1,"74":1}}],["\\t\\tlet",{"2":{"30":1,"72":2}}],["\\t",{"2":{"28":2,"30":1,"31":3,"32":4,"33":3,"34":4,"35":3,"41":1,"43":2,"44":3,"47":3,"52":6,"72":2,"73":3,"74":1}}],["还允许在程序运行时进行动态扩容",{"2":{"39":1}}],["还要声明一个引用计数器",{"2":{"28":1}}],["还会缓存其周围的其他数据",{"2":{"10":1}}],["结束节点称为尾节点",{"2":{"28":1}}],["每个放进的球只能在顶部",{"2":{"52":1}}],["每个进程被赋予一个时间片",{"2":{"38":1}}],["每个节点散落分布在内存空间中",{"2":{"28":1}}],["每一个对象节点都存储两个方向的指针",{"2":{"37":1}}],["每一层循环依然可以分别套用第",{"2":{"18":1}}],["和数组",{"2":{"63":1}}],["和大多数语言一样",{"2":{"61":1}}],["和",{"2":{"34":1,"41":1,"53":1,"58":1,"68":1}}],["和值组成",{"2":{"28":1}}],["和o",{"2":{"24":1}}],["空间上对比二者的存储方式",{"2":{"35":1}}],["空间效率高",{"2":{"10":1}}],["空闲的内存空间并非都是连续的",{"2":{"28":1}}],["然而当需要的空间比较大时",{"2":{"28":1}}],["然后通过重复使用",{"2":{"74":1}}],["然后赋值给x",{"2":{"71":1}}],["然后调用",{"2":{"66":1}}],["然后将该节点的引用指向插入位置的下一个节点",{"2":{"31":1}}],["然后把原数组中的元素复制到新空间中",{"2":{"8":1}}],["然后根据数组元素的类型和数量来确定数组的大小",{"2":{"2":1}}],["个",{"2":{"27":1}}],["个分裂出",{"2":{"27":1}}],["从0开始",{"2":{"64":1}}],["从栈顶取出元素的操作",{"2":{"52":1}}],["从当前队列头节点开始遍历",{"2":{"49":1}}],["从头节点向后依次访问",{"2":{"34":1}}],["从头节点出发",{"2":{"33":1}}],["从",{"2":{"27":1}}],["从而借助高速缓存来提升后续操作的执行速度",{"2":{"10":1}}],["递归实现",{"2":{"27":1}}],["∗1rust",{"2":{"27":1}}],["∗",{"2":{"27":2}}],["方向单一",{"2":{"37":1}}],["方案数量为",{"2":{"27":1}}],["方法使值达到最小值或最大值",{"2":{"58":1}}],["方法返回该值和一个指示是否存在溢出的布尔值",{"2":{"58":1}}],["方法时发生溢出",{"2":{"58":1}}],["方法在所有模式下进行包裹",{"2":{"58":1}}],["方法",{"2":{"2":1,"53":1}}],["求其所有可能的排列方案",{"2":{"27":1}}],["给定",{"2":{"27":1}}],["问题",{"2":{"27":1}}],["全排列",{"2":{"27":1}}],["阶乘阶",{"2":{"27":1}}],["阶乘阶对应数学上的",{"2":{"27":1}}],["阶乘",{"0":{"27":1}}],["8位",{"2":{"58":1}}],["8",{"2":{"26":2,"46":1}}],["形成数列",{"2":{"26":1}}],["细胞每轮一分为二",{"2":{"26":1}}],["细胞分裂",{"2":{"26":1}}],["bug",{"2":{"72":2}}],["byte",{"2":{"62":1}}],["bob",{"2":{"65":2}}],["bool",{"2":{"50":1,"54":1,"61":1}}],["borrow",{"2":{"30":2,"31":3,"32":4,"33":1,"34":2,"49":2,"54":2}}],["b",{"2":{"38":1}}],["base",{"2":{"26":3}}],["brr",{"2":{"2":1}}],["生物学的",{"2":{"26":1}}],["指向下一节点的指针",{"2":{"54":1}}],["指向队尾索引",{"2":{"50":1}}],["指定值",{"2":{"68":1}}],["指定位置插入",{"2":{"44":1}}],["指定长度时",{"2":{"2":1}}],["指针",{"2":{"28":1}}],["指数阶",{"0":{"26":1},"2":{"26":1}}],["外层循环和内层循环的时间复杂度都为o",{"2":{"25":1}}],["平方阶通常出现在嵌套循环中",{"2":{"25":1}}],["平方阶的操作数量相对于输入数据大小n以平方级别增长",{"2":{"25":1}}],["平方阶",{"0":{"25":1}}],["两层循环的时间复杂度分别为",{"2":{"24":1}}],["center>",{"2":{"73":1}}],["center>一个常量声明的例子",{"2":{"73":1}}],["cell",{"2":{"28":1,"49":1,"54":1}}],["calls",{"2":{"73":1}}],["cannot",{"2":{"72":1}}],["carol",{"2":{"65":2}}],["cat",{"2":{"62":1}}],["capacity",{"2":{"47":14,"50":12}}],["char",{"2":{"62":2}}],["checked",{"2":{"58":1}}],["cur",{"2":{"49":2}}],["const声明只能使用常量表达式",{"2":{"73":1}}],["constants",{"2":{"73":1}}],["constant",{"2":{"73":2}}],["code",{"2":{"49":1,"72":1}}],["counting",{"2":{"28":1}}],["count",{"2":{"22":3,"23":2,"24":3,"25":2,"26":4,"27":3,"43":3}}],["c",{"2":{"47":2,"62":1}}],["clear",{"2":{"44":1}}],["clone",{"2":{"30":2,"33":1,"34":1,"49":3}}],["cpu",{"2":{"38":2}}],["crr",{"2":{"2":1}}],["与输入数据n无关",{"2":{"21":1}}],["常量声明必须标注类型",{"2":{"73":1}}],["常量可以在任意作用域内声明",{"2":{"73":1}}],["常量用const声明",{"2":{"73":1}}],["常量一旦声明",{"2":{"73":1}}],["常量不存在",{"2":{"73":1}}],["常量",{"0":{"73":1}}],["常数阶o",{"0":{"21":1}}],["常见的复合类型又元组",{"2":{"63":1}}],["常见的链表类型",{"0":{"37":1}}],["常见的数据类型有",{"2":{"13":1}}],["常见时间复杂度类型图",{"2":{"20":1}}],["常见时间复杂度类型",{"0":{"20":1},"1":{"21":1,"22":1,"23":1,"24":1,"25":1,"26":1,"27":1}}],["趋势",{"2":{"20":1}}],["gt",{"2":{"19":1,"68":1}}],["gen",{"2":{"3":1}}],["get",{"2":{"3":1,"47":3}}],["操作数",{"2":{"19":1}}],["判断栈是否空",{"2":{"54":1}}],["判断栈是否为空",{"2":{"52":1}}],["判断队列长度是否为0",{"2":{"50":1}}],["判断队列是否为空",{"2":{"49":1}}],["判断渐进上界",{"0":{"19":1}}],["判断操作数函数的渐进上界",{"2":{"17":1}}],["j",{"2":{"18":1,"25":1}}],["技巧",{"2":{"18":4}}],["点的技巧",{"2":{"18":1}}],["点和第",{"2":{"18":1}}],["总操作数量等于外层循环和内层循环操作数量之积",{"2":{"18":1}}],["循环到栈尾实现出栈",{"2":{"54":1}}],["循环实现",{"2":{"22":1,"26":1}}],["循环嵌套时使用乘法",{"2":{"18":1}}],["循环2n次",{"2":{"18":1}}],["都可以简化记为n次",{"2":{"18":1}}],["省略所有系数",{"2":{"18":1}}],["所有冲突的元素都会被放到一个链表中",{"2":{"38":1}}],["所有的数据结构都可以基于数组或者链表",{"2":{"15":1}}],["所以",{"2":{"74":1}}],["所以你不必亲自跟踪这个值",{"2":{"72":1}}],["所以输出2",{"2":{"60":1}}],["所以时间复杂度为o",{"2":{"33":1}}],["所以对时间复杂度不产生影响",{"2":{"18":1}}],["因为这种情况很可能导致",{"2":{"72":1}}],["因为在第二行第一次声明该变量时",{"2":{"72":1}}],["因为链表节点间指针引用的单向性",{"2":{"32":1}}],["因为它们都与n无关",{"2":{"18":1}}],["因链表节点除存储值外还存储引用",{"2":{"28":1}}],["因此语句不能赋值给变量",{"2":{"70":1}}],["因此声明数据时进行类型标注是有必要的",{"2":{"56":1}}],["因此想要通过二者实现栈",{"2":{"53":1}}],["因此想获得算法的时间复杂度",{"2":{"18":1}}],["因此引入",{"2":{"39":1}}],["因此引入链表这种相较于数组更灵活的数据结构",{"2":{"28":1}}],["因此在定义节点对象时",{"2":{"28":1}}],["因此在相同数据量下",{"2":{"28":1}}],["因此总体的时间复杂度为",{"2":{"25":1}}],["因此该算法的时间复杂度是常数阶",{"2":{"21":2}}],["因此该算法的的时间复杂度",{"2":{"19":1}}],["因此只能使用常量来指定长度",{"2":{"2":1}}],["🎉一些推算操作数的技巧",{"2":{"18":1}}],["渐进上界",{"2":{"18":1}}],["of",{"2":{"74":2}}],["or",{"2":{"68":1}}],["overflowing",{"2":{"58":1}}],["ok",{"2":{"49":1,"54":1}}],["old",{"2":{"49":2,"54":2}}],["one",{"2":{"32":1}}],["o",{"2":{"18":1,"19":8,"24":1,"25":1,"35":6}}],["option",{"2":{"7":1,"28":1,"49":3,"54":4}}],["通常适用于一些永远不会改变的值",{"2":{"73":1}}],["通常将线性时间复杂度记为",{"2":{"18":1}}],["通过重复使用let声明实现遮蔽变量",{"2":{"74":1}}],["通过运行上述代码",{"2":{"72":1}}],["通过",{"2":{"64":1,"65":1}}],["通过链表实现栈要考虑使用链表的头节点还是尾节点作为栈顶",{"2":{"54":1}}],["通过取余操作实现",{"2":{"50":1}}],["通过对数据结构在逻辑层面和物理层面上的不同理解",{"2":{"16":1}}],["通过索引访问",{"2":{"6":1}}],["通过索引index访问数组中的元素",{"2":{"3":1}}],["时间内完成操作",{"2":{"44":1}}],["时间内访问任意元素",{"2":{"33":1}}],["时间片轮转调度算法是一种常见的",{"2":{"38":1}}],["时间片轮转调度算法",{"2":{"38":1}}],["时间上对比它们的操作方法的时间复杂度",{"2":{"35":1}}],["时间增长趋势",{"0":{"18":1}}],["时间复杂度为2^n",{"2":{"26":1}}],["时间复杂度为o",{"2":{"11":1,"34":1}}],["时间复杂度类型是根据输入数据n的大小与算法执行时间",{"2":{"20":1}}],["时间复杂度由t",{"2":{"19":1}}],["时间复杂度",{"0":{"17":1},"2":{"19":1}}],["或推断",{"2":{"17":1}}],["或者二者组合而实现",{"2":{"15":1}}],["或者直接遍历元素本身",{"2":{"6":1}}],["根据传入的入队元素",{"2":{"49":1}}],["根据",{"2":{"17":1}}],["根据索引实现随机抽样",{"2":{"12":1}}],["计算并产生一个值",{"2":{"69":1}}],["计算队尾指针",{"2":{"50":1}}],["计算时间复杂度通常需要两个步骤",{"2":{"17":1}}],["计算机不仅会加载它",{"2":{"10":1}}],["应选择合适的容量",{"2":{"47":1}}],["应该搞清楚以下概念",{"2":{"47":1}}],["应该深度的学习每一种数据结构类型",{"2":{"16":1}}],["应为当n趋于无穷大是",{"2":{"19":1}}],["应用",{"0":{"12":1}}],["要显式处理溢出的可能性",{"2":{"58":1}}],["要想真正地理解数据",{"2":{"16":1}}],["要考虑末端元素将失效",{"2":{"4":1}}],["对应入栈",{"2":{"52":1}}],["对应出栈",{"2":{"52":1}}],["对应队列",{"2":{"38":1}}],["对应栈",{"2":{"38":1}}],["对应的元素存放在数组中的对应位置",{"2":{"12":1}}],["对比链表和数组从空间和时间上出发",{"2":{"35":1}}],["对数阶",{"2":{"22":1}}],["对数阶o",{"0":{"22":1}}],["对数据结构的种类",{"2":{"16":1}}],["小结",{"0":{"16":1}}],["等",{"2":{"15":1}}],["维度",{"2":{"15":1}}],["张量",{"2":{"15":1}}],["张量之间的线性代数运算",{"2":{"12":1}}],["物理结构是指数据在内存中的存储方式是连续的还是非连续的",{"2":{"15":1}}],["物理结构",{"0":{"15":1}}],["算法中",{"2":{"38":1}}],["算法属于线性阶",{"2":{"23":1}}],["算法属于对数阶",{"2":{"22":1}}],["算法属于常数阶",{"2":{"21":1}}],["算法函数的时间增长趋势",{"2":{"17":1}}],["算法",{"2":{"14":1,"15":1,"38":1}}],["非网状结构",{"2":{"14":1}}],["非线性数据结构又可以分为",{"2":{"14":1}}],["非线性数据结构",{"2":{"14":1}}],["网状结构",{"2":{"14":1}}],["网状结构和非网状结构",{"2":{"14":1}}],["线性对数阶常出现于嵌套循环中",{"2":{"24":1}}],["线性对数阶",{"0":{"24":1},"2":{"24":1}}],["线性阶o",{"0":{"23":1}}],["线性数据结构",{"2":{"14":1}}],["线性和非线性",{"0":{"14":1}}],["逻辑结构主要是描述数据之间的逻辑关系",{"2":{"14":1}}],["逻辑结构",{"0":{"14":1}}],["逻辑结构和物理结构",{"2":{"13":1}}],["​理解数据机构可以从两个层面理解",{"2":{"13":1}}],["树中",{"2":{"38":1}}],["树",{"2":{"13":1,"14":2,"15":2}}],["栈只能在栈顶添加和删除元素",{"2":{"53":1}}],["栈的实现",{"0":{"53":1},"1":{"54":1,"55":1}}],["栈顶被清空",{"2":{"54":1}}],["栈顶",{"2":{"51":1}}],["栈与队列",{"2":{"38":1}}],["栈",{"0":{"51":1},"2":{"13":1,"14":1,"15":2,"51":1,"52":1}}],["存储队列元素的数组",{"2":{"50":1}}],["存储空间更多但也更为灵活",{"2":{"37":1}}],["存储数组的空间是连续的",{"2":{"28":1}}],["存储链表的指针和数据通常是分开的",{"2":{"15":1}}],["存储结构并且封装相应操作方法的数据集合",{"2":{"13":1}}],["存储的数据类型相同",{"2":{"0":1}}],["图5",{"2":{"48":1}}],["图等",{"2":{"15":1}}],["图等数据结构",{"2":{"12":1}}],["图3",{"2":{"14":1,"15":1}}],["图选自",{"2":{"14":1,"15":1}}],["图",{"2":{"13":1,"14":2,"15":1,"38":1}}],["图的邻接矩阵表示实际上是一个二维数组",{"2":{"12":1}}],["例如",{"2":{"12":1,"18":1,"58":1}}],["堆",{"2":{"12":1,"13":1,"14":2,"15":2}}],["哈希表",{"2":{"12":1,"13":1,"14":3,"15":2,"38":1}}],["数字运算",{"0":{"60":1}}],["数量标记",{"2":{"47":1}}],["数据流可能会被分成多个缓冲块并放入一个环形链表",{"2":{"38":1}}],["数据缓冲区",{"2":{"38":1}}],["数据结构是在计算机中具有一定逻辑关系",{"2":{"13":1}}],["数据结构",{"0":{"13":1}}],["数据结构实现",{"2":{"12":1}}],["数组会更加高效",{"2":{"65":1}}],["数组中的元素数量和类型就不能改变",{"2":{"65":1}}],["数组中元素通过索引",{"2":{"0":1}}],["数组队列结构体",{"2":{"50":1}}],["数组实现队列",{"0":{"50":1},"2":{"50":2}}],["数组与链表的效率对比",{"2":{"35":1}}],["数组可以用于实现栈",{"2":{"12":1}}],["数组可通过索引在时间o",{"2":{"10":1}}],["数组是固定长度的",{"2":{"65":1}}],["数组是rust中一个重要的复合类型",{"2":{"65":1}}],["数组是神经网络编程中最常使用的数据结构",{"2":{"12":1}}],["数组是排序和搜索算法最常用的数据结构",{"2":{"12":1}}],["数组需要预先分配固定大小的内存空间",{"2":{"11":1}}],["数组为数据分配了连续的内存块",{"2":{"10":1}}],["数组的长度是固定的",{"2":{"11":1}}],["数组的插入和删除操作需要大量移动元素",{"2":{"11":1}}],["数组的优",{"0":{"9":1},"1":{"10":1,"11":1,"12":1}}],["数组的常见操作",{"0":{"1":1},"1":{"2":1,"3":1,"4":1,"5":1,"6":1,"7":1,"8":1}}],["数组将数据存储在计算机中一段连续的存储空间",{"2":{"0":1}}],["数组",{"0":{"0":1,"65":1},"2":{"13":1,"14":1}}],["矩阵",{"2":{"12":1,"15":1}}],["神经网络中大量使用了向量",{"2":{"12":1}}],["机器学习",{"2":{"12":1}}],["码值作为索引",{"2":{"12":1}}],["码的映射",{"2":{"12":1}}],["则返回",{"2":{"58":1}}],["则会发生整型溢出",{"2":{"58":1}}],["则会造成很大的开销",{"2":{"11":1}}],["则会造成浪费",{"2":{"11":1}}],["则更新栈顶为下一个元素",{"2":{"54":1}}],["则令头",{"2":{"49":1}}],["则需要进行扩容",{"2":{"47":1}}],["则可以将字符的",{"2":{"12":1}}],["假如我们想实现字符到",{"2":{"12":1}}],["可变",{"2":{"73":1}}],["可选地以表达式结尾",{"2":{"69":1}}],["可从函数中提前返回",{"2":{"68":1}}],["可以以表达式结尾来返回值",{"2":{"71":1}}],["可以接收参数",{"2":{"66":1}}],["可以使用标准库针对原始数字类型提供的以下一系列方法",{"2":{"58":1}}],["可以使用该语言的数组或者链表",{"2":{"52":1}}],["可以使用数组作为查找表",{"2":{"12":1}}],["可以理为一种具有双向数据方向",{"2":{"51":1}}],["可以不断加入新的节点",{"2":{"49":1}}],["可以通过索引或者直接访问列表元素的方式来遍历列表",{"2":{"43":1}}],["可以像访问数组元素那样通过索引在o",{"2":{"42":1}}],["可以动态扩展长度",{"2":{"39":1}}],["可基于链表和数组实现",{"2":{"39":1}}],["可扩展",{"2":{"35":1}}],["可能造成内存浪费",{"2":{"11":1}}],["查找链表节点是一种线性查找",{"2":{"34":1}}],["查找节点",{"0":{"34":1}}],["查找表",{"2":{"12":1}}],["查找元素",{"0":{"7":1}}],["归并排序",{"2":{"12":1}}],["快速排序",{"2":{"12":1}}],["并取原来的值加上",{"2":{"74":1}}],["并且必须标注常量类型",{"2":{"73":1}}],["并且按照一定的顺序排列",{"2":{"0":1}}],["并未标识其为可变",{"2":{"72":1}}],["并将头节点的下一节点作为新的头节点",{"2":{"49":1}}],["并根据与初始容量的比较决定是否扩容",{"2":{"47":1}}],["并传递动态head",{"2":{"34":1}}],["并生成一个随机序列",{"2":{"12":1}}],["随机访问",{"2":{"12":1}}],["如下所示",{"2":{"74":1}}],["如函数本身就是语句",{"2":{"71":1}}],["如let",{"2":{"64":1}}],["如u8时为256",{"2":{"58":1}}],["如将一个u8赋值",{"2":{"58":1}}],["如i8的取值范围为",{"2":{"58":1}}],["如数组可以从任意位置删除",{"2":{"50":1}}],["如数组在内存中的空间一般是连续的",{"2":{"15":1}}],["如果我们代码的一部分假设某个值永远不会更改",{"2":{"72":1}}],["如果我们想随机抽取一些样本",{"2":{"12":1}}],["如果尝试改变会发生什么",{"2":{"72":1}}],["如果不确定是使用数组还是",{"2":{"65":1}}],["如果不为空",{"2":{"49":1}}],["如果表达式不返回任何其他值",{"2":{"64":1}}],["如果使用",{"2":{"58":1}}],["如果存在会导致程序panic",{"2":{"58":1}}],["如果有下一个元素",{"2":{"54":1}}],["如果队列为空",{"2":{"49":1}}],["如果队列不为空",{"2":{"49":1}}],["如果只有头节点",{"2":{"32":1}}],["如果分配的空间超过需要存储的数据",{"2":{"11":1}}],["如需要扩容",{"2":{"11":1}}],["无符号类型表示的取值范围是",{"2":{"58":1}}],["无符号类型以u开头即unsigned",{"2":{"58":1}}],["无符号型",{"2":{"58":1}}],["无初始值",{"2":{"41":2}}],["无需全部解除头尾节点的引用",{"2":{"32":1}}],["无法动态调整",{"2":{"11":1}}],["无须额外的结构开销",{"2":{"10":1}}],["插入和删除元素",{"0":{"44":1}}],["插入和删除操作效率低",{"2":{"11":1}}],["插入节点",{"0":{"31":1}}],["插入元素",{"0":{"4":1},"2":{"50":1}}],["缺点",{"0":{"11":1}}],["缺点和应用",{"0":{"9":1},"1":{"10":1,"11":1,"12":1}}],["缓存局部性",{"2":{"10":1}}],["支持随机访问",{"2":{"10":1}}],["优点",{"0":{"10":1}}],["sapces",{"2":{"74":1}}],["saturating",{"2":{"58":1}}],["spaces",{"2":{"74":5}}],["scope",{"2":{"74":1}}],["shadow更加的灵活",{"2":{"74":1}}],["shadow更加不容易更改变量的值",{"2":{"74":1}}],["shadow",{"0":{"74":1},"2":{"74":1}}],["s",{"2":{"67":1,"68":1}}],["second",{"2":{"65":1}}],["self",{"2":{"47":40,"49":20,"50":24,"54":17}}],["srtuct",{"2":{"54":1}}],["statement",{"2":{"69":1}}],["stacklist",{"2":{"54":2}}],["stack",{"2":{"51":1,"52":5,"54":11}}],["str`",{"2":{"74":1}}],["str",{"2":{"65":1}}],["str表示每个元素的类型",{"2":{"65":1}}],["structs",{"2":{"73":1}}],["struct",{"2":{"49":2,"50":1,"54":1}}],["stk",{"2":{"54":1}}],["std",{"2":{"28":2,"49":2,"54":2}}],["slef",{"2":{"47":1}}],["sort",{"2":{"45":1}}],["some",{"2":{"7":1,"30":2,"31":1,"32":1,"33":1,"34":1,"49":4,"54":3}}],["square",{"2":{"25":1}}],["size",{"2":{"8":2,"47":14,"49":7,"50":10,"54":7}}],["7",{"0":{"8":1,"27":1}}],["x恢复为6",{"2":{"74":1}}],["xxxx",{"2":{"70":1}}],["x=",{"2":{"60":1}}],["x+y",{"2":{"60":1}}],["x+y=",{"2":{"60":1}}],["x",{"2":{"59":1,"60":10,"64":7,"68":3,"70":1,"71":1,"72":13,"73":2,"74":16}}],["x3c",{"2":{"7":1,"24":1,"28":3,"31":7,"32":4,"33":7,"34":4,"41":2,"47":1,"49":15,"50":1,"54":13,"73":2}}],["x26",{"2":{"2":2,"3":1,"4":1,"5":1,"6":1,"7":1,"8":1,"31":1,"32":1,"33":2,"34":2,"43":1,"47":8,"49":6,"50":6,"54":5,"65":2,"74":1}}],["to",{"2":{"72":1,"73":1}}],["top",{"2":{"52":1}}],["twice",{"2":{"72":1}}],["third",{"2":{"65":1}}],["the",{"2":{"65":4,"74":3}}],["thread",{"2":{"3":1}}],["type声明",{"2":{"68":1}}],["type",{"2":{"64":1}}],["tupl",{"2":{"64":5}}],["tupl2",{"2":{"64":1}}],["tupl1",{"2":{"64":2}}],["tuple",{"2":{"63":1,"73":2}}],["true",{"2":{"61":1}}],["true和false",{"2":{"61":1}}],["try",{"2":{"49":1,"54":1}}],["tagart元素对应索引",{"2":{"34":1}}],["take",{"2":{"31":1,"32":2,"49":4,"54":3}}],["target",{"2":{"7":2,"34":4}}],["t>>>>",{"2":{"54":2}}],["t>>>",{"2":{"32":1,"33":1,"34":1}}],["t>>",{"2":{"31":2,"33":1}}],["t>",{"2":{"31":1,"32":1,"33":1,"54":2}}],["t",{"2":{"18":1,"34":2,"54":1,"61":1}}],["tip",{"2":{"18":1,"19":1}}],["的值变成了",{"2":{"74":1}}],["的值组合在一起",{"2":{"64":1,"65":1}}],["的根源在实际开发中可能很难追踪",{"2":{"72":1}}],["的形式",{"2":{"66":1}}],["的编译期",{"2":{"58":1}}],["的主要应用场景是用作某些集合的索引",{"2":{"58":1}}],["的整型默认是",{"2":{"58":1}}],["的限制",{"2":{"53":1}}],["的数据结构",{"2":{"51":1}}],["的数组",{"2":{"15":1}}],["的数组访问函数",{"2":{"3":1}}],["的数组被设计为在编译期确定长度",{"2":{"2":1}}],["的",{"2":{"51":1,"62":1}}],["的变化来决定的",{"2":{"20":1}}],["的查找算法",{"2":{"7":1}}],["name",{"2":{"66":1}}],["names",{"2":{"65":6}}],["n代表该数据类型的位数",{"2":{"58":1}}],["no",{"2":{"60":1}}],["node",{"2":{"31":5,"32":10,"33":4,"34":4,"54":3}}],["none=>",{"2":{"49":2}}],["none",{"2":{"7":1,"30":3,"49":3,"54":3,"58":1}}],["n1",{"2":{"30":3,"31":2,"32":2}}],["n0",{"2":{"30":3}}],["next",{"2":{"28":1,"30":5,"31":3,"32":6,"33":1,"34":1,"49":4,"54":3}}],["new",{"2":{"8":3,"30":6,"41":1,"47":5,"49":12,"50":1,"52":1,"54":4}}],["n−2",{"2":{"27":1}}],["n−1",{"2":{"27":1}}],["n互不重复的元素",{"2":{"27":1}}],["n2",{"2":{"19":1,"30":2}}],["n^3",{"2":{"19":2}}],["n^2",{"2":{"19":2,"25":1}}],["n",{"0":{"22":1,"23":1},"2":{"7":1,"11":1,"18":10,"19":5,"21":2,"22":4,"23":2,"24":7,"25":4,"26":4,"27":6,"33":1,"34":1,"35":3,"44":1}}],["nums",{"2":{"4":5,"5":4,"42":1,"50":4}}],["num",{"2":{"4":4,"42":1,"49":4,"50":2,"54":2,"67":3,"68":3,"70":3,"71":2,"73":2}}],["知道找到对应值",{"2":{"7":1}}],["64位",{"2":{"58":1}}],["6",{"0":{"7":1,"26":1,"46":1},"2":{"41":1,"44":1,"46":1,"64":3,"70":1,"74":2}}],["last",{"2":{"47":2,"52":1}}],["lru",{"2":{"38":2}}],["limited",{"2":{"73":1}}],["lisstnode>>>",{"2":{"49":1}}],["lisstnode",{"2":{"30":3}}],["list",{"0":{"39":1},"2":{"30":1,"35":1,"47":3}}],["listnode>>>",{"2":{"28":1,"49":4,"54":1}}],["listnode",{"2":{"28":1,"31":2,"32":1,"33":1,"34":1,"49":3,"54":4}}],["link",{"2":{"30":1,"35":1}}],["linear",{"2":{"23":1,"24":3}}],["logarithmic",{"2":{"22":1}}],["log",{"0":{"22":1},"2":{"24":4}}],["loop",{"2":{"6":1}}],["lt",{"2":{"19":1,"50":1}}],["len",{"2":{"3":1,"4":1,"5":1,"6":1,"7":1,"8":2,"43":1,"47":1,"52":2,"74":2}}],["let",{"2":{"2":4,"3":2,"8":1,"18":1,"22":1,"23":1,"24":1,"25":1,"26":2,"27":1,"30":2,"31":1,"32":3,"33":1,"34":1,"41":2,"42":1,"47":1,"49":1,"50":2,"54":1,"59":2,"60":4,"61":2,"62":3,"64":4,"65":3,"68":1,"70":4,"71":3,"74":8}}],["末端位置的元素将为none",{"2":{"5":1}}],["处的元素更新为",{"2":{"42":1}}],["处的元素",{"2":{"4":1,"42":1}}],["处插入元素",{"2":{"4":1}}],["赋给",{"2":{"4":1}}],["将获得第二个值",{"2":{"74":1}}],["将收到编译器的报错",{"2":{"72":1}}],["将多个值组合在一起可以组成复合类型",{"2":{"63":1}}],["将被转换后为0",{"2":{"58":1}}],["将链表的头节点看作队首",{"2":{"49":1}}],["将链表的尾节点看作队尾",{"2":{"49":1}}],["将索引",{"2":{"42":1}}],["将切换到下一个进程",{"2":{"38":1}}],["将头节点的指针修改指向至删除节点后面的节点",{"2":{"32":1}}],["将头节点指针指向插入节点",{"2":{"31":1}}],["将插入节点的指针指向原本第二节点",{"2":{"31":1}}],["将",{"2":{"4":1}}],["+=",{"2":{"22":1,"23":1,"24":1,"25":1,"26":1,"27":1,"43":2,"47":2,"49":1,"50":1,"54":1}}],["+1",{"2":{"19":1}}],["+n",{"2":{"18":2}}],["+0",{"2":{"18":2}}],["+",{"2":{"4":1,"5":1,"8":1,"18":3,"19":5,"24":1,"26":5,"50":4,"64":1,"65":1,"68":2,"70":1,"71":2,"73":1,"74":1}}],["functions",{"2":{"73":1}}],["function",{"2":{"66":5}}],["found",{"2":{"74":1}}],["fourth",{"2":{"65":1}}],["focus",{"2":{"72":1}}],["for",{"2":{"4":1,"5":1,"6":2,"7":1,"8":1,"18":3,"21":1,"23":1,"24":1,"25":2,"26":2,"27":1,"47":2,"60":1}}],["first",{"2":{"65":1}}],["find",{"2":{"7":1,"34":2}}],["false",{"2":{"61":1}}],["factorial",{"2":{"27":2}}],["f",{"2":{"61":1}}],["float",{"2":{"60":1}}],["f32",{"2":{"59":2}}],["f64",{"2":{"59":1,"64":2}}],["front",{"2":{"50":7}}],["fn关键字用来声明函数",{"2":{"66":1}}],["fn",{"2":{"3":1,"4":1,"5":1,"6":1,"7":1,"8":1,"18":1,"21":2,"22":1,"23":1,"24":1,"25":1,"26":1,"27":1,"30":1,"47":9,"49":7,"50":7,"54":6,"59":1,"60":1,"66":1,"67":1,"68":1,"70":2,"71":1,"74":1}}],["以便实现无缝播放",{"2":{"38":1}}],["以上述结构体为例",{"2":{"30":1}}],["以此类推",{"2":{"26":1}}],["以及支持快速添加和删除节点",{"2":{"38":1}}],["以及不同数据结构之间的关系有了一定的了解",{"2":{"16":1}}],["以及之后的所有元素向后移动一位",{"2":{"4":1}}],["以下将",{"2":{"2":1}}],["把索引",{"2":{"4":1}}],["当该作用域结束时",{"2":{"74":1}}],["当我们尝试改变一个前面指定为不可变的值时我们会得到编译期错误",{"2":{"72":1}}],["当plus函数有返回值时可行",{"2":{"70":1}}],["当超出索引来访问时",{"2":{"65":1}}],["当数组中的所有元素都相等时",{"2":{"65":1}}],["当使用",{"2":{"58":1}}],["当栈顶元素没有下一个元素时",{"2":{"54":1}}],["当把球放进筒时",{"2":{"52":1}}],["当front到数组尾端时",{"2":{"50":1}}],["当进行增删等操作时",{"2":{"47":1}}],["当然也可实现自己构造函数",{"2":{"41":1}}],["当然这些都还是很浅显的认知",{"2":{"16":1}}],["当时间片用完时",{"2":{"38":1}}],["当用户点击前进或后退按钮时",{"2":{"38":1}}],["当插入操作在链表的一端进行",{"2":{"38":1}}],["当插入和删除操作都在链表的一端进行时",{"2":{"38":1}}],["当前节点值等于target时",{"2":{"34":1}}],["当算法的运行时间跟输入数据n成正比时",{"2":{"23":1}}],["当算法的运行时间跟输入数据n的log成正比时",{"2":{"22":1}}],["当算法的运行时间跟输入数据n无关时",{"2":{"21":1}}],["当需要快速查找一个元素或其对应关系时",{"2":{"12":1}}],["当访问数组元素时",{"2":{"10":1}}],["当元素超出数组长度的时候",{"2":{"4":1}}],["当索引超出数组长度时会产生无效的访问",{"2":{"3":1}}],["rate",{"2":{"47":3}}],["range",{"2":{"3":1}}],["rand",{"2":{"3":5}}],["rc",{"2":{"28":3,"30":3,"31":2,"32":1,"33":2,"34":1,"49":9,"54":6}}],["rc即引用计数",{"2":{"28":1}}],["release时",{"2":{"58":1}}],["rear",{"2":{"50":1}}],["resize",{"2":{"47":2}}],["remove",{"2":{"44":2}}],["ref",{"2":{"49":1,"54":1}}],["refcell",{"2":{"28":2,"30":3,"31":2,"32":1,"33":2,"34":1,"49":7,"54":4}}],["reference",{"2":{"28":1}}],["return",{"2":{"24":2,"27":1,"32":1,"33":3,"34":3,"47":1,"50":1,"68":2}}],["recur",{"2":{"24":3,"27":2}}],["rev",{"2":{"4":1}}],["rng",{"2":{"3":1}}],["rust函数采用",{"2":{"66":1}}],["rust中的函数诸如fn",{"2":{"66":1}}],["rust中的整型",{"2":{"58":1}}],["rust标准库存在一种动态数组",{"2":{"65":1}}],["rust标量类型包括",{"2":{"57":1}}],["rustfn",{"2":{"62":1,"66":1,"67":1,"68":1,"70":1,"71":1}}],["rust的所有的数字类型都支持基本的数学运算",{"2":{"60":1}}],["rust默认的浮点类型是f64",{"2":{"59":1}}],["rust是一门静态类型语言",{"2":{"56":1}}],["rustuse",{"2":{"49":1}}],["rust\\tstruct",{"2":{"47":1}}],["rust\\tvec2",{"2":{"44":1,"45":1}}],["rust\\tlet",{"2":{"43":1,"46":1,"52":1}}],["rust\\tfn",{"2":{"41":1,"72":2,"74":1}}],["rust\\t",{"2":{"31":1,"32":1,"33":1,"34":1,"73":1}}],["rust\\tuse",{"2":{"28":1}}],["rust",{"2":{"2":4,"3":1,"4":1,"5":1,"6":1,"7":1,"8":1,"18":1,"21":1,"22":1,"23":1,"24":1,"25":1,"26":1,"30":1,"42":1,"50":1,"54":1,"58":1,"59":1,"60":1,"61":1,"62":1,"64":2,"65":2,"72":2,"74":1}}],[">i32",{"2":{"73":1}}],[">bool",{"2":{"49":1}}],[">usize",{"2":{"49":1}}],[">option",{"2":{"49":1}}],[">self",{"2":{"49":1}}],[">=",{"2":{"47":5}}],[">",{"2":{"3":1,"7":1,"21":2,"22":2,"23":1,"24":1,"25":1,"26":1,"27":1,"33":1,"34":1,"47":4,"49":1,"50":6,"54":5,"68":1}}],["eyed",{"2":{"62":1}}],["empty",{"2":{"49":1,"50":2,"52":2,"54":1}}],["end",{"2":{"49":13,"50":2}}],["enlarge",{"2":{"8":3}}],["expected",{"2":{"74":1}}],["expression",{"2":{"69":1}}],["exponential",{"2":{"26":1}}],["extend",{"2":{"2":1,"46":1,"47":3}}],["element",{"2":{"3":3,"5":1,"7":1,"47":3,"65":4}}],["按照元素排列递增",{"2":{"3":1}}],["看作数组",{"2":{"2":1}}],["一个具有返回值的函数声明的示例",{"2":{"68":1}}],["一个具有参数的函数声明的示例",{"2":{"67":1}}],["一个函数声明的示例",{"2":{"66":1}}],["一下以头插法实现栈的基本代码如下",{"2":{"54":1}}],["一下代码实现在头节点后插入节点",{"2":{"31":1}}],["一些数组的特性",{"2":{"50":1}}],["一些操作数对应的时间复杂度",{"2":{"19":1}}],["一直访问下一个节点",{"2":{"33":1}}],["一般情况下用作动态数组的类型",{"2":{"2":1}}],["一旦创建",{"2":{"0":1,"64":1,"65":1}}],["是执行一些操作但不返回值的指令",{"2":{"69":1}}],["是指数阶增长的典型例子",{"2":{"26":1}}],["是",{"2":{"2":1}}],["为了更深刻地理解栈是如何通过这两种数据结构实现的",{"2":{"53":1}}],["为了方便实现扩容",{"2":{"2":1}}],["为切片",{"2":{"2":1}}],["为数组",{"2":{"2":1}}],["不同于变量使用let声明",{"2":{"73":1}}],["不同于数组访问可以在o",{"2":{"33":1}}],["不能对不可变变量二次赋值",{"2":{"72":1}}],["不可变变量意味着一旦声明后值就不能改变",{"2":{"72":1}}],["不过你也可以选择让变量是可变的mutable",{"2":{"72":1}}],["不应该依赖补码处理整型溢出",{"2":{"58":1}}],["不断将新元素放入栈顶",{"2":{"52":1}}],["不指定长度时",{"2":{"2":1}}],["不初始化值",{"2":{"2":1}}],["中最高阶的项来决定",{"2":{"19":1}}],["中的常数项",{"2":{"18":1}}],["中",{"2":{"2":1}}],["在内部作用域内",{"2":{"74":1}}],["在函数中",{"2":{"68":1}}],["在很多语言中函数都是非常常见的存在",{"2":{"66":1}}],["在很多编程语言中并没有预先设定的栈数据结构",{"2":{"52":1}}],["在现代计算机中",{"2":{"59":1}}],["在调试模式",{"2":{"58":1}}],["在生活中有许多类似栈数据结构的例子",{"2":{"52":1}}],["在rust中mian函数是很多程序的入口",{"2":{"66":1}}],["在rust中",{"2":{"63":1,"72":1}}],["在rust中浮点类型分为单精度和双精度两种",{"2":{"59":1}}],["在rust中数组存在size和capacity两个概念",{"2":{"50":1}}],["在rust中使用智能指针rc来定义链表引用",{"2":{"28":1}}],["在中间插入元素",{"2":{"47":1}}],["在尾部插入元素",{"2":{"47":1}}],["在动手编写代码前",{"2":{"47":1}}],["在索引index处插入value",{"2":{"44":1}}],["在列表的末尾可以在o",{"2":{"44":1}}],["在许多高级编程语言的标准库中都初始了动态数组的构造方法",{"2":{"41":1}}],["在某些数据缓冲区的实现中",{"2":{"38":1}}],["在操作系统中",{"2":{"38":1}}],["在缓存淘汰",{"2":{"38":1}}],["在网页浏览器中",{"2":{"38":1}}],["在该方案中",{"2":{"38":1}}],["在环形链表中任一节点都可以作为头节点",{"2":{"37":1}}],["在这里我们删除头节点后的节点",{"2":{"32":1}}],["在数组有效索引范围内查找元素",{"2":{"7":1}}],["在数组的索引",{"2":{"4":1}}],["在数组中插入元素",{"2":{"4":1}}],["在",{"2":{"2":1,"68":1}}],["0",{"2":{"2":7,"3":1,"6":1,"7":1,"8":2,"18":5,"21":2,"22":1,"23":2,"24":1,"25":3,"26":3,"27":3,"30":1,"33":1,"42":2,"43":3,"47":3,"49":2,"50":5,"52":1,"54":1,"58":2,"59":2,"60":1,"64":2,"65":1,"72":3}}],["4",{"0":{"5":1,"24":1,"33":1,"36":1,"37":1,"38":1,"44":1,"61":1},"1":{"37":1,"38":1},"2":{"2":2,"26":2,"46":1,"48":1,"64":2}}],["30",{"2":{"73":2}}],["3表示每个元素的值",{"2":{"65":1}}],["3表示数组的长度",{"2":{"65":1}}],["32位",{"2":{"58":1}}],["3n+2",{"2":{"19":1}}],["3n+1次等",{"2":{"18":1}}],["3",{"0":{"4":1,"20":1,"21":1,"22":1,"23":2,"24":1,"25":1,"26":1,"27":1,"32":1,"35":1,"43":1,"59":1,"60":1},"1":{"21":1,"22":1,"23":1,"24":1,"25":1,"26":1,"27":1},"2":{"2":2,"18":1,"41":1,"44":2,"52":1,"59":1,"65":9}}],["20",{"2":{"60":1}}],["256",{"2":{"58":1}}],["255",{"2":{"58":1}}],["2^",{"2":{"26":2}}],["2^n^",{"2":{"58":2}}],["2^n个细胞",{"2":{"26":1}}],["2^n",{"2":{"19":2,"26":1,"58":1}}],["2n^2",{"2":{"19":1}}],["2n",{"2":{"19":2}}],["2",{"0":{"3":1,"15":1,"19":1,"22":1,"29":1,"30":1,"31":2,"32":1,"33":1,"34":1,"38":1,"42":1,"47":1,"50":1,"53":1,"54":1,"55":2,"63":1,"64":1,"65":2,"71":1},"1":{"30":1,"31":1,"32":1,"33":1,"34":1,"54":1,"55":1,"64":1,"65":1},"2":{"2":2,"15":1,"17":1,"18":3,"22":1,"24":2,"26":3,"30":1,"41":1,"47":1,"52":1,"59":1,"60":4,"64":1,"65":2,"74":2}}],["=>",{"2":{"49":2,"54":2}}],["=n∗",{"2":{"27":1}}],["=n2+n",{"2":{"18":1}}],["==",{"2":{"7":1,"19":1,"27":1,"34":1,"47":1,"49":1,"50":2,"54":1}}],["=",{"2":{"2":3,"3":2,"4":2,"5":1,"8":2,"18":2,"22":2,"23":1,"24":2,"25":1,"26":5,"27":1,"30":5,"31":3,"32":4,"33":2,"34":1,"41":2,"42":2,"43":2,"46":1,"47":11,"49":7,"50":7,"52":4,"54":6,"59":2,"60":4,"61":2,"62":3,"64":11,"65":3,"68":1,"70":4,"71":3,"72":4,"73":3,"74":8}}],["5表示数组的长度",{"2":{"65":1}}],["500",{"2":{"64":2}}],["5向下取整",{"2":{"60":1}}],["5",{"0":{"6":1,"25":1,"34":1,"45":1,"62":1},"2":{"2":8,"18":1,"41":1,"60":1,"65":1,"67":2,"68":1,"70":2,"71":1,"73":2,"74":2}}],["immutable",{"2":{"72":1}}],["implementation",{"2":{"60":1}}],["impl",{"2":{"49":2,"50":1,"54":1}}],["i128",{"2":{"58":1}}],["i16",{"2":{"58":1}}],["i64",{"2":{"58":1}}],["i8",{"2":{"58":1}}],["i+1",{"2":{"47":1}}],["item",{"2":{"43":2}}],["isize",{"2":{"58":2}}],["is",{"2":{"32":1,"49":1,"50":2,"52":2,"54":1,"65":4,"67":1,"68":1,"74":2}}],["if",{"2":{"7":1,"24":1,"27":1,"32":2,"33":2,"34":2,"47":5,"50":2}}],["i",{"2":{"4":3,"5":3,"6":4,"7":3,"8":3,"18":2,"21":2,"23":1,"25":1,"43":2,"47":5}}],["integer",{"2":{"60":1}}],["into",{"2":{"49":1,"54":1}}],["inner",{"2":{"49":1,"54":1,"74":1}}],["inite",{"2":{"30":1}}],["in",{"2":{"4":1,"5":1,"6":2,"7":1,"8":1,"18":3,"21":1,"23":1,"24":1,"25":2,"26":2,"27":1,"43":2,"47":2,"73":1,"74":1}}],["insert",{"2":{"4":1,"31":1,"44":1}}],["index+1",{"2":{"34":1,"47":1}}],["index",{"2":{"0":1,"3":2,"4":6,"5":2,"33":4,"34":4,"44":2,"47":15}}],["i32>",{"2":{"41":2,"47":1,"50":1}}],["i32",{"2":{"2":6,"3":2,"4":2,"5":1,"6":1,"7":2,"8":1,"18":1,"21":4,"22":2,"23":2,"24":3,"25":2,"26":2,"27":2,"28":1,"33":1,"34":2,"42":1,"47":5,"49":3,"50":9,"54":1,"58":2,"64":4,"67":1,"68":2,"70":2,"71":1,"73":3}}],["and",{"2":{"73":1}}],["another",{"2":{"66":4}}],["a=",{"2":{"60":2}}],["are",{"2":{"73":1}}],["arch",{"2":{"58":1}}],["arrayqueue",{"2":{"50":4}}],["array这个概念来实现列表",{"2":{"39":1}}],["array",{"2":{"2":1,"35":1,"63":1}}],["arr",{"2":{"2":1,"3":3,"6":4,"7":3,"8":7}}],["add",{"2":{"47":2,"58":1}}],["acess",{"2":{"33":1}}],["access",{"2":{"33":1}}],["assign",{"2":{"72":1}}],["as",{"2":{"24":1,"49":1,"50":3,"54":1}}],["ascii",{"2":{"12":2}}],["alice",{"2":{"65":2}}],["alog",{"2":{"21":2}}],["algorithm",{"2":{"18":1}}],["a",{"2":{"2":1,"18":3,"60":4,"65":1,"71":2}}],["15",{"2":{"68":1}}],["12",{"2":{"74":2}}],["127",{"2":{"58":1}}],["128",{"2":{"58":1}}],["128位",{"2":{"58":1}}],["1^",{"2":{"58":1}}],["16位",{"2":{"58":1}}],["11",{"2":{"44":1}}],["1次",{"2":{"33":1}}],["1000",{"2":{"21":1}}],["10000n^2",{"2":{"19":1}}],["1000000",{"2":{"19":1}}],["10",{"2":{"19":1,"60":1,"68":2,"71":1,"72":3}}],["1",{"0":{"1":1,"2":2,"3":1,"4":1,"5":1,"6":1,"7":1,"8":1,"14":1,"18":1,"21":2,"28":1,"30":1,"37":1,"40":1,"41":2,"42":1,"43":1,"44":1,"45":1,"46":1,"49":1,"52":1,"54":1,"57":1,"58":2,"59":1,"60":1,"61":1,"62":1,"64":1,"70":1},"1":{"2":1,"3":1,"4":1,"5":1,"6":1,"7":1,"8":1,"41":1,"42":1,"43":1,"44":1,"45":1,"46":1,"58":1,"59":1,"60":1,"61":1,"62":1},"2":{"2":2,"3":1,"4":2,"5":2,"10":1,"14":1,"17":1,"18":6,"19":1,"22":2,"23":1,"24":3,"25":1,"26":7,"27":3,"30":1,"33":2,"34":1,"35":3,"41":1,"42":5,"44":1,"47":6,"49":2,"50":4,"52":1,"54":2,"58":3,"64":4,"65":2,"70":1,"71":2,"73":1,"74":2}}]],"serializationVersion":2}';export{t as default};
